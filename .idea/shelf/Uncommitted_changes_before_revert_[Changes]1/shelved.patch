Index: buildozer.spec
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[app]\n\n# (str) Title of your application\ntitle = Elide\n\n# (str) Package name\npackage.name = Elide\n\n# (str) Package domain (needed for android/ios packaging)\npackage.domain = org.tacmeta\n\n# (str) Source code where the main.py live\nsource.dir = .\n\n# (list) Source files to include (let empty to include all the files)\nsource.include_exts = py,png,jpg,kv,atlas,ini,sqlite3\n\n# (list) List of inclusions using pattern matching\n#source.include_patterns = assets/*,images/*.png\n# source.include_patterns = elide/elide/assets/*, elide/elide/elide.kv\n\n# (list) Source files to exclude (let empty to not exclude anything)\n#source.exclude_exts = spec\n\n# (list) List of directory to exclude (let empty to not exclude anything)\nsource.exclude_dirs = bin,.buildozer,.tox,build,dist,lisien,elide\n\n# (list) List of exclusions using pattern matching\n# Do not prefix with './'\n#source.exclude_patterns = license,images/*/*.jpg\n\n# (str) Application versioning (method 1)\nversion = 0.21.4\n\n# (str) Application versioning (method 2)\n# version.regex = __version__ = ['\"](.*)['\"]\n# version.filename = %(source.dir)s/main.py\n\n# (list) Application requirements\n# comma separated e.g. requirements = sqlite3,kivy\nrequirements = python3,kivy,msgpack,numpy,sqlite3,networkx,astunparse,blinker,sqlalchemy,typing_extensions,tblib,pygments,libbz2,liblzma,python-osc,lisien,elide,android,androidstorage4kivy,annotated-types\n\n# (str) Custom source folders for requirements\n# Sets custom source for any requirements with recipes\n# requirements.source.kivy = ../../kivy\nrequirements.source.lisien = ./lisien\nrequirements.source.elide = ./elide\n\n# (str) Presplash of the application\n#presplash.filename = %(source.dir)s/data/presplash.png\n\n# (str) Icon of the application\n#icon.filename = %(source.dir)s/data/icon.png\nicon.filename = %(source.dir)s/elide_icon/Android/icon_512px.png\n\n\n# (list) Supported orientations\n# Valid options are: landscape, portrait, portrait-reverse or landscape-reverse\norientation = landscape\n\n# (list) List of service to declare\n#services = worker0:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker1:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker2:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker3:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker4:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker5:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker6:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker7:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker8:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker9:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker10:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker11:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker12:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker13:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker14:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker15:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker16:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker17:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker18:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker19:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker20:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker21:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker22:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker23:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker24:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker25:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker26:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker27:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker28:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker29:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker30:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker31:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker32:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker33:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker34:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker35:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker36:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker37:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker38:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker39:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker40:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker41:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker42:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker43:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker44:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker45:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker46:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker47:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker48:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker49:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker50:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker51:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker52:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker53:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker54:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker55:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker56:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker57:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker58:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker59:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker60:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker61:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker62:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#    worker63:_python_bundle/site-packages/lisien/services/worker.py:foreground,\n#\tcore:_python_bundle/site-packages/lisien/services/core.py\n\n#\n# OSX Specific\n#\n\n#\n# author = © Copyright Info\n\n# change the major version of python used by the app\nosx.python_version = 3\n\n# Kivy version to use\nosx.kivy_version = 2.3.1\n\n#\n# Android specific\n#\n\n# (bool) Indicate if the application should be fullscreen or not\nfullscreen = 1\n\n# (string) Presplash background color (for android toolchain)\n# Supported formats are: #RRGGBB #AARRGGBB or one of the following names:\n# red, blue, green, black, white, gray, cyan, magenta, yellow, lightgray,\n# darkgray, grey, lightgrey, darkgrey, aqua, fuchsia, lime, maroon, navy,\n# olive, purple, silver, teal.\n#android.presplash_color = #FFFFFF\n\n# (string) Presplash animation using Lottie format.\n# see https://lottiefiles.com/ for examples and https://airbnb.design/lottie/\n# for general documentation.\n# Lottie files can be created using various tools, like Adobe After Effect or Synfig.\n#android.presplash_lottie = \"path/to/lottie/file.json\"\n\n# (str) Adaptive icon of the application (used if Android API level is 26+ at runtime)\n#icon.adaptive_foreground.filename = %(source.dir)s/data/icon_fg.png\n#icon.adaptive_background.filename = %(source.dir)s/data/icon_bg.png\n\n# (list) Permissions\n# (See https://python-for-android.readthedocs.io/en/latest/buildoptions/#build-options-1 for all the supported syntaxes and properties)\nandroid.permissions = (name=android.permission.WRITE_EXTERNAL_STORAGE),android.permission.READ_MEDIA_IMAGES\n\n# (list) features (adds uses-feature -tags to manifest)\n#android.features = android.hardware.usb.host\n\n# (int) Target Android API, should be as high as possible.\n#android.api = 31\n\n# (int) Minimum API your APK / AAB will support.\nandroid.minapi = 28\n\n# (int) Android SDK version to use\n#android.sdk = 20\n\n# (str) Android NDK version to use\n#android.ndk = 23b\n\n# (int) Android NDK API to use. This is the minimum API your app will support, it should usually match android.minapi.\n#android.ndk_api = 21\n\n# (bool) Use --private data storage (True) or --dir public storage (False)\nandroid.private_storage = True\n\n# (str) Android NDK directory (if empty, it will be automatically downloaded.)\n#android.ndk_path =\n\n# (str) Android SDK directory (if empty, it will be automatically downloaded.)\n#android.sdk_path = /home/sanotehu/.buildozer/android-studio\n\n# (str) ANT directory (if empty, it will be automatically downloaded.)\n#android.ant_path =\n\n# (bool) If True, then skip trying to update the Android sdk\n# This can be useful to avoid excess Internet downloads or save time\n# when an update is due and you just want to test/build your package\n# android.skip_update = False\n\n# (bool) If True, then automatically accept SDK license\n# agreements. This is intended for automation only. If set to False,\n# the default, you will be shown the license when first running\n# buildozer.\n# android.accept_sdk_license = False\n\n# (str) Android entry point, default is ok for Kivy-based app\n#android.entrypoint = org.kivy.android.PythonActivity\n\n# (str) Full name including package path of the Java class that implements Android Activity\n# use that parameter together with android.entrypoint to set custom Java class instead of PythonActivity\n#android.activity_class_name = org.kivy.android.PythonActivity\n\n# (str) Extra xml to write directly inside the <manifest> element of AndroidManifest.xml\n# use that parameter to provide a filename from where to load your custom XML code\n#android.extra_manifest_xml = ./src/android/extra_manifest.xml\n\n# (str) Extra xml to write directly inside the <manifest><application> tag of AndroidManifest.xml\n# use that parameter to provide a filename from where to load your custom XML arguments:\n#android.extra_manifest_application_arguments = ./src/android/extra_manifest_application_arguments.xml\n\n# (str) Full name including package path of the Java class that implements Python Service\n# use that parameter to set custom Java class which extends PythonService\nandroid.service_class_name = org.kivy.android.PythonService\n\n# (str) Android app theme, default is ok for Kivy-based app\n# android.apptheme = \"@android:style/Theme.NoTitleBar\"\n\n# (list) Pattern to whitelist for the whole project\n#android.whitelist =\n\n# (str) Path to a custom whitelist file\n#android.whitelist_src =\n\n# (str) Path to a custom blacklist file\n#android.blacklist_src =\n\n# (list) List of Java .jar files to add to the libs so that pyjnius can access\n# their classes. Don't add jars that you do not need, since extra jars can slow\n# down the build process. Allows wildcards matching, for example:\n# OUYA-ODK/libs/*.jar\n#android.add_jars = foo.jar,bar.jar,path/to/more/*.jar\n\n# (list) List of Java files to add to the android project (can be java or a\n# directory containing the files)\n#android.add_src =\n\n# (list) Android AAR archives to add\n#android.add_aars =\n\n# (list) Put these files or directories in the apk assets directory.\n# Either form may be used, and assets need not be in 'source.include_exts'.\n# 1) android.add_assets = source_asset_relative_path\n# 2) android.add_assets = source_asset_path:destination_asset_relative_path\nandroid.add_assets = elide/elide/assets:elide/assets\n\n# (list) Put these files or directories in the apk res directory.\n# The option may be used in three ways, the value may contain one or zero ':'\n# Some examples:\n# 1) A file to add to resources, legal resource names contain ['a-z','0-9','_']\n# android.add_resources = my_icons/all-inclusive.png:drawable/all_inclusive.png\n# 2) A directory, here  'legal_icons' must contain resources of one kind\n# android.add_resources = legal_icons:drawable\n# 3) A directory, here 'legal_resources' must contain one or more directories, \n# each of a resource kind:  drawable, xml, etc...\n# android.add_resources = legal_resources\n#android.add_resources =\n\n# (list) Gradle dependencies to add\n#android.gradle_dependencies =\n\n# (bool) Enable AndroidX support. Enable when 'android.gradle_dependencies'\n# contains an 'androidx' package, or any package from Kotlin source.\n# android.enable_androidx requires android.api >= 28\n#android.enable_androidx = True\n\n# (list) add java compile options\n# this can for example be necessary when importing certain java libraries using the 'android.gradle_dependencies' option\n# see https://developer.android.com/studio/write/java8-support for further information\n# android.add_compile_options = \"sourceCompatibility = 1.8\", \"targetCompatibility = 1.8\"\n\n# (list) Gradle repositories to add {can be necessary for some android.gradle_dependencies}\n# please enclose in double quotes \n# e.g. android.gradle_repositories = \"maven { url 'https://kotlin.bintray.com/ktor' }\"\n#android.add_gradle_repositories =\n\n# (list) packaging options to add \n# see https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.PackagingOptions.html\n# can be necessary to solve conflicts in gradle_dependencies\n# please enclose in double quotes \n# e.g. android.add_packaging_options = \"exclude 'META-INF/common.kotlin_module'\", \"exclude 'META-INF/*.kotlin_module'\"\n#android.add_packaging_options =\n\n# (list) Java classes to add as activities to the manifest.\n#android.add_activities = com.example.ExampleActivity\n\n# (str) OUYA Console category. Should be one of GAME or APP\n# If you leave this blank, OUYA support will not be enabled\n#android.ouya.category = GAME\n\n# (str) Filename of OUYA Console icon. It must be a 732x412 png image.\n#android.ouya.icon.filename = %(source.dir)s/data/ouya_icon.png\n\n# (str) XML file to include as an intent filters in <activity> tag\n#android.manifest.intent_filters =\n\n# (list) Copy these files to src/main/res/xml/ (used for example with intent-filters)\n#android.res_xml = PATH_TO_FILE,\n\n# (str) launchMode to set for the main activity\n#android.manifest.launch_mode = standard\n\n# (str) screenOrientation to set for the main activity.\n# Valid values can be found at https://developer.android.com/guide/topics/manifest/activity-element\n#android.manifest.orientation = fullSensor\n\n# (list) Android additional libraries to copy into libs/armeabi\n#android.add_libs_armeabi = libs/android/*.so\n#android.add_libs_armeabi_v7a = libs/android-v7/*.so\n#android.add_libs_arm64_v8a = libs/android-v8/*.so\n#android.add_libs_x86 = libs/android-x86/*.so\n#android.add_libs_mips = libs/android-mips/*.so\n\n# (bool) Indicate whether the screen should stay on\n# Don't forget to add the WAKE_LOCK permission if you set this to True\n#android.wakelock = False\n\n# (list) Android application meta-data to set (key=value format)\n#android.meta_data =\n\n# (list) Android library project to add (will be added in the\n# project.properties automatically.)\n#android.library_references =\n\n# (list) Android shared libraries which will be added to AndroidManifest.xml using <uses-library> tag\n#android.uses_library =\n\n# (str) Android logcat filters to use\nandroid.logcat_filters = *:S python:D\n\n# (bool) Android logcat only display log for activity's pid\n#android.logcat_pid_only = False\n\n# (str) Android additional adb arguments\n#android.adb_args = -H host.docker.internal\n\n# (bool) Copy library instead of making a libpymodules.so\n#android.copy_libs = 1\n\n# (list) The Android archs to build for, choices: armeabi-v7a, arm64-v8a, x86, x86_64\n# In past, was `android.arch` as we weren't supporting builds for multiple archs at the same time.\nandroid.archs = arm64-v8a, armeabi-v7a\n\n# (int) overrides automatic versionCode computation (used in build.gradle)\n# this is not the same as app version and should only be edited if you know what you're doing\n# android.numeric_version = 1\n\n# (bool) enables Android auto backup feature (Android API >=23)\nandroid.allow_backup = True\n\n# (str) XML file for custom backup rules (see official auto backup documentation)\n# android.backup_rules =\n\n# (str) If you need to insert variables into your AndroidManifest.xml file,\n# you can do so with the manifestPlaceholders property.\n# This property takes a map of key-value pairs. (via a string)\n# Usage example : android.manifest_placeholders = [myCustomUrl:\\\"org.kivy.customurl\\\"]\n# android.manifest_placeholders = [:]\n\n# (bool) Skip byte compile for .py files\nandroid.no-byte-compile-python = True\n\n# (str) The format used to package the app for release mode (aab or apk or aar).\n# android.release_artifact = aab\n\n# (str) The format used to package the app for debug mode (apk or aar).\n# android.debug_artifact = apk\n\n#\n# Python for android (p4a) specific\n#\n\n# (str) python-for-android URL to use for checkout\n# p4a.url = git@github.com:T-Dynamos/python-for-android.git\n\n# (str) python-for-android fork to use in case if p4a.url is not specified, defaults to upstream (kivy)\n#p4a.fork = kivy\n\n# (str) python-for-android branch to use, defaults to master\np4a.branch = develop\n\n# (str) python-for-android specific commit to use, defaults to HEAD, must be within p4a.branch\n#p4a.commit = HEAD\n\n# (str) python-for-android git clone directory (if empty, it will be automatically cloned from github)\n# p4a.source_dir = /home/sanotehu/src/python-for-android\n\n# (str) The directory in which python-for-android should look for your own build recipes (if any)\np4a.local_recipes = ./recipes\n\n# (str) Filename to the hook for p4a\n#p4a.hook =\n\n# (str) Bootstrap to use for android builds\n# p4a.bootstrap = sdl2\n\n# (int) port number to specify an explicit --port= p4a argument (eg for bootstrap flask)\n#p4a.port =\n\n# Control passing the --use-setup-py vs --ignore-setup-py to p4a\n# \"in the future\" --use-setup-py is going to be the default behaviour in p4a, right now it is not\n# Setting this to false will pass --ignore-setup-py, true will pass --use-setup-py\n# NOTE: this is general setuptools integration, having pyproject.toml is enough, no need to generate\n# setup.py if you're using Poetry, but you need to add \"toml\" to source.include_exts.\n# p4a.setup_py = false\n\n# (str) extra command line arguments to pass when invoking pythonforandroid.toolchain\n#p4a.extra_args =\n\n\n\n#\n# iOS specific\n#\n\n# (str) Path to a custom kivy-ios folder\n#ios.kivy_ios_dir = ../kivy-ios\n# Alternately, specify the URL and branch of a git checkout:\nios.kivy_ios_url = https://github.com/kivy/kivy-ios\nios.kivy_ios_branch = master\n\n# Another platform dependency: ios-deploy\n# Uncomment to use a custom checkout\n#ios.ios_deploy_dir = ../ios_deploy\n# Or specify URL and branch\nios.ios_deploy_url = https://github.com/phonegap/ios-deploy\nios.ios_deploy_branch = 1.10.0\n\n# (bool) Whether or not to sign the code\nios.codesign.allowed = false\n\n# (str) Name of the certificate to use for signing the debug version\n# Get a list of available identities: buildozer ios list_identities\n#ios.codesign.debug = \"iPhone Developer: <lastname> <firstname> (<hexstring>)\"\n\n# (str) The development team to use for signing the debug version\n#ios.codesign.development_team.debug = <hexstring>\n\n# (str) Name of the certificate to use for signing the release version\n#ios.codesign.release = %(ios.codesign.debug)s\n\n# (str) The development team to use for signing the release version\n#ios.codesign.development_team.release = <hexstring>\n\n# (str) URL pointing to .ipa file to be installed\n# This option should be defined along with `display_image_url` and `full_size_image_url` options.\n#ios.manifest.app_url =\n\n# (str) URL pointing to an icon (57x57px) to be displayed during download\n# This option should be defined along with `app_url` and `full_size_image_url` options.\n#ios.manifest.display_image_url =\n\n# (str) URL pointing to a large icon (512x512px) to be used by iTunes\n# This option should be defined along with `app_url` and `display_image_url` options.\n#ios.manifest.full_size_image_url =\n\n\n[buildozer]\n\n# (int) Log level (0 = error only, 1 = info, 2 = debug (with command output))\nlog_level = 2\n\n# (int) Display warning if buildozer is run as root (0 = False, 1 = True)\nwarn_on_root = 1\n\n# (str) Path to build artifact storage, absolute or relative to spec file\n# build_dir = ./.buildozer\n\n# (str) Path to build output (i.e. .apk, .aab, .ipa) storage\n# bin_dir = ./bin\n\n#    -----------------------------------------------------------------------------\n#    List as sections\n#\n#    You can define all the \"list\" as [section:key].\n#    Each line will be considered as a option to the list.\n#    Let's take [app] / source.exclude_patterns.\n#    Instead of doing:\n#\n#[app]\n#source.exclude_patterns = license,data/audio/*.wav,data/images/original/*\n#\n#    This can be translated into:\n#\n#[app:source.exclude_patterns]\n#license\n#data/audio/*.wav\n#data/images/original/*\n#\n\n\n#    -----------------------------------------------------------------------------\n#    Profiles\n#\n#    You can extend section / key with a profile\n#    For example, you want to deploy a demo version of your application without\n#    HD content. You could first change the title to add \"(demo)\" in the name\n#    and extend the excluded directories to remove the HD content.\n#\n#[app@demo]\n#title = My Application (demo)\n#\n#[app:source.exclude_patterns@demo]\n#images/hd/*\n#\n#    Then, invoke the command line with the \"demo\" profile:\n#\n#buildozer --profile demo android debug\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/buildozer.spec b/buildozer.spec
--- a/buildozer.spec	(revision 88a2449a682cf4ee82f65c7754adf3cbed014cf5)
+++ b/buildozer.spec	(date 1756277794082)
@@ -30,7 +30,7 @@
 #source.exclude_patterns = license,images/*/*.jpg
 
 # (str) Application versioning (method 1)
-version = 0.21.4
+version = 0.21.5
 
 # (str) Application versioning (method 2)
 # version.regex = __version__ = ['"](.*)['"]
Index: CHANGES.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>== 0.21.4 | 2025-08-27 ==\n* Fix an issue causing some valid exported games not to import right in Elide,\n  causing an empty map and a freeze\n* Add ↑ and ↓ buttons to rules in Elide, for you to reorder them\n\n== 0.21.3 | 2025-08-21 ==\n* Fix Elide's session management; exiting and resuming a game weren't always\n  really doing that.\n* Removed the remainder of the parallelism on Android, because that was causing\n  issues with starting the game. I'll try again once python-for-android can\n  deploy Python 3.14 and its new `concurrent.interpreters` module.\n\n== 0.21.2 | 2025-08-13 ==\n* Fix a packaging issue that was causing Elide's main menu not to show up.\n  0.21.1 was meant to fix the same, but didn't really.\n\n== 0.21.0 | 2025-08-10 ==\n* Added the `bookmark` mapping/method. This is a convenient way to store points\n  in time and travel to them. You can call it with whatever name you want to\n  give your bookmark to make a new one, then call it with that name again\n  to travel back to that time. Bookmarks are not versioned. If you want\n  a point in time that changes in response to time travel, store the time in\n  the engine's `universal` mapping.\n* Added support for storing the value `None`. Values deleted from dictionaries\n  are now represented by the ellipsis object.\n* Renamed the `user` property of nodes to `leader`.\n* Removed what remained of multigraphs, which may never be supported. This\n  changed the database schema, so old playthroughs are incompatible.\n* Generally decrufted the codebase.\n\n== 0.20.2 | 2025-08-03 ==\n* Overhauled the internal `WindowDict` class and its relatives, ruling out\n  a bunch of race conditions that caused intermittent crashes\n* Made deltas behave more consistently, ruling out some types of data loss\n* Overhauled the tracking of units and users\n* Made entity deletion *really* atomic, this time\n* Fixed keyframe snaps sometimes happening after a change had been recorded\n  to the database, but before it had been cached, resulting in the loss of\n  a single change to the game state\n* Fixed deleting keyframes\n\n== 0.20.1 | 2025-07-17 ==\n* Unify the fast delta code, fixing some changes getting left out of deltas\n* Fix tracking of units' users\n* Finish up the proxy interface\n* Fix setting mutable values (like list and dict) in the `universal` mapping\n* Fix tracking which rules were already handled\n* Fix intermittent crash from attempting to serialize Things whose locations \n  aren't available\n\n== 0.20.0 | 2025-07-07 ==\n* Android support. Currently, the Android version supports only SQLite, not\n  ParquetDB. Parallelism is disabled for now, too, because it increases the\n  startup time too much.\n* A main menu for Elide. If you don't want it, specify the path to your game\n  folder on the command line, and Elide will launch straight into that game.\n* Support Python 3.13.\n* Crash fixes\n  * When resuming a game that was closed at the very beginning of a branch\n  * Intermittently when deleting entities, if an automatic keyframe snap\n    happened to occur mid-deletion. Fixed by making deletion atomic.\n\n== 0.19.3 | 2025-05-23 ==\n* Fix keyframes sometimes getting made every tick, if the automatic keyframe\n  creation was overridden\n* Require ParquetDB version 1.0.1, fix some freezes that could occur when\n  loading empty ParquetDB tables and a data integrity issue with the rules-\n  handledness tracking\n* Performance improvements when using plans with ParquetDB\n* Fixed worker processes sometimes staying open when there's nothing left to do\n\n== 0.19.2  | 2025-04-26 ==\n* Added the option to run Lisien without connecting to any database. This is\n  mainly useful for testing. Instantiate the engine like `Engine(None)` to use.\n* Rewrote the string store, `Engine.string`, to save any changes you make while\n  the engine is running, like it was supposed to be doing. Use it like a\n  dictionary with both the keys and the values being strings, and set its\n  `language` property to change to another language. These strings don't react\n  to time travel at all; it's just a convenient interface to some JSON files.\n* More refactoring.\n\n== 0.19.1 | 2025-04-19 ==\n* Fixed big rules not resetting the time at the end of a plan block\n* Fixed character rulebooks becoming unset after some time travel operations\n* Fixed picking a starting directory in Elide\n* Removed `threaded_triggers` option; triggers are now serial when there are\n  no workers, parallel if there are workers to go parallel with. I plan to\n  make a kind of worker \"process\" that's really a thread.\n* Fixed loading node and portal rulebooks from keyframes\n* Fixed loading things' locations from keyframes\n\n== 0.19.0 | 2025-04-13 ==\nCore:\n* Switched the default storage backend to ParquetDB, which is far more space-efficient.\n  Use the `connect_string` parameter if you want a SQL database, which\n  is still required for historical queries (for now).\n* The engine's `time` property now includes the tick, as well as the branch and\n  turn.\n* Added the ability to record \"replays\" of Elide sessions. They run the same\n  commands on the Lisien core that Elide would. You won't really be able\n  to play them back, exactly, but if you set a replayfile in elide.ini's [lisien]\n  section, then send the file to me, I'll be able to reproduce whatever bug you\n  ran into.\n* When using the proxy interface, you can register functions to be called\n  whenever the time changes, as `engine_proxy.time.connect(function)`; or\n  whenever the rules engine has simulated a turn, as\n  `engine_proxy.next_turn.connect(function)`. Also available in the core proper.\n* Filled in some missing parts of the proxy API.\n* Fixed inconsistent handling of planned changes.\n* Fixed some intermittent interprocess sync issues that could result in crashes\n  or freezes.\n* Database integrity issues, too.\n* Fixed Thing objects sometimes hanging around after deletion, depending on\n  when you closed the engine.\n* The old allegedb submodule no longer exists. Its functionality is now part of\n  Lisien proper.\nElide frontend:\n* Fixed stats running off the left of the window.\n* Fixed the grid view not being visible.\n* Fixed configuration of the stat widgets.\n\n== 0.18.3 | 2025-02-23 ==\n* Fix major memory leaks\n\n== 0.18.2 | 2025-02-20 ==\n* A crash fix relating to the unloading code, which was too eager\n\n== 0.18.1 | 2025-02-14 ==\n* Crash fixes\n\n== 0.18.0 | 2025-02-13 ==\n* Changed name of \"LiSE\" to \"Lisien\" -- thanks to https://webb.page for the name\n* Changed name of \"ELiDE\" to \"Elide\"\n(letters cased like normal English if that's what you're writing,\n\"elide\" and \"lisien\" in Python)\n* Rules may now be designated \"big,\" which will enable an optimization to\n  only write the changes they make to the world after they're all computed.\n* Neighborhoods get keyframed properly, now, the same as other rule attributes.\n* Added Kenney graphics, and changed the default background to Kenney's parchment\n* Fixed rules displaying out of order in the stepper\n* Fixed dragged objects dropping when they shouldn't\n* Improved locking for caches, fixing some intermittent data loss\n* Dropped support for Python 3.8 and 3.9\n\n== 0.17.2 | 2024-11-30 ==\n* Fix rule poller. It only worked for some rulebook types before.\n* Performance improvements as a result of new caching behavior for the above.\n\n== 0.17.1 | 2024-11-09 ==\n* Disable editing all throughout ELiDE whenever the simulation is running.\n  It was only disabled sometimes, in some parts of the UI.\n* Add a button to edit a function card without backing out of the rule editor\n* Fix ELiDE crash in Python 3.8 when making more than one new Place or Thing\n\n\n== 0.17.0 | 2024-10-31 ==\n* Overhaul the entire caching infrastructure, which should greatly cut down on\n  crashes. No new features, but it does make some changes to the database\n  schema.\n\n== 0.16.16 | 2024-10-18 ==\n* Fix pawn duplication in ELiDE\n\n== 0.16.15 | 2024-10-16 ==\n* Fix a different way pawns could disappear in ELiDE\n\n== 0.16.14 | 2024-10-16 ==\n* Fix disappearing pawns in ELiDE\n\n== 0.16.13 | 2024-10-16 ==\n* Fix worker process states getting desynchronized when you made a new character\n* Fix methods not being callable in worker processes\n* Improved performance when planning a lot of future state\n* Made the LiSE engine itself an Executor, which I guess breaks compatibility.\n\tWhatever, zerover makes no promises. Use `Engine.submit(..)` to schedule\n\tcomputation in worker processes now.\n* Made ELiDE's stat list scrollable\n\n== 0.16.2 & 0.16.12 | 2024-10-14 ==\n* Fix ELiDE crash when adding graph-shaped world state to a grid-shaped world\n\n== 0.16.1 | 2024-10-13 ==\n* Fix some incoherent world state that could result from doing things\n\ton tick zero of turn zero, if you started the world with a NetworkX graph.\n* Fix a rule running when it shouldn't have in the wolfsheep example\n\n== 0.16.0 | 2024-10-11 ==\n* A process pool. When you've stored a function in LiSE, you can `submit` it\n\tto `Engine.pool.submit(..)` using the standard Python\n\t`concurrent.futures.Executor` API. The worker processes all have read-only\n\tviews on the state of the simulation.\n* Trigger functions now run in parallel by default. Set the `workers` option\n\tto 0 to disable this.\n* Neighborhoods. If your rule only runs when something changes near the Thing\n\tor Place it runs on, you can indicate this by setting the rule's\n\tneighborhood property to an integer, and your sim will run faster.\n\tSee \"Getting started\" in the README for an example.\n* ELiDE once again updates its graphics in response to events in the LiSE core\n\t-- set the \"_image_paths\" of a `Thing` or `Place` object to a list of\n\tpaths.\n\n\n== 0.15.9 | 2024-09-01 ==\n* More data corruption fixes\n\n== 0.15.8 | 2024-09-01 ==\n* More concurrency fixes\n\n== 0.15.7 | 2024-08-27 ==\n* A variety of database corruption fixes\n\n== 0.15.6 | 2024-08-16 ==\n* Fix Thing objects occasionally forgetting their location\n\n== 0.15.5 | 2024-08-10 ==\n* Fix a crash when resuming ELiDE in the past of a simulation\n* Fix rules sometimes not triggering, based on when the trigger was set\n\n== 0.15.4 | 2024-08-08 ==\n* Fix time travel via rule stepper\n* Restore the ability to delete Characters\n* Even faster interbranch time travel\n* Fix a crash when time traveling between times with no changes to the world\n\n== 0.15.3 | 2024-07-22 ==\n* More crash fixes\n\n== 0.15.2 | 2024-07-05 ==\n* Crash fixes involving time travel\n* Speed up interbranch time travel somewhat\n* Switch to ruff formatter\n\n== 0.15.1 | 2024-06-24 ==\n* Fix another concurrency issue\n\n== 0.15.0 | 2024-06-18 ==\n* Automatically unload history, thus minimizing memory usage for long games\n    By default, this happens whenever you commit changes to the database.\n* Improved support for ELiDE widgets in games\n    * New example sim, awareness.py, to demonstrate this\n* Moved `game_start` into its own module\n* Dropped support for Python 3.7 and the lz4 module\n* A lot of fixes regarding thread safety and interprocess sync\n\n== 0.14.2 | 2023-04-27 ==\n* Fix the rest of the loader\n\n== 0.14.1 | 2023-04-26 ==\n* Fix a loading error when you make two keyframes and then start the engine before the first\n\n== 0.14.0 | 2023-04-07 ==\n* Seek bar for time travel in ELiDE, and some other minor UI improvements\n* Vastly improved performance in ELiDE for large worlds\n* History queries no longer require the whole of history to be loaded, and are faster\n\t* SQLAlchemy is now a hard dependency\n\t* numpy is required again\n* Save the state of the randomizer every time you use it, not just on time travel\n* Rule stepper now works when you reopen the sim\n* New example sim, wolfsheep.py\n* `enforce_end_of_time` option, so it's not so trivial to make voids of time by accident\n* Lots of crash fixes\n* yapf formatting, with tabs\n* Improved documentation\n\n==0.13.2 | 2022-07-31 ==\n* Fix an intermittent error where entity deletion sometimes wouldn't go through all the way\n* Performance improvements\n* LiSE now saves keyframes on close by default. Change ``keyframe_on_close`` to ``False`` to disable this\n* Renamed \"modulus\" options to end with \"interval\" instead\n* Disable the cache arranger by default\n\n== 0.13.0 | 2022-07-23 ==\n* ELiDE now has the Timestream view, easing time travel when history gets complicated\n* Rename \"avatar\" to \"unit\"\n* Nodes now support the `.user.only` property, just like characters' `.unit.only`\n* Improve interprocess communication some more, particularly when time travelling between branches\n* Tab indentation, with yapf formatting\n* Rename some Engine methods to use snake_case\n* numpy is no longer required for the LiSE core (will speed up IPC, though)\n* Fix a loading error with changes in branches other than trunk\n* Crash fixes\n* Drop support for Python 3.6\n\n== 0.12.1 | 2021-07-04 ==\n* Optimize interprocess synchronization\n* Fix some inconsistencies in the rulebook sync\n* Crush all of a character's initial state into the one keyframe, fixing integrity problems\n* License change; no longer accept later versions of the AGPL\n* Support networkx 2.5\n* ELiDE changes\n  * Rule stepper to help you view the state of the game after one rule's run, just before the next\n  * Don't crash when resuming the game on non-trunk branches\n  * Fix stats configurator\n  * Fix rules configurators\n  * Accept a prefix on the command line\n  * Grid view shows characters other than the one you started with\n  * Dialog options from the game itself don't appear more than requested\n  * Fix crash when laying out one-dimensional boards\n\n== 0.11.2 | 2021-04-19 ==\n* Fix the branch input in ELiDE\n* Performance improvements\n\n== 0.11.1 | 2021-03-17 ==\n* Fix a flaw in the keyframes implementation that caused them to overwrite each other when several were made in a single session\n\n== 0.11 | 2021-02-03 ==\n* Add support for \"keyframes,\" snapshots of the world state at some specific time. These are currently most useful for supplying the world's initial state by instantiating a Character with a networkx graph, eg. `engine.new_character('new', nx.grid_2d_graph(3, 3))`\n    * Drastically improved load times for large initial world states\n* Removed the would-be world generation API; for now, use [the networkx graph generators](https://networkx.org/documentation/stable/reference/generators.html), and `LiSE.character.grid_2d_8graph`if you want a square grid that's connected at the corners as well as the sides.\n* Removed the \"sense\" feature. It will need a reimagining at some point. In the meantime you can still use `Character.facade()` to get a transient, mutable view onto a `Character` that won't be saved\n* `allegedb` is a submodule of `LiSE` now, and will not be published on its own.\n    * Dropped support for graph types other than `DiGraph`\n* Dropped support for Python versions prior to 3.6\n* Compatibility with msgpack 1.0.0\n* ELiDE changes\n    * Grid view\n    * File browser\n    * Grid generator when starting new simulation\n    * Symmetrical portals\n    * New agenda widget, for scheduling things in the future\n      The stat list on the left of the default ELiDE view is technically a calendar now, where an agenda is a related widget class that offers more flexibility to interface designers.\n    * Require Kivy 2.0\n\n== 0.10.1 | 2020-01-08 ==\n* Compatibility with networkx 2.4\n* Smaller database\n* Performance improvements\n* Default database filename is now 'world.db', and you can instantiate Engine with no arguments\n\n\n== 0.10 | 2019-03-16 ==\n* Improved documentation.\n* Improved performance.\n* Prevented the user from trying to start the rules engine while it's already running.\n* Minor API changes. clear_world and clear_code are now one option, clear\n* Any trigger that's going to run in a given turn is now guaranteed to run prior to any prereq or action. This is mostly to prepare for experiments in parallelism.\n* If you branch the timeline while stuff is planned for the future, the plan will be copied to the new branch, unless the plan has not yet started.\n* Made facades act more like regular characters. They still aren't very useful... I'm planning to add some new API to them that lets you munge and filter their data lazily\n\n\n== 0.9 | 2018-10-29 ==\nThis release is for ProcJam 2018.\n\n* Changed license to AGPL3+, but also waive rights in case of my death.\n* Switched to semantic versioning.\n* Made the frontend experience faster by implementing deltas. Use Engine.get_delta(...) to rapidly generate a dictionary describing changes between two points in time in a single branch.\n* Switched serialization format from an abuse of JSON to msgpack.\n* Improved the API of the ELiDE widgets, making it easier to use them in your own game. See https://github.com/LogicalDash/DungeonUniversity for an example.\n* You can zoom the map with the mousewheel now.\n* Reduced memory usage for large worlds. They still take a long time to load; I'll work on that.\n* Wrote a real tutorial for building LiSE games in Python outside of ELiDE.\n* Made the order of execution for rulebooks easier to understand. Basically, rulebooks are followed in alphabetical order; rules within them go in whatever order they were added.\n* Rearranged the UI a little.\n* You can edit every rulebook in ELiDE now, including the ones that apply to all a character's avatars and so forth.\n* Rules will only be followed for entities that still exist when they're run.\n* The turn will always increment *before* running any rules, and no rules will be run on turn 0.\n* Various little performance improvements and fixes to things like data integrity.\n\n\n== Alpha 8 | 2017-10-06 ==\nThis release is for ProcJam 2017.\n\n* Made the time model more granular. What was formerly called a tick is now a turn, which contains as many ticks as you need.\n* Support a rudimentary form of dialog menu for player interaction.\n* Rules and rulebooks are now journaled, and may change throughout the game.\n* Python source code is no longer stored in SQLite--just plain text files.\n* Changed the rule API so that rule functions are only ever called with a single argument, the entity that they apply to.\n* ELiDE is now a pure Python module.\n* Performance improvements.\n\n\n=== Alpha 7 | 2017-05-06 ===\n* Restructure everything in LiSE around a new caching strategy.\n* Generally cleaner UI.\n* If all your places are named with pairs of integers, you get automatic grid layout in ELiDE.\n\n\n=== Alpha 6 | 2016-02-01 ===\n* Opening a functions editor no longer crashes the app.\n* All the function editors are now in tabs of one screen.\n* Nicer auto layout of spots.\n* Various smaller fixes.\n\n\n=== Alpha 5 | 2016-01-03 ===\n* A whole new approach to interprocess communication resulting in much more acceptable performance within ELiDE.\n* LiSE caches the whole world state.\n* ELiDE has a new caching scheme as well. This is invisible to the user but rules out some aliasing bugs.\n* Fixed some rules not being polled.\n* A new example, college.py, and some fixes to kobold.py where it hadn't kept up with API changes.\n* The first sprouts of a world generation API, currently undocumented since I myself don't know how to work with it. Observe its methods within the class AbstractCharacter in the LiSE.character module. Chain the methods together and play around with the order to the best effect.\n* Lots of refactoring.\n* Some new graphics from Marsh Davies for Procjam 2015. And it's easier to include your own now, with an atlas and a change in elide.ini (though undocumented).\n* Real version numbers in the Python packages.\n\n\n=== Alpha 4 | 2015-08-26 ===\n* The rules editor is now usable under normal conditions. After you've made Actions and Triggers, check this out by selecting something and pressing the Rules button.\n* The big > button will cause time to pass for so long as it is toggled, as it was always meant to.\n* Improvements to input handling and collision detection.\n* Less cryptic README.\n* Crash fixes.\n\n\n=== Alpha 3 | 2015-08-11 ===\n* Performance improvements.\n* Architectural changes in ELiDE.\n* Many crash bugs fixed.\n* Pop-over windows changed into Screens, making them tidier and enabling transition animations that aren't much to look at presently.\n* Thing and Place graphics can now be added in the elide.ini configuration file.\n\n\n=== Alpha 2 | 2015-03-29 ===\n* The core LiSE simulation process and the ELiDE graphical frontend are now running in separate processes.\n* Fixed some UI interactions.\n\n\n=== Alpha 1 | 2015-03-06 ===\n* Initial release.\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CHANGES.txt b/CHANGES.txt
--- a/CHANGES.txt	(revision 88a2449a682cf4ee82f65c7754adf3cbed014cf5)
+++ b/CHANGES.txt	(date 1756295946005)
@@ -1,3 +1,8 @@
+== 0.21.5 | 2025-08-28 ==
+* Fix starting new games in Elide again
+* Fix a type of crash that happened when starting the game with some types of
+  world state already in place, related to the initial keyframe snap
+
 == 0.21.4 | 2025-08-27 ==
 * Fix an issue causing some valid exported games not to import right in Elide,
   causing an empty map and a freeze
Index: lisien/lisien/engine.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of Lisien, a framework for life simulation games.\n# Copyright (c) Zachary Spector, public@zacharyspector.com\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, version 3.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"The \"engine\" of lisien is an object relational mapper with special\nstores for game data and entities, as well as properties for manipulating the\nflow of time.\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport gc\nimport os\nimport pickle\nimport shutil\nimport signal\nimport sys\nimport zlib\nfrom abc import ABC, abstractmethod\nfrom collections import UserDict, defaultdict\nfrom concurrent.futures import Executor, Future, ThreadPoolExecutor\nfrom concurrent.futures import wait as futwait\nfrom contextlib import ContextDecorator, contextmanager\nfrom functools import cached_property, partial, wraps\nfrom itertools import chain, pairwise\nfrom logging import DEBUG, Formatter, Logger, LogRecord, StreamHandler\nfrom operator import itemgetter, lt\nfrom os import PathLike\nfrom queue import Empty, SimpleQueue\nfrom random import Random\nfrom threading import Lock, RLock, Thread\nfrom time import sleep\nfrom types import FunctionType, MethodType, ModuleType\nfrom typing import Any, Callable, Iterable, Iterator, Literal, Optional, Type\n\nimport networkx as nx\nimport numpy as np\nfrom blinker import Signal\nfrom networkx import (\n\tGraph,\n\tNetworkXError,\n\tfrom_dict_of_dicts,\n\tfrom_dict_of_lists,\n\tspring_layout,\n)\n\nfrom . import exc\nfrom .cache import (\n\tBignessCache,\n\tCharacterPlaceRulesHandledCache,\n\tCharacterPortalRulesHandledCache,\n\tCharacterRulesHandledCache,\n\tCharactersRulebooksCache,\n\tCharacterThingRulesHandledCache,\n\tEdgesCache,\n\tEdgeValCache,\n\tEntitylessCache,\n\tFuncListCache,\n\tGraphCache,\n\tGraphValCache,\n\tNeighborhoodsCache,\n\tNodeContentsCache,\n\tNodeRulesHandledCache,\n\tNodesCache,\n\tNodesRulebooksCache,\n\tNodeValCache,\n\tPickyDefaultDict,\n\tPortalRulesHandledCache,\n\tPortalsRulebooksCache,\n\tRulebooksCache,\n\tStructuredDefaultDict,\n\tThingsCache,\n\tTurnEndDict,\n\tTurnEndPlanDict,\n\tUnitnessCache,\n\tUnitRulesHandledCache,\n)\nfrom .character import Character\nfrom .db import NullQueryEngine, ParquetQueryEngine, SQLAlchemyQueryEngine\nfrom .exc import (\n\tGraphNameError,\n\tHistoricKeyError,\n\tKeyframeError,\n\tOutOfTimelineError,\n)\nfrom .facade import CharacterFacade\nfrom .graph import DiGraph\nfrom .node import Place, Thing\nfrom .portal import Portal\nfrom .proxy import worker_subprocess\nfrom .query import (\n\tCharacterStatAccessor,\n\tCombinedQueryResult,\n\tComparisonQuery,\n\tCompoundQuery,\n\tEntityStatAccessor,\n\tQuery,\n\tQueryResult,\n\tQueryResultEndTurn,\n\tQueryResultMidTurn,\n\t_make_side_sel,\n)\nfrom .rule import AllRuleBooks, AllRules, Rule\nfrom .types import (\n\tBranch,\n\tCharacterRulebookTypeStr,\n\tCharDelta,\n\tCharName,\n\tDeltaDict,\n\tEdgesDict,\n\tEdgeValDict,\n\tGraphEdgesKeyframe,\n\tGraphEdgeValKeyframe,\n\tGraphNodesKeyframe,\n\tGraphNodeValKeyframe,\n\tGraphValKeyframe,\n\tKey,\n\tKeyframe,\n\tKeyframeTuple,\n\tLinearTime,\n\tNodeName,\n\tNodesDict,\n\tNodeValDict,\n\tPlan,\n\tRuleBig,\n\tRulebookName,\n\tRuleFuncName,\n\tRuleName,\n\tRuleNeighborhood,\n\tSlightlyPackedDeltaType,\n\tStat,\n\tStatDict,\n\tTick,\n\tTime,\n\tTurn,\n\tUniversalKey,\n\tValue,\n)\nfrom .util import (\n\tACTIONS,\n\tBIG,\n\tEDGE_VAL,\n\tEDGES,\n\tELLIPSIS,\n\tETERNAL,\n\tFALSE,\n\tNEIGHBORHOOD,\n\tNODE_VAL,\n\tNODES,\n\tPREREQS,\n\tRULEBOOK,\n\tRULEBOOKS,\n\tRULES,\n\tTRIGGERS,\n\tTRUE,\n\tUNITS,\n\tUNIVERSAL,\n\tAbstractBookmarkMapping,\n\tAbstractCharacter,\n\tAbstractEngine,\n\tSizedDict,\n\tTimeSignalDescriptor,\n\tfake_submit,\n\tgarbage,\n\tnormalize_layout,\n\tsort_set,\n\ttimer,\n\tworld_locked,\n)\nfrom .window import WindowDict, update_backward_window, update_window\nfrom .xcollections import (\n\tChangeTrackingDict,\n\tCharacterMapping,\n\tFunctionStore,\n\tStringStore,\n\tUniversalMapping,\n)\n\nSUBPROCESS_TIMEOUT = 30\nif \"LISIEN_SUBPROCESS_TIMEOUT\" in os.environ:\n\ttry:\n\t\tSUBPROCESS_TIMEOUT = int(os.environ[\"LISIEN_SUBPROCESS_TIMEOUT\"])\n\texcept ValueError:\n\t\tSUBPROCESS_TIMEOUT = None\nKILL_SUBPROCESS = False\nif \"LISIEN_KILL_SUBPROCESS\" in os.environ:\n\tKILL_SUBPROCESS = bool(os.environ[\"LISIEN_KILL_SUBPROCESS\"])\n\n\nclass InnerStopIteration(StopIteration):\n\tpass\n\n\nclass PlanningContext(ContextDecorator):\n\t\"\"\"A context manager for 'hypothetical' edits.\n\n\tStart a block of code like::\n\n\t\twith orm.plan():\n\t\t\t...\n\n\n\tand any changes you make to the world state within that block will be\n\t'plans,' meaning that they are used as defaults. The world will\n\tobey your plan unless you make changes to the same entities outside\n\tthe plan, in which case the world will obey those, and cancel any\n\tfuture plan.\n\n\tPlans are *not* canceled when concerned entities are deleted, although\n\tthey are unlikely to be followed.\n\n\tNew branches cannot be started within plans. The ``with orm.forward():``\n\toptimization is disabled within a ``with orm.plan():`` block, so\n\tconsider another approach instead of making a very large plan.\n\n\tWith ``reset=True`` (the default), when the plan block closes,\n\tthe time will reset to when it began.\n\n\t\"\"\"\n\n\t__slots__ = [\"orm\", \"id\", \"forward\", \"reset\"]\n\n\tdef __init__(self, orm: \"Engine\", reset=True):\n\t\tself.orm = orm\n\t\tif reset:\n\t\t\tself.reset = orm._btt()\n\t\telse:\n\t\t\tself.reset = None\n\n\tdef __enter__(self):\n\t\torm = self.orm\n\t\tif orm._planning:\n\t\t\traise ValueError(\"Already planning\")\n\t\torm._planning = True\n\t\tbranch, turn, tick = orm._btt()\n\t\tself.id = myid = orm._last_plan = orm._last_plan + 1\n\t\tself.forward = orm._forward\n\t\tif orm._forward:\n\t\t\torm._forward = False\n\t\torm._plans[myid] = branch, turn, tick\n\t\torm.query.plans_insert(myid, branch, turn, tick)\n\t\torm._branches_plans[branch].add(myid)\n\t\treturn myid\n\n\tdef __exit__(self, exc_type, exc_val, exc_tb):\n\t\tself.orm._planning = False\n\t\tif self.reset is not None:\n\t\t\tself.orm._set_btt(*self.reset)\n\t\tif self.forward:\n\t\t\tself.orm._forward = True\n\n\nclass NextTurn(Signal):\n\t\"\"\"Make time move forward in the simulation.\n\n\tCalls ``advance`` repeatedly, returning a list of the rules' return values.\n\n\tI am also a ``Signal``, so you can register functions to be\n\tcalled when the simulation runs. Pass them to my ``connect``\n\tmethod.\n\n\t\"\"\"\n\n\tdef __init__(self, engine: Engine):\n\t\tsuper().__init__()\n\t\tself.engine = engine\n\n\tdef __call__(self) -> tuple[list, DeltaDict]:\n\t\tengine = self.engine\n\t\tfor store in engine.stores:\n\t\t\tif getattr(store, \"_need_save\", None):\n\t\t\t\tstore.save()\n\t\tif hasattr(engine, \"_worker_processes\"):\n\t\t\tengine._update_all_worker_process_states()\n\t\tstart_branch, start_turn, start_tick = engine._btt()\n\t\tlatest_turn = engine._get_last_completed_turn(start_branch)\n\t\tif latest_turn is None or start_turn == latest_turn:\n\t\t\t# Pre-emptively nudge the loadedness and branch tracking,\n\t\t\t# so that lisien does not try to load an empty turn before every\n\t\t\t# loop of the rules engine\n\t\t\tengine._extend_branch(start_branch, Turn(start_turn + 1), Tick(0))\n\t\t\tengine.turn += 1\n\t\t\tengine.tick = engine.turn_end_plan()\n\t\telif start_turn < latest_turn:\n\t\t\tengine.turn += 1\n\t\t\tengine.tick = engine.turn_end_plan()\n\t\t\tself.send(\n\t\t\t\tengine,\n\t\t\t\tbranch=engine.branch,\n\t\t\t\tturn=engine.turn,\n\t\t\t\ttick=engine.tick,\n\t\t\t)\n\t\t\treturn [], engine._get_branch_delta(\n\t\t\t\tbranch=start_branch,\n\t\t\t\tturn_from=start_turn,\n\t\t\t\tturn_to=engine.turn,\n\t\t\t\ttick_from=start_tick,\n\t\t\t\ttick_to=engine.tick,\n\t\t\t)\n\t\telif start_turn > latest_turn + 1:\n\t\t\traise exc.RulesEngineError(\n\t\t\t\t\"Can't run the rules engine on any turn but the latest\"\n\t\t\t)\n\t\tresults = []\n\t\tif hasattr(engine, \"_rules_iter\"):\n\t\t\tit = engine._rules_iter\n\t\telse:\n\t\t\ttodo = engine._eval_triggers()\n\t\t\tit = engine._rules_iter = engine._follow_rules(todo)\n\t\twith (\n\t\t\ttimer(\"seconds to run the rules engine\", engine.debug),\n\t\t\tengine.advancing(),\n\t\t):\n\t\t\tfor res in it:\n\t\t\t\tif isinstance(res, InnerStopIteration):\n\t\t\t\t\tdel engine._rules_iter\n\t\t\t\t\traise StopIteration from res\n\t\t\t\telif res:\n\t\t\t\t\tif isinstance(res, tuple) and res[0] == \"stop\":\n\t\t\t\t\t\tengine.universal[\"last_result\"] = res\n\t\t\t\t\t\tengine.universal[\"last_result_idx\"] = 0\n\t\t\t\t\t\tbranch, turn, tick = engine._btt()\n\t\t\t\t\t\tself.send(engine, branch=branch, turn=turn, tick=tick)\n\t\t\t\t\t\treturn list(res), engine._get_branch_delta(\n\t\t\t\t\t\t\tbranch=start_branch,\n\t\t\t\t\t\t\tturn_from=start_turn,\n\t\t\t\t\t\t\tturn_to=turn,\n\t\t\t\t\t\t\ttick_from=start_tick,\n\t\t\t\t\t\t\ttick_to=tick,\n\t\t\t\t\t\t)\n\t\t\t\t\telse:\n\t\t\t\t\t\tresults.extend(res)\n\t\tdel engine._rules_iter\n\t\tif results:\n\t\t\tengine.universal[\"last_result\"] = results\n\t\t\tengine.universal[\"last_result_idx\"] = 0\n\t\t# accept any new plans\n\t\tengine.tick = engine.turn_end_plan()\n\t\tengine._complete_turn(\n\t\t\tstart_branch,\n\t\t\tengine.turn,\n\t\t)\n\t\tif (\n\t\t\tengine.flush_interval is not None\n\t\t\tand engine.turn % engine.flush_interval == 0\n\t\t):\n\t\t\tengine.flush()\n\t\tif (\n\t\t\tengine.commit_interval is not None\n\t\t\tand engine.turn % engine.commit_interval == 0\n\t\t):\n\t\t\tengine.commit()\n\t\tself.send(\n\t\t\tself.engine,\n\t\t\tbranch=engine.branch,\n\t\t\tturn=engine.turn,\n\t\t\ttick=engine.tick,\n\t\t)\n\t\tdelta = engine._get_branch_delta(\n\t\t\tbranch=engine.branch,\n\t\t\tturn_from=start_turn,\n\t\t\tturn_to=engine.turn,\n\t\t\ttick_from=start_tick,\n\t\t\ttick_to=engine.tick,\n\t\t)\n\t\treturn results, delta\n\n\nclass AbstractSchema(ABC):\n\t\"\"\"Base class for schemas describing what changes are permitted to the game world\"\"\"\n\n\tdef __init__(self, engine: AbstractEngine):\n\t\tself.engine = engine\n\n\t@abstractmethod\n\tdef entity_permitted(self, entity):\n\t\traise NotImplementedError\n\n\t@abstractmethod\n\tdef stat_permitted(self, turn, entity, key, value):\n\t\traise NotImplementedError\n\n\nclass NullSchema(AbstractSchema):\n\t\"\"\"Schema that permits all changes to the game world\"\"\"\n\n\tdef entity_permitted(self, entity):\n\t\treturn True\n\n\tdef stat_permitted(self, turn, entity, key, value):\n\t\treturn True\n\n\nclass WorkerFormatter(Formatter):\n\tdef formatMessage(self, record: LogRecord) -> str:\n\t\tif not hasattr(record, \"worker_idx\"):\n\t\t\traise RuntimeError(\n\t\t\t\t\"WorkerFormatter received a LogRecord from a non-worker\",\n\t\t\t\trecord,\n\t\t\t)\n\t\treturn f\"worker {getattr(record, 'worker_idx', '???')}: {super().formatMessage(record)}\"\n\n\nclass BookmarkMapping(AbstractBookmarkMapping, UserDict):\n\t\"\"\"Points in time you might want to return to.\n\n\tCall this with a valid key, like a string, to place a bookmark at the\n\tcurrent time, or, if there is already a bookmark by the given name,\n\tthen return to it.\n\n\tThe times stored here are triples of (branch, turn, tick). If you wish,\n\tyou can set the engine's `time` property to one of those triples yourself,\n\tand time travel all the same.\n\n\t\"\"\"\n\n\tdef __init__(self, eng: Engine):\n\t\tself.eng = eng\n\t\tsuper().__init__(eng.query.bookmark_items())\n\n\tdef __setitem__(self, key, value):\n\t\tif not (\n\t\t\tisinstance(value, tuple)\n\t\t\tand len(value) == 3\n\t\t\tand isinstance(value[0], str)\n\t\t\tand isinstance(value[1], int)\n\t\t\tand isinstance(value[2], int)\n\t\t):\n\t\t\traise TypeError(\"Not a valid time\", value)\n\t\tsuper().__setitem__(key, value)\n\t\tself.eng.query.set_bookmark(key, value)\n\n\tdef __delitem__(self, key):\n\t\tsuper().__delitem__(key)\n\t\tself.eng.query.del_bookmark(key)\n\n\tdef __call__(self, key: Key):\n\t\tif key in self:\n\t\t\tself.eng.time = self[key]\n\t\telse:\n\t\t\tself[key] = tuple(self.eng.time)\n\n\nclass Engine(AbstractEngine, Executor):\n\t\"\"\"Lisien, the Life Simulator Engine.\n\n\t:param prefix: directory containing the simulation and its code;\n\t\tdefaults to the working directory. If ``None``, Lisien won't save\n\t\tany rules code to disk, and won't save world data unless you supply\n\t\t:param connect_string:.\n\t:param string: module storing strings to be used in the game; if absent,\n\t\twe'll use a :class:`lisien.xcollections.StringStore` to keep them in a\n\t\tJSON file in the ``prefix``.\n\t:param function: module containing utility functions; if absent, we'll\n\t\tuse a :class:`lisien.xcollections.FunctionStore` to keep them in a .py\n\t\tfile in the ``prefix``\n\t:param method: module containing functions taking this engine as\n\t\tfirst arg; if absent, we'll\n\t\tuse a :class:`lisien.xcollections.FunctionStore` to keep them in a .py\n\t\tfile in the ``prefix``.\n\t:param trigger: module containing trigger functions, taking a lisien\n\t\tentity and returning a boolean for whether to run a rule; if absent, we'll\n\t\tuse a :class:`lisien.xcollections.FunctionStore` to keep them in a .py\n\t\tfile in the ``prefix``.\n\t:param prereq: module containing prereq functions, taking a lisien entity and\n\t\treturning a boolean for whether to permit a rule to run; if absent, we'll\n\t\tuse a :class:`lisien.xcollections.FunctionStore` to keep them in a .py\n\t\tfile in the ``prefix``.\n\t:param action: module containing action functions, taking a lisien entity and\n\t\tmutating it (and possibly the rest of the world); if absent, we'll\n\t\tuse a :class:`lisien.xcollections.FunctionStore` to keep them in a .py\n\t\tfile in the ``prefix``.\n\t:param main_branch: the string name of the branch to start from. Defaults\n\t\tto \"trunk\" if not set in some prior session. You should only change\n\t\tthis if your game generates new initial conditions for each\n\t\tplaythrough.\n\t:param connect_string: a rfc1738 URI for a database to connect to. Leave\n\t\t``None`` to use the ParquetDB database in the ``prefix``.\n\t:param connect_args: Dictionary of keyword arguments for the\n\t\tdatabase connection\n\t:param schema: A Schema class that determines which changes to allow to\n\t\tthe world; used when a player should not be able to change just\n\t\tanything. Defaults to :class:`NullSchema`, which allows all changes.\n\t:param flush_interval: lisien will put pending changes into the database\n\t\ttransaction every ``flush_interval`` turns. If ``None``, only flush\n\t\ton commit. Default ``None``.\n\t:param keyframe_interval: How many records to let through before automatically\n\t\tsnapping a keyframe, default ``1000``. If ``None``, you'll need\n\t\tto call ``snap_keyframe`` yourself.\n\t:param commit_interval: Lisien will commit changes to disk every\n\t\t``commit_interval`` turns. If ``None`` (the default), only commit\n\t\ton close or manual call to ``commit``.\n\t:param random_seed: A number to initialize the randomizer.\n\t:param clear: Whether to delete *any and all* existing data\n\t\tand code in ``prefix`` and the database. Use with caution!\n\t:param keep_rules_journal: Boolean; if ``True`` (the default), keep\n\t\tinformation on the behavior of the rules engine in the database.\n\t\tMakes the database rather large, but useful for debugging.\n\t:param keyframe_on_close: Whether to snap a keyframe when closing the\n\t\tengine, default ``True``. This is usually what you want, as it will\n\t\tmake future startups faster, but could cause database bloat if\n\t\tyour game runs few turns per session.\n\t:param enforce_end_of_time: Whether to raise an exception when\n\t\ttime travelling to a point after the time that's been simulated.\n\t\tDefault ``True``. You normally want this, but it could cause problems\n\t\tif you're not using the rules engine.\n\t:param workers: How many subprocesses to use as workers for\n\t\tparallel processing. When ``None`` (the default), use as many\n\t\tsubprocesses as we have CPU cores. When ``0``, parallel processing\n\t\tis disabled. Note that ``workers=0`` implies that trigger\n\t\tfunctions operate on bare lisien objects, and can therefore have\n\t\tside effects. If you don't want this, instead use\n\t\t``workers=1``, which *does* disable parallelism in the case\n\t\tof trigger functions.\n\t\"\"\"\n\n\tchar_cls = Character\n\tthing_cls = Thing\n\tplace_cls = node_cls = Place\n\tportal_cls = edge_cls = Portal\n\tentity_cls = char_cls | thing_cls | place_cls | portal_cls\n\tillegal_graph_names = {\n\t\t\"global\",\n\t\t\"eternal\",\n\t\t\"universal\",\n\t\t\"rulebooks\",\n\t\t\"rules\",\n\t}\n\tillegal_node_names = {\"nodes\", \"node_val\", \"edges\", \"edge_val\", \"things\"}\n\ttime = TimeSignalDescriptor()\n\ttrigger: FunctionStore\n\tprereq: FunctionStore\n\taction: FunctionStore\n\tfunction: FunctionStore\n\tmethod: FunctionStore\n\n\t@property\n\tdef eternal(self):\n\t\treturn self.query.globl\n\n\t@property\n\tdef branch(self) -> Branch:\n\t\treturn self._obranch\n\n\t@branch.setter\n\t@world_locked\n\tdef branch(self, v: str):\n\t\tif not isinstance(v, str):\n\t\t\traise TypeError(\"branch must be str\")\n\t\tif self._planning:\n\t\t\traise ValueError(\"Don't change branches while planning\")\n\t\tcurbranch, curturn, curtick = self._btt()\n\t\tif curbranch == v:\n\t\t\treturn\n\t\t# make sure I'll end up within the revision range of the\n\t\t# destination branch\n\t\tv = Branch(v)\n\t\tif v != self.main_branch and v in self.branches():\n\t\t\tparturn = self._branch_start(v)[0]\n\t\t\tif curturn < parturn:\n\t\t\t\traise OutOfTimelineError(\n\t\t\t\t\t\"Tried to jump to branch {br} at turn {tr}, \"\n\t\t\t\t\t\"but {br} starts at turn {rv}. \"\n\t\t\t\t\t\"Go to turn {rv} or later to use this branch.\".format(\n\t\t\t\t\t\tbr=v, tr=self.turn, rv=parturn\n\t\t\t\t\t),\n\t\t\t\t\tself.branch,\n\t\t\t\t\tself.turn,\n\t\t\t\t\tself.tick,\n\t\t\t\t\tv,\n\t\t\t\t\tself.turn,\n\t\t\t\t\tself.tick,\n\t\t\t\t)\n\t\tthen = self._btt()\n\t\tbranch_is_new = v not in self.branches()\n\t\tif branch_is_new:\n\t\t\t# assumes the present turn in the parent branch has\n\t\t\t# been finalized.\n\t\t\tself._start_branch(curbranch, v, self.turn, self.tick)\n\t\t\ttick = self.tick\n\t\telse:\n\t\t\tself._otick = tick = self.turn_end(v, self.turn)\n\t\tparent = self._obranch\n\t\tself._obranch = v\n\t\tif branch_is_new:\n\t\t\tself._copy_plans(parent, self.turn, tick)\n\t\t\tself.snap_keyframe(silent=True)\n\t\t\treturn\n\t\tself.load_at(v, curturn, tick)\n\t\tself.time.send(self.time, then=then, now=self._btt())\n\n\t@property\n\tdef main_branch(self):\n\t\treturn self.query.globl[\"main_branch\"]\n\n\tdef switch_main_branch(self, branch: Branch) -> None:\n\t\tif self.branch != self.main_branch or self.turn != 0 or self.tick != 0:\n\t\t\traise ValueError(\"Go to the start of time first\")\n\t\tif (\n\t\t\tbranch in self.branches()\n\t\t\tand self.branch_parent(branch) is not None\n\t\t):\n\t\t\traise ValueError(\"Not a main branch\")\n\t\tthen = self._btt()\n\t\tself.query.globl[\"main_branch\"] = self.branch = branch\n\t\tself.time.send(self, then=then, now=self._btt())\n\n\t@property\n\tdef turn(self) -> Turn:\n\t\treturn Turn(self._oturn)\n\n\t@turn.setter\n\t@world_locked\n\tdef turn(self, v: int):\n\t\tif not isinstance(v, int):\n\t\t\traise TypeError(\"Turns must be integers\")\n\t\tif v < 0:\n\t\t\traise ValueError(\"Turns can't be negative\")\n\t\tif v == self.turn:\n\t\t\treturn\n\t\tturn_end, tick_end = self._branch_end()\n\t\tif self._enforce_end_of_time and not self._planning and v > turn_end:\n\t\t\traise OutOfTimelineError(\n\t\t\t\tf\"The turn {v} is after the end of the branch {self.branch}. \"\n\t\t\t\tf\"Go to turn {turn_end} and simulate with `next_turn`.\",\n\t\t\t\tself.branch,\n\t\t\t\tself.turn,\n\t\t\t\tself.tick,\n\t\t\t\tself.branch,\n\t\t\t\tv,\n\t\t\t\tself.tick,\n\t\t\t)\n\t\t# enforce the arrow of time, if it's in effect\n\t\tif self._forward and v < self._oturn:\n\t\t\traise ValueError(\"Can't time travel backward in a forward context\")\n\t\tv = Turn(v)\n\t\toldrando = self.universal.get(\"rando_state\")\n\t\tbranch = self.branch\n\t\tif self._planning:\n\t\t\ttick = self._turn_end_plan[branch, v]\n\t\telse:\n\t\t\ttick = self._turn_end[branch, v]\n\t\tself.load_at(branch, v, tick)\n\t\tself._extend_branch(branch, v, tick)\n\t\tthen = self._btt()\n\t\tself._otick = tick\n\t\tself._oturn = v\n\t\tnewrando = self.universal.get(\"rando_state\")\n\t\tif newrando and newrando != oldrando:\n\t\t\tself._rando.setstate(newrando)\n\t\tself.time.send(self, then=then, now=self._btt())\n\n\t@property\n\tdef tick(self) -> Tick:\n\t\t\"\"\"A counter of how many changes have occurred this turn.\n\n\t\tCan be set manually, but is more often set to the last tick in a turn\n\t\tas a side effect of setting ``turn``.\n\n\t\t\"\"\"\n\t\treturn Tick(self._otick)\n\n\t@tick.setter\n\t@world_locked\n\tdef tick(self, v: int):\n\t\tif not isinstance(v, int):\n\t\t\traise TypeError(\"Ticks must be integers\")\n\t\tif v < 0:\n\t\t\traise ValueError(\"Ticks can't be negative\")\n\t\t# enforce the arrow of time, if it's in effect\n\t\tif self._forward and v < self._otick:\n\t\t\traise ValueError(\"Can't time travel backward in a forward context\")\n\t\tif v == self.tick:\n\t\t\treturn\n\t\tif self.turn == self.branch_end_turn():\n\t\t\ttick_end = self._turn_end_plan[self.branch, self.turn]\n\t\t\tif v > tick_end + 1:\n\t\t\t\traise OutOfTimelineError(\n\t\t\t\t\tf\"The tick {v} is after the end of the turn {self.turn}. \"\n\t\t\t\t\tf\"Go to tick {tick_end + 1} and simulate with `next_turn`.\",\n\t\t\t\t\tself.branch,\n\t\t\t\t\tself.turn,\n\t\t\t\t\tself.tick,\n\t\t\t\t\tself.branch,\n\t\t\t\t\tself.turn,\n\t\t\t\t\tv,\n\t\t\t\t)\n\t\toldrando = self.universal.get(\"rando_state\")\n\t\tv = Tick(v)\n\t\tself.load_at(self.branch, self.turn, v)\n\t\tself._extend_branch(self.branch, self.turn, v)\n\t\told_tick = self._otick\n\t\tself._otick = v\n\t\tnewrando = self.universal.get(\"rando_state\")\n\t\tif newrando and newrando != oldrando:\n\t\t\tself._rando.setstate(newrando)\n\t\tself.time.send(\n\t\t\tself,\n\t\t\tthen=(self.branch, self.turn, old_tick),\n\t\t\tnow=(self.branch, self.turn, v),\n\t\t)\n\n\t@cached_property\n\tdef bookmark(self) -> BookmarkMapping:\n\t\treturn BookmarkMapping(self)\n\n\t@cached_property\n\tdef _where_cached(self) -> dict[Time, list]:\n\t\treturn defaultdict(list)\n\n\t@cached_property\n\tdef _node_objs(self) -> SizedDict:\n\t\treturn SizedDict()\n\n\t@cached_property\n\tdef _edge_objs(self) -> SizedDict:\n\t\treturn SizedDict()\n\n\t@cached_property\n\tdef _nbtt_stuff(self):\n\t\treturn (\n\t\t\tself._btt,\n\t\t\tself._turn_end_plan,\n\t\t\tself._turn_end,\n\t\t\tself._plan_ticks,\n\t\t\tself._time_plan,\n\t\t)\n\n\t@cached_property\n\tdef _node_exists_stuff(\n\t\tself,\n\t) -> tuple[\n\t\tCallable[[tuple[CharName, NodeName, Branch, Turn, Tick]], Any],\n\t\tCallable[[], Time],\n\t]:\n\t\treturn (self._nodes_cache._base_retrieve, self._btt)\n\n\t@cached_property\n\tdef _exist_node_stuff(\n\t\tself,\n\t) -> tuple[\n\t\tCallable[[], Time],\n\t\tCallable[[CharName, NodeName, Branch, Turn, Tick, bool], None],\n\t\tCallable[[CharName, NodeName, Branch, Turn, Tick, Any], None],\n\t]:\n\t\treturn (self._nbtt, self.query.exist_node, self._nodes_cache.store)\n\n\t@cached_property\n\tdef _edge_exists_stuff(\n\t\tself,\n\t) -> tuple[\n\t\tCallable[\n\t\t\t[tuple[CharName, NodeName, NodeName, Branch, Turn, Tick]],\n\t\t\tbool,\n\t\t],\n\t\tCallable[[], Time],\n\t]:\n\t\treturn (self._edges_cache._base_retrieve, self._btt)\n\n\t@cached_property\n\tdef _exist_edge_stuff(\n\t\tself,\n\t) -> tuple[\n\t\tCallable[[], Time],\n\t\tCallable[\n\t\t\t[CharName, NodeName, NodeName, Branch, Turn, Tick, bool], None\n\t\t],\n\t\tCallable[\n\t\t\t[CharName, NodeName, NodeName, Branch, Turn, Tick, Any], None\n\t\t],\n\t]:\n\t\treturn (self._nbtt, self.query.exist_edge, self._edges_cache.store)\n\n\t@cached_property\n\tdef _loaded(\n\t\tself,\n\t) -> dict[Branch, tuple[Turn, Tick, Optional[Turn], Optional[Tick]]]:\n\t\t\"\"\"Slices of time that are currently in memory\n\n\t\t{branch: (turn_from, tick_from, turn_to, tick_to)}\n\n\t\t\"\"\"\n\t\treturn {}\n\n\t@cached_property\n\tdef _get_node_stuff(\n\t\tself,\n\t) -> tuple[\n\t\tSizedDict,\n\t\tCallable[[tuple], Any],\n\t\tCallable[[], tuple[Branch, Turn, Tick]],\n\t\tCallable[[Character, NodeName], Thing | Place],\n\t]:\n\t\treturn (\n\t\t\tself._node_objs,\n\t\t\tself._nodes_cache._base_retrieve,\n\t\t\tself._btt,\n\t\t\tself._make_node,\n\t\t)\n\n\t@cached_property\n\tdef _get_edge_stuff(\n\t\tself,\n\t) -> tuple[\n\t\tSizedDict,\n\t\tCallable[[CharName, NodeName, NodeName], bool],\n\t\tCallable[[Character, NodeName, NodeName], Portal],\n\t]:\n\t\treturn self._edge_objs, self._edge_exists, self._make_edge\n\n\t@cached_property\n\tdef _childbranch(self) -> dict[Branch, set[Branch]]:\n\t\t\"\"\"Immediate children of a branch\"\"\"\n\t\treturn defaultdict(set)\n\n\t@cached_property\n\tdef _branches_d(\n\t\tself,\n\t) -> ChangeTrackingDict[\n\t\tBranch, tuple[Branch | None, Turn, Tick, Turn, Tick]\n\t]:\n\t\t\"\"\"Parent, start time, and end time of each branch. Includes plans.\"\"\"\n\t\treturn ChangeTrackingDict()\n\n\t@cached_property\n\tdef _branch_parents(self) -> dict[Branch, set[Branch]]:\n\t\t\"\"\"Parents of a branch at any remove\"\"\"\n\t\treturn defaultdict(set)\n\n\t@cached_property\n\tdef _turn_end(self) -> TurnEndDict[tuple[Branch, Turn], Tick]:\n\t\treturn TurnEndDict(self)\n\n\t@cached_property\n\tdef _turn_end_plan(self) -> TurnEndPlanDict[tuple[Branch, Turn], Tick]:\n\t\treturn TurnEndPlanDict(self)\n\n\t@cached_property\n\tdef _graph_objs(self) -> dict[CharName, AbstractCharacter]:\n\t\treturn {}\n\n\t@cached_property\n\tdef _plans(self) -> dict[Plan, Time]:\n\t\treturn {}\n\n\t@cached_property\n\tdef _branches_plans(self) -> dict[Branch, set[Plan]]:\n\t\treturn defaultdict(set)\n\n\t@cached_property\n\tdef _plan_ticks(self) -> dict[Plan, dict[Turn, set[Tick]]]:\n\t\treturn defaultdict(lambda: defaultdict(set))\n\n\t@cached_property\n\tdef _time_plan(self) -> dict[Time, Plan]:\n\t\treturn {}\n\n\t@cached_property\n\tdef _graph_cache(self) -> GraphCache:\n\t\treturn GraphCache(self, name=\"graph cache\")\n\n\t@cached_property\n\tdef _graph_val_cache(self) -> GraphValCache:\n\t\tret = GraphValCache(self, name=\"graph val cache\")\n\t\tret.setdb = self.query.graph_val_set\n\t\tret.deldb = self.query.graph_val_del_time\n\t\treturn ret\n\n\t@cached_property\n\tdef _nodes_cache(self) -> NodesCache:\n\t\tret = NodesCache(self, name=\"nodes cache\")\n\t\tret.setdb = self.query.exist_node\n\t\tret.deldb = self.query.nodes_del_time\n\t\treturn ret\n\n\t@cached_property\n\tdef _edges_cache(self) -> EdgesCache:\n\t\tret = EdgesCache(self, name=\"edges cache\")\n\t\tret.setdb = self.query.exist_edge\n\t\tret.deldb = self.query.edges_del_time\n\t\treturn ret\n\n\t@cached_property\n\tdef _node_val_cache(self) -> NodeValCache:\n\t\tret = NodeValCache(self, name=\"node val cache\")\n\t\tret.setdb = self.query.node_val_set\n\t\tret.deldb = self.query.node_val_del_time\n\t\treturn ret\n\n\t@cached_property\n\tdef _edge_val_cache(self) -> EdgeValCache:\n\t\tret = EdgeValCache(self, name=\"edge val cache\")\n\t\tret.setdb = self.query.edge_val_set\n\t\tret.deldb = self.query.edge_val_del_time\n\t\treturn ret\n\n\t@cached_property\n\tdef _things_cache(self) -> ThingsCache:\n\t\tret = ThingsCache(self, name=\"things cache\")\n\t\tret.setdb = self.query.set_thing_loc\n\t\treturn ret\n\n\t@cached_property\n\tdef _node_contents_cache(self) -> NodeContentsCache:\n\t\treturn NodeContentsCache(self, name=\"node contents cache\")\n\n\t@cached_property\n\tdef _neighbors_cache(self) -> SizedDict:\n\t\treturn SizedDict()\n\n\t@cached_property\n\tdef _universal_cache(self) -> EntitylessCache:\n\t\tret = EntitylessCache(self, name=\"universal cache\")\n\t\tret.setdb = self.query.universal_set\n\t\treturn ret\n\n\t@cached_property\n\tdef _rulebooks_cache(self) -> RulebooksCache:\n\t\tret = RulebooksCache(self, name=\"rulebooks cache\")\n\t\tret.setdb = self.query.rulebook_set\n\t\treturn ret\n\n\t@cached_property\n\tdef _characters_rulebooks_cache(self) -> CharactersRulebooksCache:\n\t\treturn CharactersRulebooksCache(\n\t\t\tself, name=\"character_rulebook\"\n\t\t)\n\n\t@cached_property\n\tdef _units_rulebooks_cache(self) -> CharactersRulebooksCache:\n\t\treturn CharactersRulebooksCache(self, name=\"unit_ulebook\")\n\n\t@cached_property\n\tdef _characters_things_rulebooks_cache(self) -> CharactersRulebooksCache:\n\t\treturn CharactersRulebooksCache(\n\t\t\tself, name=\"character_thing_rulebook\"\n\t\t)\n\n\t@cached_property\n\tdef _characters_places_rulebooks_cache(self) -> CharactersRulebooksCache:\n\t\treturn CharactersRulebooksCache(\n\t\t\tself, name=\"character_place_rulebook\"\n\t\t)\n\n\t@cached_property\n\tdef _characters_portals_rulebooks_cache(self) -> CharactersRulebooksCache:\n\t\treturn CharactersRulebooksCache(\n\t\t\tself, name=\"character_portals_rulebook\"\n\t\t)\n\n\t@cached_property\n\tdef _nodes_rulebooks_cache(self) -> NodesRulebooksCache:\n\t\treturn NodesRulebooksCache(self, name=\"nodes rulebooks cache\")\n\n\t@cached_property\n\tdef _portals_rulebooks_cache(self) -> PortalsRulebooksCache:\n\t\treturn PortalsRulebooksCache(self, name=\"portals rulebooks cache\")\n\n\t@cached_property\n\tdef _triggers_cache(self) -> FuncListCache:\n\t\treturn FuncListCache(self, name=\"triggers cache\")\n\n\t@cached_property\n\tdef _prereqs_cache(self) -> FuncListCache:\n\t\treturn FuncListCache(self, name=\"prereqs cache\")\n\n\t@cached_property\n\tdef _actions_cache(self) -> FuncListCache:\n\t\treturn FuncListCache(self, name=\"actions cache\")\n\n\t@cached_property\n\tdef _neighborhoods_cache(self) -> NeighborhoodsCache:\n\t\treturn NeighborhoodsCache(self, name=\"neighborhoods cache\")\n\n\t@cached_property\n\tdef _rule_bigness_cache(self) -> BignessCache:\n\t\treturn BignessCache(self, name=\"rule bigness cache\")\n\n\t@cached_property\n\tdef _node_rules_handled_cache(self) -> NodeRulesHandledCache:\n\t\treturn NodeRulesHandledCache(self, name=\"node rules handled cache\")\n\n\t@cached_property\n\tdef _portal_rules_handled_cache(self) -> PortalRulesHandledCache:\n\t\treturn PortalRulesHandledCache(self, name=\"portal rules handled cache\")\n\n\t@cached_property\n\tdef _character_rules_handled_cache(self) -> CharacterRulesHandledCache:\n\t\treturn CharacterRulesHandledCache(\n\t\t\tself, name=\"character rules handled cache\"\n\t\t)\n\n\t@cached_property\n\tdef _unit_rules_handled_cache(self) -> UnitRulesHandledCache:\n\t\treturn UnitRulesHandledCache(self, name=\"unit rules handled cache\")\n\n\t@cached_property\n\tdef _character_thing_rules_handled_cache(\n\t\tself,\n\t) -> CharacterThingRulesHandledCache:\n\t\treturn CharacterThingRulesHandledCache(\n\t\t\tself, name=\"character thing rules handled cache\"\n\t\t)\n\n\t@cached_property\n\tdef _character_place_rules_handled_cache(\n\t\tself,\n\t) -> CharacterPlaceRulesHandledCache:\n\t\treturn CharacterPlaceRulesHandledCache(\n\t\t\tself, name=\"character place rules handled cache\"\n\t\t)\n\n\t@cached_property\n\tdef _character_portal_rules_handled_cache(\n\t\tself,\n\t) -> CharacterPortalRulesHandledCache:\n\t\treturn CharacterPortalRulesHandledCache(\n\t\t\tself, name=\"character portal rules handled cache\"\n\t\t)\n\n\t@cached_property\n\tdef _unitness_cache(self) -> UnitnessCache:\n\t\treturn UnitnessCache(self, name=\"unitness cache\")\n\n\t@cached_property\n\tdef _turns_completed_d(self) -> dict[Branch, Turn]:\n\t\treturn {}\n\n\t@cached_property\n\tdef universal(self) -> UniversalMapping:\n\t\treturn UniversalMapping(self)\n\n\t@cached_property\n\tdef rule(self) -> AllRules:\n\t\treturn AllRules(self)\n\n\t@cached_property\n\tdef rulebook(self) -> AllRuleBooks:\n\t\treturn AllRuleBooks(self)\n\n\t@cached_property\n\tdef _keyframes_dict(self) -> dict[Branch, WindowDict[Turn, set[Tick]]]:\n\t\treturn PickyDefaultDict(WindowDict)\n\n\t@cached_property\n\tdef _keyframes_times(self) -> set[Time]:\n\t\treturn set()\n\n\t@cached_property\n\tdef _keyframes_loaded(self) -> set[Time]:\n\t\treturn set()\n\n\t@cached_property\n\tdef _caches(self) -> list:\n\t\treturn [\n\t\t\tself._things_cache,\n\t\t\tself._node_contents_cache,\n\t\t\tself._universal_cache,\n\t\t\tself._rulebooks_cache,\n\t\t\tself._characters_rulebooks_cache,\n\t\t\tself._units_rulebooks_cache,\n\t\t\tself._characters_things_rulebooks_cache,\n\t\t\tself._characters_places_rulebooks_cache,\n\t\t\tself._characters_portals_rulebooks_cache,\n\t\t\tself._nodes_rulebooks_cache,\n\t\t\tself._portals_rulebooks_cache,\n\t\t\tself._triggers_cache,\n\t\t\tself._prereqs_cache,\n\t\t\tself._actions_cache,\n\t\t\tself._character_rules_handled_cache,\n\t\t\tself._unit_rules_handled_cache,\n\t\t\tself._character_thing_rules_handled_cache,\n\t\t\tself._character_place_rules_handled_cache,\n\t\t\tself._character_portal_rules_handled_cache,\n\t\t\tself._node_rules_handled_cache,\n\t\t\tself._portal_rules_handled_cache,\n\t\t\tself._unitness_cache,\n\t\t\tself._graph_val_cache,\n\t\t\tself._nodes_cache,\n\t\t\tself._edges_cache,\n\t\t\tself._node_val_cache,\n\t\t\tself._edge_val_cache,\n\t\t]\n\n\t@cached_property\n\tdef character(self) -> CharacterMapping:\n\t\treturn CharacterMapping(self)\n\n\tdef _btt(self) -> Time:\n\t\t\"\"\"Return the branch, turn, and tick.\"\"\"\n\t\treturn Branch(self._obranch), Turn(self._oturn), Tick(self._otick)\n\n\tdef _set_btt(self, branch: Branch, turn: Turn, tick: Tick):\n\t\t(self._obranch, self._oturn, self._otick) = (branch, turn, tick)\n\n\t@world_locked\n\tdef _nbtt(self) -> Time:\n\t\t\"\"\"Increment the tick and return branch, turn, tick\n\n\t\tUnless we're viewing the past, in which case raise HistoryError.\n\n\t\tIdea is you use this when you want to advance time, which you\n\t\tcan only do once per branch, turn, tick.\n\n\t\t\"\"\"\n\t\t(\n\t\t\tbtt,\n\t\t\tturn_end_plan,\n\t\t\tturn_end,\n\t\t\tplan_ticks,\n\t\t\ttime_plan,\n\t\t) = self._nbtt_stuff\n\t\tbranch, turn, tick = btt()\n\t\tbranch_turn = (branch, turn)\n\t\ttick += 1\n\t\tif branch_turn in turn_end_plan and tick <= turn_end_plan[branch_turn]:\n\t\t\ttick = turn_end_plan[branch_turn] + 1\n\t\tif branch_turn in turn_end and turn_end[branch_turn] > tick:\n\t\t\traise HistoricKeyError(\n\t\t\t\t\"You're not at the end of turn {}. \"\n\t\t\t\t\"Go to tick {} to change things\".format(\n\t\t\t\t\tturn, turn_end[branch_turn]\n\t\t\t\t)\n\t\t\t)\n\t\tif self._planning:\n\t\t\tlast_plan = self._last_plan\n\t\t\tif (turn, tick) in plan_ticks[last_plan]:\n\t\t\t\traise OutOfTimelineError(\n\t\t\t\t\t\"Trying to make a plan at {}, \"\n\t\t\t\t\t\"but that time already happened\".format(\n\t\t\t\t\t\t(branch, turn, tick)\n\t\t\t\t\t),\n\t\t\t\t\tself.branch,\n\t\t\t\t\tself.turn,\n\t\t\t\t\tself.tick,\n\t\t\t\t\tself.branch,\n\t\t\t\t\tself.turn,\n\t\t\t\t\ttick,\n\t\t\t\t)\n\t\t\tplan_ticks[last_plan][turn].add(tick)\n\t\t\tself.query.plan_ticks_insert(last_plan, turn, tick)\n\t\t\ttime_plan[branch, turn, tick] = last_plan\n\t\telse:\n\t\t\tend_turn, _ = self._branch_end(branch)\n\t\t\tif turn < end_turn:\n\t\t\t\traise OutOfTimelineError(\n\t\t\t\t\t\"You're in the past. Go to turn {} to change things\"\n\t\t\t\t\t\" -- or start a new branch\".format(end_turn),\n\t\t\t\t\t*btt(),\n\t\t\t\t\tbranch,\n\t\t\t\t\tturn,\n\t\t\t\t\ttick,\n\t\t\t\t)\n\t\t\telif turn == end_turn and (branch, turn) in turn_end_plan:\n\t\t\t\t# Accept any plans made for this turn\n\t\t\t\ttick = turn_end_plan[branch, turn] + 1\n\t\t\tif tick > turn_end[branch_turn]:\n\t\t\t\tturn_end[branch_turn] = tick\n\t\tloaded = self._loaded\n\t\tif branch in loaded:\n\t\t\t(early_turn, early_tick, late_turn, late_tick) = loaded[branch]\n\t\t\tif late_turn is not None:\n\t\t\t\tif turn > late_turn:\n\t\t\t\t\t(late_turn, late_tick) = (turn, tick)\n\t\t\t\telif turn == late_turn and tick > late_tick:\n\t\t\t\t\tlate_tick = tick\n\t\t\tloaded[branch] = (early_turn, early_tick, late_turn, late_tick)\n\t\telse:\n\t\t\tloaded[branch] = (turn, tick, turn, tick)\n\t\tself._extend_branch(branch, turn, tick)\n\t\tthen = self._btt()\n\t\tself._otick = tick\n\t\tself.time.send(self, then=then, now=self._btt())\n\t\treturn branch, turn, tick\n\n\tdef __getattr__(self, item):\n\t\ttry:\n\t\t\treturn MethodType(\n\t\t\t\tgetattr(super().__getattribute__(\"method\"), item), self\n\t\t\t)\n\t\texcept AttributeError:\n\t\t\traise AttributeError(\"No such attribute\", item)\n\n\tdef __hasattr__(self, item):\n\t\treturn hasattr(super().__getattribute__(\"method\"), item)\n\n\tdef _graph_state_hash(\n\t\tself, nodes: NodeValDict, edges: EdgeValDict, vals: StatDict\n\t) -> bytes:\n\t\tfrom hashlib import blake2b\n\n\t\tqpac = self.query.pack\n\n\t\tif isinstance(qpac(\" \"), str):\n\n\t\t\tdef pack(x):\n\t\t\t\treturn qpac(x).encode()\n\t\telse:\n\t\t\tpack = qpac\n\t\tnodes_hash = 0\n\t\tfor name, val in nodes.items():\n\t\t\thash = blake2b(pack(name))\n\t\t\thash.update(pack(val))\n\t\t\tnodes_hash ^= int.from_bytes(hash.digest(), \"little\")\n\t\tedges_hash = 0\n\t\tfor orig, dests in edges.items():\n\t\t\tfor dest, val in dests.items():\n\t\t\t\thash = blake2b(pack(orig))\n\t\t\t\thash.update(pack(dest))\n\t\t\t\thash.update(pack(val))\n\t\t\t\tedges_hash ^= int.from_bytes(hash.digest(), \"little\")\n\t\tval_hash = 0\n\t\tfor key, val in vals.items():\n\t\t\thash = blake2b(pack(key))\n\t\t\thash.update(pack(val))\n\t\t\tval_hash ^= int.from_bytes(hash.digest(), \"little\")\n\t\ttotal_hash = blake2b(nodes_hash.to_bytes(64, \"little\"))\n\t\ttotal_hash.update(edges_hash.to_bytes(64, \"little\"))\n\t\ttotal_hash.update(val_hash.to_bytes(64, \"little\"))\n\t\treturn total_hash.digest()\n\n\tdef _kfhash(\n\t\tself,\n\t\tgraphn: Key,\n\t\tbranch: Branch,\n\t\tturn: Turn,\n\t\ttick: Tick,\n\t\tnodes: NodeValDict,\n\t\tedges: EdgeValDict,\n\t\tvals: StatDict,\n\t) -> bytes:\n\t\t\"\"\"Return a hash digest of a keyframe\"\"\"\n\t\tfrom hashlib import blake2b\n\n\t\tqpac = self.query.pack\n\n\t\tif isinstance(qpac(\" \"), str):\n\n\t\t\tdef pack(x):\n\t\t\t\treturn qpac(x).encode()\n\t\telse:\n\t\t\tpack = qpac\n\t\ttotal_hash = blake2b(pack(graphn))\n\t\ttotal_hash.update(pack(branch))\n\t\ttotal_hash.update(pack(turn))\n\t\ttotal_hash.update(pack(tick))\n\t\ttotal_hash.update(self._graph_state_hash(nodes, edges, vals))\n\t\treturn total_hash.digest()\n\n\tdef _get_node(self, graph: CharName | Character, node: NodeName):\n\t\tnode_objs, retrieve, btt, make_node = self._get_node_stuff\n\t\tif hasattr(graph, \"name\"):\n\t\t\tgraphn = graph.name\n\t\telse:\n\t\t\tgraphn = graph\n\t\t\tgraph = self.character[graphn]\n\t\tkey = (graphn, node)\n\t\tif key in node_objs:\n\t\t\tret = node_objs[key]\n\t\t\tif ret._validate_node_type():\n\t\t\t\treturn ret\n\t\t\telse:\n\t\t\t\tdel node_objs[key]\n\t\tex = retrieve((graphn, node, *btt()))\n\t\tif isinstance(ex, Exception):\n\t\t\traise ex\n\t\tif not ex:\n\t\t\traise KeyError(\"No such node: {} in {}\".format(node, graphn))\n\t\tret = make_node(graph, node)\n\t\tnode_objs[key] = ret\n\t\treturn ret\n\n\tdef _get_edge(\n\t\tself, graph: Character | CharName, orig: NodeName, dest: NodeName\n\t):\n\t\tedge_objs, edge_exists, make_edge = self._get_edge_stuff\n\t\tif type(graph) is str:\n\t\t\tgraphn = graph\n\t\t\tgraph = self.character[graphn]\n\t\telse:\n\t\t\tgraphn = graph.name\n\t\tkey = (graphn, orig, dest)\n\t\tif key in edge_objs:\n\t\t\treturn edge_objs[key]\n\t\tif not edge_exists(graphn, orig, dest):\n\t\t\traise KeyError(\n\t\t\t\t\"No such edge: {}->{} in {}\".format(orig, dest, graphn)\n\t\t\t)\n\t\tret = make_edge(graph, orig, dest)\n\t\tedge_objs[key] = ret\n\t\treturn ret\n\n\tdef plan(self, reset: bool = True) -> PlanningContext:\n\t\t__doc__ = PlanningContext.__doc__\n\t\treturn PlanningContext(self, reset)\n\n\t@world_locked\n\tdef _copy_plans(\n\t\tself, branch_from: Branch, turn_from: Turn, tick_from: Tick\n\t) -> None:\n\t\t\"\"\"Copy all plans active at the given time to the current branch\"\"\"\n\t\tplan_ticks = self._plan_ticks\n\t\ttime_plan = self._time_plan\n\t\tplans = self._plans\n\t\tbranch = self.branch\n\t\twhere_cached = self._where_cached\n\t\tturn_end_plan = self._turn_end_plan\n\t\twas_planning = self._planning\n\t\tself._planning = True\n\t\tfor plan_id in self._branches_plans[branch_from]:\n\t\t\t_, start_turn, start_tick = plans[plan_id]\n\t\t\tif (\n\t\t\t\tbranch_from,\n\t\t\t\tstart_turn,\n\t\t\t) not in turn_end_plan or start_tick > turn_end_plan[\n\t\t\t\tbranch_from, start_turn\n\t\t\t]:\n\t\t\t\tturn_end_plan[branch_from, start_turn] = start_tick\n\t\t\tif (start_turn, start_tick) > (turn_from, tick_from):\n\t\t\t\tcontinue\n\t\t\tincremented = False\n\t\t\tfor turn, ticks in list(plan_ticks[plan_id].items()):\n\t\t\t\tif turn < turn_from:\n\t\t\t\t\tcontinue\n\t\t\t\tfor tick in ticks:\n\t\t\t\t\tif (turn, tick) < (turn_from, tick_from):\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tif not incremented:\n\t\t\t\t\t\tself._last_plan += 1\n\t\t\t\t\t\tincremented = True\n\t\t\t\t\t\tplans[self._last_plan] = branch, turn, tick\n\t\t\t\t\tif (\n\t\t\t\t\t\tbranch,\n\t\t\t\t\t\tturn,\n\t\t\t\t\t) not in turn_end_plan or tick > turn_end_plan[\n\t\t\t\t\t\tbranch, turn\n\t\t\t\t\t]:\n\t\t\t\t\t\tturn_end_plan[branch, turn] = tick\n\t\t\t\t\tplan_ticks[self._last_plan][turn].add(tick)\n\t\t\t\t\tself.query.plan_ticks_insert(self._last_plan, turn, tick)\n\t\t\t\t\tfor cache in where_cached[branch_from, turn, tick]:\n\t\t\t\t\t\tdata = cache.settings[branch_from][turn][tick]\n\t\t\t\t\t\tvalue = data[-1]\n\t\t\t\t\t\tkey = data[:-1]\n\t\t\t\t\t\targs = key + (branch, turn, tick, value)\n\t\t\t\t\t\tif hasattr(cache, \"setdb\"):\n\t\t\t\t\t\t\tcache.setdb(*args)\n\t\t\t\t\t\tcache.store(*args, planning=True)\n\t\t\t\t\t\ttime_plan[branch, turn, tick] = self._last_plan\n\t\tself._planning = was_planning\n\n\t@world_locked\n\tdef delete_plan(self, plan: Plan) -> None:\n\t\t\"\"\"Delete the portion of a plan that has yet to occur.\n\n\t\t:arg plan: integer ID of a plan, as given by\n\t\t\t\t   ``with self.plan() as plan:``\n\n\t\t\"\"\"\n\t\tbranch, turn, tick = self._btt()\n\t\tto_delete: list[LinearTime] = []\n\t\tplan_ticks = self._plan_ticks[plan]\n\t\tstart_turn = start_tick = float(\"inf\")\n\t\tfor (\n\t\t\ttrn,\n\t\t\ttcks,\n\t\t) in (\n\t\t\tplan_ticks.items()\n\t\t):  # might improve performance to use a WindowDict for plan_ticks\n\t\t\tif turn == trn:\n\t\t\t\tfor tck in tcks:\n\t\t\t\t\tif (trn, tck) < (start_turn, start_tick):\n\t\t\t\t\t\t(start_turn, start_tick) = (trn, tck)\n\t\t\t\t\tif tck >= tick:\n\t\t\t\t\t\tto_delete.append((trn, tck))\n\t\t\telif trn > turn:\n\t\t\t\tfor tck in tcks:\n\t\t\t\t\tif (trn, tck) < (start_turn, start_tick):\n\t\t\t\t\t\t(start_turn, start_tick) = (trn, tck)\n\t\t\t\t\tto_delete.append((trn, tck))\n\t\t\telse:\n\t\t\t\tfor tck in tcks:\n\t\t\t\t\tif (trn, tck) < (start_turn, start_tick):\n\t\t\t\t\t\t(start_turn, start_tick) = (trn, tck)\n\t\t# Delete stuff that happened at contradicted times,\n\t\t# and then delete the times from the plan\n\t\twhere_cached = self._where_cached\n\t\ttime_plan = self._time_plan\n\t\tfor trn, tck in to_delete:\n\t\t\tfor cache in where_cached[branch, trn, tck]:\n\t\t\t\tcache.remove(branch, trn, tck)\n\t\t\t\tif hasattr(cache, \"deldb\"):\n\t\t\t\t\tcache.deldb(branch, trn, tck)\n\t\t\tdel where_cached[branch, trn, tck]\n\t\t\tplan_ticks[trn].remove(tck)\n\t\t\tif not plan_ticks[trn]:\n\t\t\t\tdel plan_ticks[trn]\n\t\t\tdel time_plan[branch, trn, tck]\n\t\t# Delete keyframes on or after the start of the plan\n\t\tkf2del = []\n\t\tfor r, ts in self._keyframes_dict[branch].items():\n\t\t\tif r > start_turn:\n\t\t\t\tkf2del.extend((r, t) for t in ts)\n\t\t\telif r == start_turn:\n\t\t\t\tkf2del.extend((r, t) for t in ts if t >= start_tick)\n\t\tfor kf_turn, kf_tick in kf2del:\n\t\t\tself._delete_keyframe(branch, kf_turn, kf_tick)\n\n\tdef _delete_keyframe(self, branch: Branch, turn: Turn, tick: Tick) -> None:\n\t\tif (branch, turn, tick) not in self._keyframes_times:\n\t\t\traise KeyframeError(\"No keyframe at that time\", branch, turn, tick)\n\t\tself.query.delete_keyframe(branch, turn, tick)\n\t\tself._keyframes_times.remove((branch, turn, tick))\n\t\tself._keyframes_loaded.remove((branch, turn, tick))\n\t\tself._keyframes_dict[branch][turn].remove(tick)\n\t\tif not self._keyframes_dict[branch][turn]:\n\t\t\tdel self._keyframes_dict[branch][turn]\n\t\tif not self._keyframes_dict[branch]:\n\t\t\tdel self._keyframes_dict[branch]\n\t\tfor cache in self._caches:\n\t\t\tif hasattr(cache, \"delete_keyframe\"):\n\t\t\t\tcache.discard_keyframe(branch, turn, tick)\n\t\t\tif hasattr(cache, \"shallowest\"):\n\t\t\t\tcache.shallowest.clear()\n\n\t@contextmanager\n\tdef advancing(self):\n\t\t\"\"\"A context manager for when time is moving forward one turn at a time.\n\n\t\tWhen used in lisien, this means that the game is being simulated.\n\t\tIt changes how the caching works, making it more efficient.\n\n\t\t\"\"\"\n\t\tif self._forward:\n\t\t\traise ValueError(\"Already advancing\")\n\t\tself._forward = True\n\t\tyield\n\t\tself._forward = False\n\n\t@contextmanager\n\tdef batch(self):\n\t\t\"\"\"A context manager for when you're creating lots of state.\n\n\t\tReads will be much slower in a batch, but writes will be faster.\n\n\t\tYou *can* combine this with ``advancing`` but it isn't any faster.\n\n\t\t\"\"\"\n\t\tif self._no_kc:\n\t\t\tyield\n\t\t\treturn\n\t\tself._no_kc = True\n\t\twith garbage():\n\t\t\tyield\n\t\tself._no_kc = False\n\n\tdef _set_graph_in_delta(\n\t\tself,\n\t\tbranch: Branch,\n\t\tturn_from: Turn,\n\t\ttick_from: Tick,\n\t\tturn_to: Turn,\n\t\ttick_to: Tick,\n\t\tdelta: DeltaDict,\n\t\t__: Turn,\n\t\t___: Tick,\n\t\t_: None,\n\t\tgraph: CharName,\n\t\tval: Value,\n\t) -> None:\n\t\t\"\"\"Change a delta to say that a graph was deleted or not\"\"\"\n\t\tif val in (..., None, \"Deleted\"):\n\t\t\tdelta[graph] = ...\n\t\telif graph not in delta or delta[graph] is ...:\n\t\t\t# If the graph was *created* within our window,\n\t\t\t# include its whole initial keyframe\n\t\t\tdelta[graph] = {\n\t\t\t\t\"character_rulebook\": (\"character_rulebook\", graph),\n\t\t\t\t\"unit_rulebook\": (\"unit_rulebook\", graph),\n\t\t\t\t\"character_thing_rulebook\": (\n\t\t\t\t\t\"character_thing_rulebook\",\n\t\t\t\t\tgraph,\n\t\t\t\t),\n\t\t\t\t\"character_place_rulebook\": (\n\t\t\t\t\t\"character_place_rulebook\",\n\t\t\t\t\tgraph,\n\t\t\t\t),\n\t\t\t\t\"character_portal_rulebook\": (\n\t\t\t\t\t\"character_portal_rulebook\",\n\t\t\t\t\tgraph,\n\t\t\t\t),\n\t\t\t}\n\t\t\tkf_time = None\n\t\t\tthe_kf = None\n\t\t\tgraph_kf = self._graph_cache.keyframe[None,]\n\t\t\tif branch in graph_kf:\n\t\t\t\tkfb = graph_kf[branch]\n\t\t\t\tif turn_from == turn_to:\n\t\t\t\t\t# past view is reverse chronological\n\t\t\t\t\tfor t in kfb[turn_from].past(tick_to):\n\t\t\t\t\t\tif tick_from <= t:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telif t < tick_from:\n\t\t\t\t\t\t\treturn\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn\n\t\t\t\t\tkf_time = branch, turn_from, t\n\t\t\t\t\tthe_kf = graph_kf[branch][turn_from][t]\n\t\t\t\telif (\n\t\t\t\t\tturn_from in kfb\n\t\t\t\t\tand kfb[turn_from].end > tick_from\n\t\t\t\t\tand graph\n\t\t\t\t\tin (\n\t\t\t\t\t\tthe_kf := graph_kf[branch][turn_from][\n\t\t\t\t\t\t\tkfb[turn_from].end\n\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t\t):\n\t\t\t\t\tkf_time = branch, turn_from, kfb[turn_from].end\n\t\t\t\t\tthe_kf = graph_kf[branch][turn_from][kf_time[2]]\n\t\t\t\telif (\n\t\t\t\t\tkfb.rev_after(turn_from) is not None\n\t\t\t\t\tand kfb.rev_before(turn_to) is not None\n\t\t\t\t\tand kfb.rev_after(turn_from)\n\t\t\t\t\t<= (r := kfb.rev_before(turn_to))\n\t\t\t\t):\n\t\t\t\t\tif r == turn_to:\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tkfb[r].end < tick_to\n\t\t\t\t\t\t\tand graph in graph_kf[branch][r][kfb[r].end]\n\t\t\t\t\t\t):\n\t\t\t\t\t\t\tkf_time = branch, r, kfb[r].end\n\t\t\t\t\t\t\tthe_kf = graph_kf[branch][r][kf_time[2]]\n\t\t\t\t\telse:\n\t\t\t\t\t\tthe_kf = graph_kf[branch][r][kfb[r].end]\n\t\t\t\t\t\tif graph in the_kf:\n\t\t\t\t\t\t\tkf_time = branch, r, kfb[r].end\n\t\t\tif kf_time is not None:\n\t\t\t\tassert isinstance(the_kf, dict)\n\t\t\t\t# Well, we have *a keyframe* attesting the graph's existence,\n\t\t\t\t# but we don't know it was *created* at that time.\n\t\t\t\t# Check the presettings; if there was no type set for the\n\t\t\t\t# graph before this keyframe, then it's the keyframe\n\t\t\t\t# in which the graph was created.\n\t\t\t\t# (An absence of presettings data indicates that the graph\n\t\t\t\t# existed prior to the current branch.)\n\t\t\t\tpreset = self._graph_cache.presettings\n\t\t\t\tb, r, t = kf_time\n\t\t\t\tassert b == branch\n\t\t\t\tif (\n\t\t\t\t\tb not in preset\n\t\t\t\t\tor r not in preset[b]\n\t\t\t\t\tor t not in preset[b][r]\n\t\t\t\t\tor preset[b][r][t][2] is ...\n\t\t\t\t):\n\t\t\t\t\treturn\n\t\t\t\tdelta[graph] = {}\n\n\tdef _get_branch_delta(\n\t\tself,\n\t\tbranch: Branch,\n\t\tturn_from: Turn,\n\t\ttick_from: Tick,\n\t\tturn_to: Turn,\n\t\ttick_to: Tick,\n\t) -> DeltaDict:\n\t\t\"\"\"Get a dictionary describing changes to all graphs.\n\n\t\tThe keys are graph names. Their values are dictionaries of the\n\t\tgraphs' attributes' new values, with ``None`` for deleted keys. Also\n\t\tin those graph dictionaries are special keys 'node_val' and\n\t\t'edge_val' describing changes to node and edge attributes,\n\t\tand 'nodes' and 'edges' full of booleans indicating whether a node\n\t\tor edge exists.\n\n\t\t\"\"\"\n\t\tself.debug(\n\t\t\t\"Getting delta in branch %s from %d, %d to %d, %d\",\n\t\t\tbranch,\n\t\t\tturn_from,\n\t\t\ttick_from,\n\t\t\tturn_to,\n\t\t\ttick_to,\n\t\t)\n\n\t\tsetgraph = partial(\n\t\t\tself._set_graph_in_delta,\n\t\t\tbranch,\n\t\t\tturn_from,\n\t\t\ttick_from,\n\t\t\tturn_to,\n\t\t\ttick_to,\n\t\t)\n\n\t\tdef setgraphval(\n\t\t\tdelta: DeltaDict,\n\t\t\t_: Turn,\n\t\t\t__: Tick,\n\t\t\tgraph: CharName,\n\t\t\tkey: Stat,\n\t\t\tval: Value,\n\t\t) -> None:\n\t\t\t\"\"\"Change a delta to say that a graph stat was set to a certain value\"\"\"\n\t\t\tif graph not in delta:\n\t\t\t\tdelta[graph] = {}\n\t\t\tif delta[graph] is not ...:\n\t\t\t\tgraph_stats: CharDelta = delta[graph]\n\t\t\t\tgraph_stats[key] = val\n\n\t\tdef setnode(\n\t\t\tdelta: DeltaDict,\n\t\t\tturn: Turn,\n\t\t\ttick: Tick,\n\t\t\tgraph: CharName,\n\t\t\tnode: NodeName,\n\t\t\texists: bool | None,\n\t\t) -> None:\n\t\t\t\"\"\"Change a delta to say that a node was created or deleted\"\"\"\n\t\t\tif graph not in delta:\n\t\t\t\tdelta[graph] = {}\n\t\t\tif delta[graph] is ...:\n\t\t\t\treturn\n\t\t\tgraph_nodes: NodesDict = delta[graph].setdefault(\"nodes\", {})\n\t\t\tgraph_nodes[node] = bool(exists)\n\t\t\ttry:\n\t\t\t\tcontents: frozenset[NodeName] = (\n\t\t\t\t\tself._node_contents_cache.retrieve(\n\t\t\t\t\t\tgraph, node, branch, turn, tick\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\texcept KeyError:\n\t\t\t\treturn\n\t\t\tif not contents:\n\t\t\t\treturn\n\t\t\tfor thing in contents:\n\t\t\t\tgraph_nodes[thing] = bool(exists)\n\n\t\tdef setnodeval(\n\t\t\tdelta: DeltaDict,\n\t\t\t_: Turn,\n\t\t\t__: Tick,\n\t\t\tgraph: CharName,\n\t\t\tnode: NodeName,\n\t\t\tkey: Stat,\n\t\t\tvalue: Value,\n\t\t) -> None:\n\t\t\t\"\"\"Change a delta to say that a node stat was set to a certain value\"\"\"\n\t\t\tif graph not in delta:\n\t\t\t\tdelta[graph] = {}\n\t\t\tif delta[graph] is ...:\n\t\t\t\treturn\n\t\t\tif (\n\t\t\t\t\"nodes\" in delta[graph]\n\t\t\t\tand node in delta[graph][\"nodes\"]\n\t\t\t\tand not delta[graph][\"nodes\"][node]\n\t\t\t):\n\t\t\t\treturn\n\t\t\tgraphstats: CharDelta = delta[graph]\n\t\t\tnodestats: NodeValDict = graphstats.setdefault(\"node_val\", {})\n\t\t\tif node in nodestats:\n\t\t\t\tnodestats[node][key] = value\n\t\t\telse:\n\t\t\t\tnodestats[node] = {key: value}\n\n\t\tdef setedge(\n\t\t\tdelta: DeltaDict,\n\t\t\tis_multigraph: callable,\n\t\t\t_: Turn,\n\t\t\t__: Tick,\n\t\t\tgraph: CharName,\n\t\t\torig: NodeName,\n\t\t\tdest: NodeName,\n\t\t\texists: bool | None,\n\t\t) -> None:\n\t\t\t\"\"\"Change a delta to say that an edge was created or deleted\"\"\"\n\t\t\tif graph not in delta:\n\t\t\t\tdelta[graph] = {}\n\t\t\tif delta[graph] is ...:\n\t\t\t\treturn\n\t\t\tgraphstat: CharDelta = delta[graph]\n\t\t\tif \"edges\" in graphstat:\n\t\t\t\tes: EdgesDict = graphstat[\"edges\"]\n\t\t\t\tif orig in es:\n\t\t\t\t\tes[orig][dest] = bool(exists)\n\t\t\t\telse:\n\t\t\t\t\tes[orig] = {dest: bool(exists)}\n\t\t\telse:\n\t\t\t\tgraphstat[\"edges\"] = {orig: {dest: bool(exists)}}\n\n\t\tdef setedgeval(\n\t\t\tdelta: DeltaDict,\n\t\t\tis_multigraph: callable,\n\t\t\tturn: Turn,\n\t\t\ttick: Tick,\n\t\t\tgraph: CharName,\n\t\t\torig: NodeName,\n\t\t\tdest: NodeName,\n\t\t\tkey: Stat,\n\t\t\tvalue: Value,\n\t\t) -> None:\n\t\t\tif graph not in delta:\n\t\t\t\tdelta[graph] = {}\n\t\t\tif delta[graph] is ...:\n\t\t\t\treturn\n\t\t\tgraphstat: CharDelta = delta[graph]\n\t\t\tif (\n\t\t\t\t\"edges\" in graphstat\n\t\t\t\tand orig in graphstat[\"edges\"]\n\t\t\t\tand dest in graphstat[\"edges\"][orig]\n\t\t\t\tand not graphstat[\"edges\"][orig][dest]\n\t\t\t):\n\t\t\t\treturn\n\t\t\tif \"edge_val\" in graphstat:\n\t\t\t\tevs: EdgeValDict = graphstat[\"edge_val\"]\n\t\t\t\tif orig in evs:\n\t\t\t\t\tif dest in evs[orig]:\n\t\t\t\t\t\tevs[orig][dest][key] = value\n\t\t\t\t\telse:\n\t\t\t\t\t\tevs[orig][dest] = {key: value}\n\t\t\t\telse:\n\t\t\t\t\tevs[orig] = {dest: {key: value}}\n\t\t\telse:\n\t\t\t\tgraphstat[\"edge_val\"] = {orig: {dest: {key: value}}}\n\n\t\tif not isinstance(branch, str):\n\t\t\traise TypeError(\"branch must be str\")\n\t\tfor arg in (turn_from, tick_from, turn_to, tick_to):\n\t\t\tif not isinstance(arg, int):\n\t\t\t\traise TypeError(\"turn and tick must be int\")\n\t\tself.load_between(branch, turn_from, tick_from, turn_to, tick_to)\n\t\ta: LinearTime = turn_from, tick_from\n\t\tb: LinearTime = turn_to, tick_to\n\t\tif a == b:\n\t\t\treturn {}\n\t\tdelta = {}\n\t\tgraph_objs = self._graph_objs\n\n\t\tif a < b:\n\t\t\tupdater = partial(\n\t\t\t\tupdate_window, turn_from, tick_from, turn_to, tick_to\n\t\t\t)\n\t\t\tattribute = \"settings\"\n\t\telse:\n\t\t\tupdater = partial(\n\t\t\t\tupdate_backward_window, turn_from, tick_from, turn_to, tick_to\n\t\t\t)\n\t\t\tattribute = \"presettings\"\n\t\tgbranches = getattr(self._graph_cache, attribute)\n\t\tgvbranches = getattr(self._graph_val_cache, attribute)\n\t\tnbranches = getattr(self._nodes_cache, attribute)\n\t\tnvbranches = getattr(self._node_val_cache, attribute)\n\t\tebranches = getattr(self._edges_cache, attribute)\n\t\tevbranches = getattr(self._edge_val_cache, attribute)\n\t\tunivbranches = getattr(self._universal_cache, attribute)\n\t\tunitbranches = getattr(self._unitness_cache, attribute)\n\t\tthbranches = getattr(self._things_cache, attribute)\n\t\trbbranches = getattr(self._rulebooks_cache, attribute)\n\t\ttrigbranches = getattr(self._triggers_cache, attribute)\n\t\tpreqbranches = getattr(self._prereqs_cache, attribute)\n\t\tactbranches = getattr(self._actions_cache, attribute)\n\t\tnbrbranches = getattr(self._neighborhoods_cache, attribute)\n\t\tbigbranches = getattr(self._rule_bigness_cache, attribute)\n\t\tcharrbbranches = getattr(self._characters_rulebooks_cache, attribute)\n\t\tavrbbranches = getattr(self._units_rulebooks_cache, attribute)\n\t\tcharthrbbranches = getattr(\n\t\t\tself._characters_things_rulebooks_cache, attribute\n\t\t)\n\t\tcharplrbbranches = getattr(\n\t\t\tself._characters_places_rulebooks_cache, attribute\n\t\t)\n\t\tcharporbbranches = getattr(\n\t\t\tself._characters_portals_rulebooks_cache, attribute\n\t\t)\n\t\tnoderbbranches = getattr(self._nodes_rulebooks_cache, attribute)\n\t\tedgerbbranches = getattr(self._portals_rulebooks_cache, attribute)\n\n\t\tif branch in gbranches:\n\t\t\tupdater(partial(setgraph, delta), gbranches[branch])\n\n\t\tif branch in gvbranches:\n\t\t\tupdater(partial(setgraphval, delta), gvbranches[branch])\n\n\t\tif branch in nbranches:\n\t\t\tupdater(partial(setnode, delta), nbranches[branch])\n\n\t\tif branch in nvbranches:\n\t\t\tupdater(partial(setnodeval, delta), nvbranches[branch])\n\n\t\tif branch in ebranches:\n\t\t\tupdater(\n\t\t\t\tpartial(\n\t\t\t\t\tsetedge, delta, lambda g: graph_objs[g].is_multigraph()\n\t\t\t\t),\n\t\t\t\tebranches[branch],\n\t\t\t)\n\n\t\tif branch in evbranches:\n\t\t\tupdater(\n\t\t\t\tpartial(\n\t\t\t\t\tsetedgeval, delta, lambda g: graph_objs[g].is_multigraph()\n\t\t\t\t),\n\t\t\t\tevbranches[branch],\n\t\t\t)\n\n\t\tdef upduniv(\n\t\t\t_: Turn, __: Tick, ___: None, key: UniversalKey, val: Value\n\t\t):\n\t\t\tdelta.setdefault(\"universal\", {})[key] = val\n\n\t\tif branch in univbranches:\n\t\t\tupdater(upduniv, univbranches[branch])\n\n\t\tdef updunit(\n\t\t\t_: Turn,\n\t\t\t__: Tick,\n\t\t\tchar: CharName,\n\t\t\tgraph: CharName,\n\t\t\tnode: NodeName,\n\t\t\tis_unit: bool,\n\t\t):\n\t\t\tif char in delta and delta[char] is ...:\n\t\t\t\treturn\n\t\t\tdelta.setdefault(char, {}).setdefault(\"units\", {}).setdefault(\n\t\t\t\tgraph, {}\n\t\t\t)[node] = bool(is_unit)\n\n\t\tif branch in unitbranches:\n\t\t\tupdater(updunit, unitbranches[branch])\n\n\t\tdef updthing(\n\t\t\t_: Turn,\n\t\t\t__: Tick,\n\t\t\tchar: CharName,\n\t\t\tthing: NodeName,\n\t\t\tloc: NodeName,\n\t\t):\n\t\t\tif char in delta and (\n\t\t\t\tdelta[char] is ...\n\t\t\t\tor (\n\t\t\t\t\t\"nodes\" in delta[char]\n\t\t\t\t\tand thing in delta[char][\"nodes\"]\n\t\t\t\t\tand not delta[char][\"nodes\"][thing]\n\t\t\t\t)\n\t\t\t):\n\t\t\t\treturn\n\t\t\tthingd = (\n\t\t\t\tdelta.setdefault(char, {})\n\t\t\t\t.setdefault(\"node_val\", {})\n\t\t\t\t.setdefault(thing, {})\n\t\t\t)\n\t\t\tthingd[\"location\"] = loc\n\n\t\tif branch in thbranches:\n\t\t\tupdater(updthing, thbranches[branch])\n\n\t\tdef updrb(\n\t\t\t__: Turn,\n\t\t\t___: Tick,\n\t\t\t_: None,\n\t\t\trulebook: RulebookName,\n\t\t\trules: list[RuleName],\n\t\t):\n\t\t\tdelta.setdefault(\"rulebooks\", {})[rulebook] = rules or []\n\n\t\tif branch in rbbranches:\n\t\t\tupdater(updrb, rbbranches[branch])\n\n\t\tdef updru(\n\t\t\tkey: Literal[\"triggers\", \"prereqs\", \"actions\"],\n\t\t\t__: Turn,\n\t\t\t___: Tick,\n\t\t\t_: None,\n\t\t\trule: RuleName,\n\t\t\tfuns: list[RuleFuncName],\n\t\t):\n\t\t\tdelta.setdefault(\"rules\", {}).setdefault(rule, {})[key] = (\n\t\t\t\tfuns or []\n\t\t\t)\n\n\t\tif branch in trigbranches:\n\t\t\tupdater(partial(updru, \"triggers\"), trigbranches[branch])\n\n\t\tif branch in preqbranches:\n\t\t\tupdater(partial(updru, \"prereqs\"), preqbranches[branch])\n\n\t\tif branch in actbranches:\n\t\t\tupdater(partial(updru, \"actions\"), actbranches[branch])\n\n\t\tdef updnbr(\n\t\t\t__: Turn,\n\t\t\t___: Tick,\n\t\t\t_: None,\n\t\t\trule: RuleName,\n\t\t\tneighborhood: RuleNeighborhood,\n\t\t):\n\t\t\tif neighborhood is not None:\n\t\t\t\tif not isinstance(neighborhood, int):\n\t\t\t\t\traise TypeError(\n\t\t\t\t\t\t\"Neighborhood must be int or None\", neighborhood\n\t\t\t\t\t)\n\t\t\t\tif neighborhood < 0:\n\t\t\t\t\traise ValueError(\n\t\t\t\t\t\t\"Neighborhood must not be negative\", neighborhood\n\t\t\t\t\t)\n\t\t\tdelta.setdefault(\"rules\", {}).setdefault(rule, {})[\n\t\t\t\t\"neighborhood\"\n\t\t\t] = neighborhood\n\n\t\tif branch in nbrbranches:\n\t\t\tupdater(updnbr, nbrbranches[branch])\n\n\t\tdef updbig(__: Turn, ___: Tick, _: None, rule: RuleName, big: RuleBig):\n\t\t\tif big is not None and not isinstance(big, bool):\n\t\t\t\traise TypeError(\"big must be boolean\", big)\n\t\t\tdelta.setdefault(\"rules\", {}).setdefault(rule, {})[\"big\"] = big\n\n\t\tif branch in bigbranches:\n\t\t\tupdater(updbig, bigbranches[branch])\n\n\t\tdef updcrb(\n\t\t\tkey: CharacterRulebookTypeStr,\n\t\t\t__: Turn,\n\t\t\t___: Tick,\n\t\t\t_: None,\n\t\t\tcharacter: CharName,\n\t\t\trulebook: RulebookName,\n\t\t):\n\t\t\tif character in delta and delta[character] is ...:\n\t\t\t\treturn\n\t\t\tdelta.setdefault(character, {})[key] = rulebook\n\n\t\tif branch in charrbbranches:\n\t\t\tupdater(\n\t\t\t\tpartial(updcrb, \"character_rulebook\"), charrbbranches[branch]\n\t\t\t)\n\n\t\tif branch in avrbbranches:\n\t\t\tupdater(partial(updcrb, \"unit_rulebook\"), avrbbranches[branch])\n\n\t\tif branch in charthrbbranches:\n\t\t\tupdater(\n\t\t\t\tpartial(updcrb, \"character_thing_rulebook\"),\n\t\t\t\tcharthrbbranches[branch],\n\t\t\t)\n\n\t\tif branch in charplrbbranches:\n\t\t\tupdater(\n\t\t\t\tpartial(updcrb, \"character_place_rulebook\"),\n\t\t\t\tcharplrbbranches[branch],\n\t\t\t)\n\n\t\tif branch in charporbbranches:\n\t\t\tupdater(\n\t\t\t\tpartial(updcrb, \"character_portal_rulebook\"),\n\t\t\t\tcharporbbranches[branch],\n\t\t\t)\n\n\t\tdef updnoderb(\n\t\t\t_: Turn,\n\t\t\t__: Tick,\n\t\t\tcharacter: CharName,\n\t\t\tnode: NodeName,\n\t\t\trulebook: RulebookName,\n\t\t):\n\t\t\tif (character in delta) and (\n\t\t\t\tdelta[character] is ...\n\t\t\t\tor (\n\t\t\t\t\t\"nodes\" in delta[character]\n\t\t\t\t\tand node in delta[character][\"nodes\"]\n\t\t\t\t\tand not delta[character][\"nodes\"][node]\n\t\t\t\t)\n\t\t\t):\n\t\t\t\treturn\n\t\t\tdelta.setdefault(character, {}).setdefault(\n\t\t\t\t\"node_val\", {}\n\t\t\t).setdefault(node, {})[\"rulebook\"] = rulebook\n\n\t\tif branch in noderbbranches:\n\t\t\tupdater(updnoderb, noderbbranches[branch])\n\n\t\tdef updedgerb(\n\t\t\t_: Turn,\n\t\t\t__: Tick,\n\t\t\tcharacter: CharName,\n\t\t\torig: NodeName,\n\t\t\tdest: NodeName,\n\t\t\trulebook: RulebookName | None = None,\n\t\t):\n\t\t\tif rulebook is None:\n\t\t\t\t# It's one of those updates that stores all the rulebooks from\n\t\t\t\t# some origin. Not relevant to deltas.\n\t\t\t\treturn\n\t\t\tif character in delta and (\n\t\t\t\tdelta[character] is ...\n\t\t\t\tor (\n\t\t\t\t\t\"edges\" in delta[character]\n\t\t\t\t\tand orig in delta[character][\"edges\"]\n\t\t\t\t\tand dest in delta[character][\"edges\"][orig]\n\t\t\t\t\tand not delta[character][\"edges\"][orig][dest]\n\t\t\t\t)\n\t\t\t):\n\t\t\t\treturn\n\t\t\tdelta.setdefault(character, {}).setdefault(\n\t\t\t\t\"edge_val\", {}\n\t\t\t).setdefault(orig, {}).setdefault(dest, {})[\"rulebook\"] = rulebook\n\n\t\tif branch in edgerbbranches:\n\t\t\tupdater(updedgerb, edgerbbranches[branch])\n\n\t\treturn delta\n\n\t@cached_property\n\tdef next_turn(self) -> NextTurn:\n\t\treturn NextTurn(self)\n\n\t@cached_property\n\tdef world_lock(self):\n\t\treturn RLock()\n\n\t@world_locked\n\tdef __init__(\n\t\tself,\n\t\tprefix: PathLike | str | None = \".\",\n\t\t*,\n\t\tstring: StringStore | dict | None = None,\n\t\ttrigger: FunctionStore | ModuleType | None = None,\n\t\tprereq: FunctionStore | ModuleType | None = None,\n\t\taction: FunctionStore | ModuleType | None = None,\n\t\tfunction: FunctionStore | ModuleType | None = None,\n\t\tmethod: FunctionStore | ModuleType | None = None,\n\t\tmain_branch: Branch | None = None,\n\t\tconnect_string: str | None = None,\n\t\tconnect_args: dict | None = None,\n\t\tschema_cls: Type[AbstractSchema] = NullSchema,\n\t\tflush_interval: int | None = None,\n\t\tkeyframe_interval: int | None = 1000,\n\t\tcommit_interval: int | None = None,\n\t\trandom_seed: int | None = None,\n\t\tclear: bool = False,\n\t\tkeep_rules_journal: bool = True,\n\t\tkeyframe_on_close: bool = True,\n\t\tenforce_end_of_time: bool = True,\n\t\tlogger: Logger | None = None,\n\t\tworkers: int | None = None,\n\t):\n\t\tif workers is None:\n\t\t\tworkers = os.cpu_count()\n\t\tif prefix:\n\t\t\tos.makedirs(prefix, exist_ok=True)\n\t\tself._planning = False\n\t\tself._forward = False\n\t\tself._no_kc = False\n\t\tself._enforce_end_of_time = enforce_end_of_time\n\t\tself._keyframe_on_close = keyframe_on_close\n\t\tself._prefix = prefix\n\t\tself.keep_rules_journal = keep_rules_journal\n\t\tself.flush_interval = flush_interval\n\t\tself.commit_interval = commit_interval\n\t\tself.schema = schema_cls(self)\n\t\t# in case this is the first startup\n\t\tself._obranch = main_branch or \"trunk\"\n\t\tself._otick = self._oturn = 0\n\t\tif logger is not None:\n\t\t\tself._logger = logger\n\t\tworker_handler = StreamHandler()\n\t\tworker_handler.addFilter(lambda rec: hasattr(rec, \"worker_idx\"))\n\t\tworker_handler.setLevel(DEBUG)\n\t\tworker_handler.setFormatter(WorkerFormatter())\n\t\tself.logger.addHandler(worker_handler)\n\t\tself._init_func_stores(\n\t\t\tprefix, function, method, trigger, prereq, action, clear\n\t\t)\n\t\tself._init_load(\n\t\t\tprefix,\n\t\t\tconnect_string,\n\t\t\tconnect_args,\n\t\t\tkeyframe_interval,\n\t\t\tmain_branch,\n\t\t\tclear,\n\t\t)\n\t\tself._init_random(random_seed)\n\t\tself._init_string(prefix, string, clear)\n\t\tself._top_uid = 0\n\t\tif workers != 0:\n\t\t\tself._start_worker_processes(prefix, workers)\n\n\tdef _init_func_stores(\n\t\tself,\n\t\tprefix: str | os.PathLike | None,\n\t\tfunction: ModuleType | FunctionStore,\n\t\tmethod: ModuleType | FunctionStore,\n\t\ttrigger: ModuleType | FunctionStore,\n\t\tprereq: ModuleType | FunctionStore,\n\t\taction: ModuleType | FunctionStore,\n\t\tclear: bool,\n\t):\n\t\tfor module, name in (\n\t\t\t(function, \"function\"),\n\t\t\t(method, \"method\"),\n\t\t\t(trigger, \"trigger\"),\n\t\t\t(prereq, \"prereq\"),\n\t\t\t(action, \"action\"),\n\t\t):\n\t\t\tif isinstance(module, ModuleType):\n\t\t\t\tsetattr(self, name, module)\n\t\t\telif prefix is None:\n\t\t\t\tsetattr(self, name, FunctionStore(None, module=name))\n\t\t\telse:\n\t\t\t\tfn = os.path.join(prefix, f\"{name}.py\")\n\t\t\t\tsetattr(self, name, FunctionStore(fn, module=name))\n\t\t\t\tif clear and os.path.exists(fn):\n\t\t\t\t\tos.remove(fn)\n\n\tdef _init_load(\n\t\tself,\n\t\tprefix: str | os.PathLike | None,\n\t\tconnect_string: str | None,\n\t\tconnect_args: dict | None,\n\t\tkeyframe_interval: int | None,\n\t\tmain_branch: Branch,\n\t\tclear: bool,\n\t):\n\t\tif prefix is None:\n\t\t\tif connect_string is None:\n\t\t\t\tself.query = NullQueryEngine()\n\t\t\telse:\n\t\t\t\tself.query = SQLAlchemyQueryEngine(\n\t\t\t\t\tconnect_string, connect_args or {}, self.pack, self.unpack\n\t\t\t\t)\n\t\telse:\n\t\t\tif not os.path.exists(prefix):\n\t\t\t\tos.mkdir(prefix)\n\t\t\tif not os.path.isdir(prefix):\n\t\t\t\traise FileExistsError(\"Need a directory\")\n\t\t\tif connect_string is None:\n\t\t\t\tself.query = ParquetQueryEngine(\n\t\t\t\t\tos.path.join(prefix, \"world\"),\n\t\t\t\t\tself.pack,\n\t\t\t\t\tself.unpack,\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\tself.query = SQLAlchemyQueryEngine(\n\t\t\t\t\tconnect_string, connect_args or {}, self.pack, self.unpack\n\t\t\t\t)\n\t\t\tif clear:\n\t\t\t\tself.query.truncate_all()\n\n\t\tself.query.keyframe_interval = keyframe_interval\n\t\tself._load_keyframe_times()\n\t\tif main_branch is not None:\n\t\t\tself.query.globl[\"main_branch\"] = main_branch\n\t\telif \"main_branch\" not in self.query.globl:\n\t\t\tmain_branch = self.query.globl[\"main_branch\"] = \"trunk\"\n\t\telse:\n\t\t\tmain_branch = self.query.globl[\"main_branch\"]\n\t\tassert main_branch is not None\n\t\tassert main_branch == self.query.globl[\"main_branch\"]\n\t\tself._obranch = self.query.get_branch()\n\t\tself._oturn = self.query.get_turn()\n\t\tself._otick = self.query.get_tick()\n\t\tfor (\n\t\t\tbranch,\n\t\t\tparent,\n\t\t\tparent_turn,\n\t\t\tparent_tick,\n\t\t\tend_turn,\n\t\t\tend_tick,\n\t\t) in self.query.all_branches():\n\t\t\tself._branches_d[branch] = (\n\t\t\t\tparent,\n\t\t\t\tparent_turn,\n\t\t\t\tparent_tick,\n\t\t\t\tend_turn,\n\t\t\t\tend_tick,\n\t\t\t)\n\t\t\tself._upd_branch_parentage(parent, branch)\n\t\tfor branch, turn, end_tick, plan_end_tick in self.query.turns_dump():\n\t\t\tself._turn_end[branch, turn] = max(\n\t\t\t\tself._turn_end[branch, turn], end_tick\n\t\t\t)\n\t\t\tself._turn_end_plan[branch, turn] = max(\n\t\t\t\t(self._turn_end_plan[branch, turn], plan_end_tick)\n\t\t\t)\n\t\tif main_branch not in self._branches_d:\n\t\t\tself._branches_d[main_branch] = None, 0, 0, 0, 0\n\t\tself._load_graphs()\n\t\tself._load_plans()\n\t\tself._load_rules_handled()\n\t\tself._turns_completed_d.update(self.query.turns_completed_dump())\n\t\tself._rules_cache = {\n\t\t\tname: Rule(self, name, create=False)\n\t\t\tfor name in self.query.rules_dump()\n\t\t}\n\t\twith garbage():\n\t\t\tself._load(*self._read_at(*self._btt()))\n\t\tself.query.snap_keyframe = self.snap_keyframe\n\t\tself.query.kf_interval_override = self._detect_kf_interval_override\n\t\tif not self._keyframes_times:\n\t\t\tself._snap_keyframe_de_novo(*self._btt())\n\n\tdef _init_random(self, random_seed: int | None):\n\t\tself._rando = Random()\n\t\tif \"rando_state\" in self.universal:\n\t\t\tself._rando.setstate(self.universal[\"rando_state\"])\n\t\telse:\n\t\t\tself._rando.seed(random_seed)\n\t\t\trando_state = self._rando.getstate()\n\t\t\tif self._oturn == self._otick == 0:\n\t\t\t\tnow = self._btt()\n\t\t\t\tif now in self._keyframes_times:\n\t\t\t\t\tassert now in self._keyframes_loaded\n\t\t\t\t\tkf = self._universal_cache.get_keyframe(*now, copy=False)\n\t\t\t\t\tkf[\"rando_state\"] = rando_state\n\t\t\t\tself._universal_cache.store(\n\t\t\t\t\t\"rando_state\",\n\t\t\t\t\tself.branch,\n\t\t\t\t\tTurn(0),\n\t\t\t\t\tTick(0),\n\t\t\t\t\trando_state,\n\t\t\t\t\tloading=True,\n\t\t\t\t)\n\t\t\t\tself.query.universal_set(\n\t\t\t\t\t\"rando_state\",\n\t\t\t\t\tself.branch,\n\t\t\t\t\tTurn(0),\n\t\t\t\t\tTick(0),\n\t\t\t\t\trando_state,\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\tself.universal[\"rando_state\"] = rando_state\n\n\tdef _init_string(\n\t\tself,\n\t\tprefix: str | os.PathLike | None,\n\t\tstring: StringStore | dict | None,\n\t\tclear: bool,\n\t):\n\t\tif string:\n\t\t\tself.string = string\n\t\telif prefix is None:\n\t\t\tself.string = StringStore(\n\t\t\t\tself,\n\t\t\t\tNone,\n\t\t\t\tself.eternal.setdefault(\"language\", \"eng\"),\n\t\t\t)\n\t\telif isinstance(string, dict):\n\t\t\tself.string = StringStore(\n\t\t\t\tstring, None, self.eternal.setdefault(\"language\", \"eng\")\n\t\t\t)\n\t\telse:\n\t\t\tstring_prefix = os.path.join(prefix, \"strings\")\n\t\t\tif clear and os.path.isdir(string_prefix):\n\t\t\t\tshutil.rmtree(string_prefix)\n\t\t\tif not os.path.exists(string_prefix):\n\t\t\t\tos.mkdir(string_prefix)\n\t\t\tself.string = StringStore(\n\t\t\t\tself,\n\t\t\t\tstring_prefix,\n\t\t\t\tself.eternal.setdefault(\"language\", \"eng\"),\n\t\t\t)\n\n\tdef _sync_log_forever(self, q: SimpleQueue[LogRecord]) -> None:\n\t\twhile not hasattr(self, \"_closed\"):\n\t\t\trecs: list[LogRecord] = []\n\t\t\twhile True:\n\t\t\t\ttry:\n\t\t\t\t\trecs.append(q.get())\n\t\t\t\texcept Empty:\n\t\t\t\t\tbreak\n\t\t\tfor rec in recs:\n\t\t\t\tself.logger.handle(rec)\n\t\t\tsleep(0.5)\n\n\tdef _start_worker_processes(\n\t\tself, prefix: str | os.PathLike | None, workers: int\n\t):\n\t\tfrom multiprocessing import get_context\n\t\tfrom multiprocessing.connection import Connection\n\t\tfrom multiprocessing.process import BaseProcess\n\n\t\tfor store in self.stores:\n\t\t\tif hasattr(store, \"save\"):\n\t\t\t\tstore.save(reimport=False)\n\n\t\tself._trigger_pool = ThreadPoolExecutor()\n\t\tself._worker_last_eternal = dict(self.eternal.items())\n\t\tinitial_payload = self._get_worker_kf_payload()\n\n\t\tself._worker_processes: list[BaseProcess] = []\n\t\twp = self._worker_processes\n\t\tself._mp_ctx = ctx = get_context(\"spawn\")\n\t\tself._worker_inputs: list[Connection] = []\n\t\twi = self._worker_inputs\n\t\tself._worker_outputs: list[Connection] = []\n\t\two = self._worker_outputs\n\t\tself._worker_locks: list[Lock] = []\n\t\twlk = self._worker_locks\n\t\tself._worker_log_queues: list[SimpleQueue] = []\n\t\twl = self._worker_log_queues\n\t\tself._worker_log_threads: list[Thread] = []\n\t\twlt = self._worker_log_threads\n\t\tfor i in range(workers):\n\t\t\tinpipe_there, inpipe_here = ctx.Pipe(duplex=False)\n\t\t\toutpipe_here, outpipe_there = ctx.Pipe(duplex=False)\n\t\t\tlogq = ctx.SimpleQueue()\n\t\t\tlogthread = Thread(\n\t\t\t\ttarget=self._sync_log_forever, args=(logq,), daemon=True\n\t\t\t)\n\t\t\tworker_args = [\n\t\t\t\ti,\n\t\t\t\tprefix,\n\t\t\t\tself._branches_d,\n\t\t\t\tdict(self.eternal),\n\t\t\t\tinpipe_there,\n\t\t\t\toutpipe_there,\n\t\t\t\tlogq,\n\t\t\t]\n\t\t\tfor store in (\n\t\t\t\tself.function,\n\t\t\t\tself.method,\n\t\t\t\tself.trigger,\n\t\t\t\tself.prereq,\n\t\t\t\tself.action,\n\t\t\t):\n\t\t\t\tif hasattr(store, \"_locl\"):\n\t\t\t\t\tworker_args.append(store._locl)\n\t\t\t\telif hasattr(store, \"__dict__\"):\n\t\t\t\t\tworker_args.append(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: v\n\t\t\t\t\t\t\tfor (k, v) in store.__dict__.items()\n\t\t\t\t\t\t\tif callable(v)\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\telse:\n\t\t\t\t\tfuncs = {}\n\t\t\t\t\tfor name in dir(store):\n\t\t\t\t\t\tvalue = getattr(store, name)\n\t\t\t\t\t\tif callable(value):\n\t\t\t\t\t\t\tfuncs[name] = value\n\t\t\t\t\tworker_args.append(funcs)\n\t\t\tproc = ctx.Process(\n\t\t\t\ttarget=worker_subprocess,\n\t\t\t\targs=worker_args,\n\t\t\t)\n\t\t\twi.append(inpipe_here)\n\t\t\two.append(outpipe_here)\n\t\t\twl.append(logq)\n\t\t\twlk.append(Lock())\n\t\t\twlt.append(logthread)\n\t\t\twp.append(proc)\n\t\t\tlogthread.start()\n\t\t\tproc.start()\n\t\t\twith wlk[-1]:\n\t\t\t\tinpipe_here.send_bytes(initial_payload)\n\t\tif hasattr(self.trigger, \"connect\"):\n\t\t\tself.trigger.connect(self._reimport_trigger_functions)\n\t\tif hasattr(self.function, \"connect\"):\n\t\t\tself.function.connect(self._reimport_worker_functions)\n\t\tif hasattr(self.method, \"connect\"):\n\t\t\tself.method.connect(self._reimport_worker_methods)\n\t\tself._setup_fut_manager(workers)\n\n\tdef _setup_fut_manager(self, workers: int):\n\t\tself._workers = workers\n\t\tself._worker_updated_btts: list[Time] = [self._btt()] * workers\n\t\tself._uid_to_fut: dict[int, Future] = {}\n\t\tself._futs_to_start: SimpleQueue[Future] = SimpleQueue()\n\t\tself._how_many_futs_running = 0\n\t\tself._fut_manager_thread = Thread(\n\t\t\ttarget=self._manage_futs, daemon=True\n\t\t)\n\t\tself._fut_manager_thread.start()\n\n\tdef _start_branch(\n\t\tself, parent: Branch, branch: Branch, turn: Turn, tick: Tick\n\t) -> None:\n\t\t\"\"\"Record the point at which a new branch forks off from its parent\"\"\"\n\t\t_, start_turn, start_tick, end_turn, end_tick = self._branches_d[\n\t\t\tparent\n\t\t]\n\t\tif not (\n\t\t\t(start_turn, start_tick) <= (turn, tick) <= (end_turn, end_tick)\n\t\t):\n\t\t\traise OutOfTimelineError(\n\t\t\t\t\"The parent branch does not cover that time\",\n\t\t\t\tparent,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t)\n\t\tself._branches_d[branch] = (parent, turn, tick, turn, tick)\n\t\tself._turn_end[branch, turn] = self._turn_end_plan[branch, turn] = tick\n\t\tself._loaded[branch] = (turn, tick, None, None)\n\t\tself._upd_branch_parentage(parent, branch)\n\t\tself.query.new_branch(branch, parent, turn, tick)\n\n\tdef _extend_branch(self, branch: Branch, turn: Turn, tick: Tick) -> None:\n\t\t\"\"\"Record a change in the span of time that a branch includes\"\"\"\n\t\tparent, start_turn, start_tick, end_turn, end_tick = self._branches_d[\n\t\t\tbranch\n\t\t]\n\t\tif (turn, tick) < (start_turn, start_tick):\n\t\t\traise OutOfTimelineError(\n\t\t\t\t\"Can't extend branch backwards\", branch, turn, tick\n\t\t\t)\n\t\tif (turn, tick) < (end_turn, end_tick):\n\t\t\treturn\n\t\tif (branch, turn) in self._turn_end_plan:\n\t\t\tif tick > self._turn_end_plan[branch, turn]:\n\t\t\t\tself._turn_end_plan[branch, turn] = tick\n\t\telse:\n\t\t\tself._turn_end_plan[branch, turn] = tick\n\t\tself._updload(branch, turn, tick)\n\t\tif not self._planning:\n\t\t\tself._branches_d[branch] = (\n\t\t\t\tparent,\n\t\t\t\tstart_turn,\n\t\t\t\tstart_tick,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t)\n\t\t\tif (branch, turn) in self._turn_end:\n\t\t\t\tif tick > self._turn_end[branch, turn]:\n\t\t\t\t\tself._turn_end[branch, turn] = tick\n\t\t\telse:\n\t\t\t\tself._turn_end[branch, turn] = tick\n\n\tdef _get_keyframe(\n\t\tself,\n\t\tbranch: Branch,\n\t\tturn: Turn,\n\t\ttick: Tick,\n\t\trulebooks: bool = True,\n\t\tsilent: bool = False,\n\t) -> Keyframe | None:\n\t\t\"\"\"Load the keyframe if it's not loaded, and return it\"\"\"\n\t\tif (branch, turn, tick) in self._keyframes_loaded:\n\t\t\tself.debug(\n\t\t\t\t\"Keyframe already loaded, returning %s, %d, %d from memory\",\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t)\n\t\t\tif silent:\n\t\t\t\treturn\n\t\t\treturn self._get_kf(branch, turn, tick, rulebooks=rulebooks)\n\t\tuniv, rule, rulebook = self.query.get_keyframe_extensions(\n\t\t\tbranch, turn, tick\n\t\t)\n\t\tself._universal_cache.set_keyframe(branch, turn, tick, univ)\n\t\tself._triggers_cache.set_keyframe(\n\t\t\tbranch, turn, tick, rule.get(\"triggers\", {})\n\t\t)\n\t\tself._prereqs_cache.set_keyframe(\n\t\t\tbranch, turn, tick, rule.get(\"prereqs\", {})\n\t\t)\n\t\tself._actions_cache.set_keyframe(\n\t\t\tbranch, turn, tick, rule.get(\"actions\", {})\n\t\t)\n\t\tself._neighborhoods_cache.set_keyframe(\n\t\t\tbranch, turn, tick, rule.get(\"neighborhood\", {})\n\t\t)\n\t\tself._rule_bigness_cache.set_keyframe(\n\t\t\tbranch, turn, tick, rule.get(\"big\", {})\n\t\t)\n\t\tself._rulebooks_cache.set_keyframe(branch, turn, tick, rulebook)\n\t\tkeyframe_graphs = list(\n\t\t\tself.query.get_all_keyframe_graphs(branch, turn, tick)\n\t\t)\n\t\twith (\n\t\t\tself.batch()\n\t\t):  # so that iter_keys doesn't try fetching the kf we're about to make\n\t\t\tself._graph_cache.set_keyframe(\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t\t{graph: \"DiGraph\" for (graph, _, _, _) in keyframe_graphs},\n\t\t\t)\n\t\t\tfor (\n\t\t\t\tgraph,\n\t\t\t\tnodes,\n\t\t\t\tedges,\n\t\t\t\tgraph_val,\n\t\t\t) in keyframe_graphs:\n\t\t\t\tself._snap_keyframe_de_novo_graph(\n\t\t\t\t\tgraph, branch, turn, tick, nodes, edges, graph_val\n\t\t\t\t)\n\t\tif not keyframe_graphs:\n\t\t\tfor cache in (\n\t\t\t\tself._characters_rulebooks_cache,\n\t\t\t\tself._units_rulebooks_cache,\n\t\t\t\tself._characters_things_rulebooks_cache,\n\t\t\t\tself._characters_places_rulebooks_cache,\n\t\t\t\tself._characters_portals_rulebooks_cache,\n\t\t\t):\n\t\t\t\tcache.set_keyframe(branch, turn, tick, {})\n\t\tself._updload(branch, turn, tick)\n\t\tif branch in self._keyframes_dict:\n\t\t\tif turn in self._keyframes_dict[branch]:\n\t\t\t\tself._keyframes_dict[branch][turn].add(tick)\n\t\t\telse:\n\t\t\t\tself._keyframes_dict[branch][turn] = {tick}\n\t\telse:\n\t\t\tself._keyframes_dict[branch] = {turn: {tick}}\n\t\tself._mark_keyframe_loaded(branch, turn, tick)\n\t\tret = self._get_kf(branch, turn, tick)\n\t\tcharrbkf = {}\n\t\tunitrbkf = {}\n\t\tcharthingrbkf = {}\n\t\tcharplacerbkf = {}\n\t\tcharportrbkf = {}\n\t\tfor graph, graphval in ret[\"graph_val\"].items():\n\t\t\tcharrbkf[graph] = graphval.get(\n\t\t\t\t\"character_rulebook\", (\"character\", graph)\n\t\t\t)\n\t\t\tunitrbkf[graph] = graphval.get(\"unit_rulebook\", (\"unit\", graph))\n\t\t\tcharthingrbkf[graph] = graphval.get(\n\t\t\t\t\"character_thing_rulebook\", (\"character_thing\", graph)\n\t\t\t)\n\t\t\tcharplacerbkf[graph] = graphval.get(\n\t\t\t\t\"character_place_rulebook\", (\"character_place\", graph)\n\t\t\t)\n\t\t\tcharportrbkf[graph] = graphval.get(\n\t\t\t\t\"character_portal_rulebook\", (\"character_portal\", graph)\n\t\t\t)\n\t\t\tself._unitness_cache.set_keyframe(\n\t\t\t\tgraph, branch, turn, tick, graphval.get(\"units\", {})\n\t\t\t)\n\t\t\tif graph in ret[\"node_val\"]:\n\t\t\t\tlocs = {}\n\t\t\t\tconts = {}\n\t\t\t\tnoderbkf = {}\n\t\t\t\tfor node, val in ret[\"node_val\"][graph].items():\n\t\t\t\t\tnoderbkf[node] = val.get(\"rulebook\", (graph, node))\n\t\t\t\t\tif \"location\" not in val:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tlocs[node] = location = val[\"location\"]\n\t\t\t\t\tif location in conts:\n\t\t\t\t\t\tconts[location].add(node)\n\t\t\t\t\telse:\n\t\t\t\t\t\tconts[location] = {node}\n\t\t\t\tself._things_cache.set_keyframe(\n\t\t\t\t\tgraph, branch, turn, tick, locs\n\t\t\t\t)\n\t\t\t\tself._node_contents_cache.set_keyframe(\n\t\t\t\t\tgraph,\n\t\t\t\t\tbranch,\n\t\t\t\t\tturn,\n\t\t\t\t\ttick,\n\t\t\t\t\t{k: frozenset(v) for (k, v) in conts.items()},\n\t\t\t\t)\n\t\t\t\tself._nodes_rulebooks_cache.set_keyframe(\n\t\t\t\t\tgraph, branch, turn, tick, noderbkf\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\tself._things_cache.set_keyframe(graph, branch, turn, tick, {})\n\t\t\t\tself._node_contents_cache.set_keyframe(\n\t\t\t\t\tgraph, branch, turn, tick, {}\n\t\t\t\t)\n\t\t\t\tself._nodes_rulebooks_cache.set_keyframe(\n\t\t\t\t\tgraph, branch, turn, tick, {}\n\t\t\t\t)\n\t\t\tif graph in ret[\"edge_val\"]:\n\t\t\t\tedgerbkf = {}\n\t\t\t\tdests: dict[NodeName, dict[Stat | Literal[\"rulebook\"], Value]]\n\t\t\t\tfor orig, dests in ret[\"edge_val\"][graph].items():\n\t\t\t\t\tif not dests:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\torigrbkf = edgerbkf[orig] = {}\n\t\t\t\t\tfor dest, val in dests.items():\n\t\t\t\t\t\torigrbkf[dest] = val.get(\n\t\t\t\t\t\t\t\"rulebook\", (graph, orig, dest)\n\t\t\t\t\t\t)\n\t\t\t\tself._portals_rulebooks_cache.set_keyframe(\n\t\t\t\t\tgraph, branch, turn, tick, edgerbkf\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\tself._portals_rulebooks_cache.set_keyframe(\n\t\t\t\t\tgraph, branch, turn, tick, {}\n\t\t\t\t)\n\t\tself._characters_rulebooks_cache.set_keyframe(\n\t\t\tbranch, turn, tick, charrbkf\n\t\t)\n\t\tself._units_rulebooks_cache.set_keyframe(branch, turn, tick, unitrbkf)\n\t\tself._characters_things_rulebooks_cache.set_keyframe(\n\t\t\tbranch, turn, tick, charthingrbkf\n\t\t)\n\t\tself._characters_places_rulebooks_cache.set_keyframe(\n\t\t\tbranch, turn, tick, charplacerbkf\n\t\t)\n\t\tself._characters_portals_rulebooks_cache.set_keyframe(\n\t\t\tbranch, turn, tick, charportrbkf\n\t\t)\n\t\tif silent:\n\t\t\treturn  # not that it helps performance any, in this case\n\t\treturn ret\n\n\tdef _iter_parent_btt(\n\t\tself,\n\t\tbranch: str = None,\n\t\tturn: int = None,\n\t\ttick: int = None,\n\t\t*,\n\t\tstoptime: tuple[str, int, int] = None,\n\t) -> Iterator[tuple[str, int, int]]:\n\t\t\"\"\"Private use.\n\n\t\tIterate over (branch, turn, tick), where the branch is\n\t\ta descendant of the previous (starting with whatever branch is\n\t\tpresently active and ending at the main branch), and the turn is the\n\t\tlatest revision in the branch that matters.\n\n\t\t:arg stoptime: a triple, ``(branch, turn, tick)``. Iteration will\n\t\tstop instead of yielding that time or any before it. The tick may be\n\t\t``None``, in which case, iteration will stop instead of yielding the\n\t\tturn.\n\n\t\t\"\"\"\n\t\tbranch = branch or self.branch\n\t\ttrn = self.turn if turn is None else turn\n\t\ttck = self.tick if tick is None else tick\n\t\tyield branch, trn, tck\n\t\tbranches = self.branches()\n\t\tif stoptime:\n\t\t\tstopbranch, stopturn, stoptick = stoptime\n\t\t\tstopping = stopbranch == branch\n\t\t\twhile branch in branches and not stopping:\n\t\t\t\ttrn, tck = self._branch_start(branch)\n\t\t\t\tbranch = self.branch_parent(branch)\n\t\t\t\tif branch is None:\n\t\t\t\t\treturn\n\t\t\t\tif branch == stopbranch:\n\t\t\t\t\tstopping = True\n\t\t\t\t\tif trn < stopturn or (\n\t\t\t\t\t\ttrn == stopturn\n\t\t\t\t\t\tand (stoptick is None or tck <= stoptick)\n\t\t\t\t\t):\n\t\t\t\t\t\treturn\n\t\t\t\tyield branch, trn, tck\n\t\telse:\n\t\t\twhile branch in branches:\n\t\t\t\ttrn, tck = self._branch_start(branch)\n\t\t\t\tbranch = self.branch_parent(branch)\n\t\t\t\tif branch is None:\n\t\t\t\t\tyield \"trunk\", 0, 0\n\t\t\t\t\treturn\n\t\t\t\tyield branch, trn, tck\n\n\tdef _iter_keyframes(\n\t\tself,\n\t\tbranch: Branch,\n\t\tturn: Turn,\n\t\ttick: Tick,\n\t\t*,\n\t\tloaded: bool = False,\n\t\twith_fork_points: bool = False,\n\t\tstoptime: Optional[Time] = None,\n\t):\n\t\t\"\"\"Iterate back over (branch, turn, tick) at which there is a keyframe\n\n\t\tFollows the timestream, like :method:`_iter_parent_btt`, but yields more times.\n\t\tWe may have any number of keyframes in the same branch, and will yield\n\t\tthem all.\n\n\t\tWith ``loaded=True``, only yield keyframes that are in memory now.\n\n\t\tUse ``with_fork_points=True`` to also include all the times that the\n\t\ttimeline branched.\n\n\t\t``stoptime`` is as in :method:`_iter_parent_btt`.\n\n\t\t\"\"\"\n\t\tkfd = self._keyframes_dict\n\t\tkfs = self._keyframes_times\n\t\tkfl = self._keyframes_loaded\n\t\tit = pairwise(\n\t\t\tself._iter_parent_btt(branch, turn, tick, stoptime=stoptime)\n\t\t)\n\t\ttry:\n\t\t\ta, b = next(it)\n\t\texcept StopIteration:\n\t\t\tassert branch in self.branches() and self._branch_start(\n\t\t\t\tbranch\n\t\t\t) == (\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t)\n\t\t\ta = (branch, turn, tick)\n\t\t\tb = (branch, 0, 0)\n\t\t\tif a == b:\n\t\t\t\tif (loaded and a in kfl) or (not loaded and a in kfs):\n\t\t\t\t\tyield a\n\t\t\t\treturn\n\t\tfor (b0, r0, t0), (b1, r1, t1) in chain([(a, b)], it):\n\t\t\t# we're going up the timestream, meaning that b1, r1, t1\n\t\t\t# is *before* b0, r0, t0\n\t\t\tif loaded:\n\t\t\t\tif (b0, r0, t0) in kfl:\n\t\t\t\t\tyield b0, r0, t0\n\t\t\telif (b0, r0, t0) in kfs:\n\t\t\t\tyield b0, r0, t0\n\t\t\tif b0 not in kfd:\n\t\t\t\tcontinue\n\t\t\tassert b0 in self.branches()\n\t\t\tkfdb = kfd[b0]\n\t\t\tif r0 in kfdb:\n\t\t\t\ttcks = sorted(kfdb[r0])\n\t\t\t\twhile tcks and tcks[-1] > t0:\n\t\t\t\t\ttcks.pop()\n\t\t\t\tif not tcks:\n\t\t\t\t\tif with_fork_points:\n\t\t\t\t\t\tyield b0, r0, t0\n\t\t\t\t\tcontinue\n\t\t\t\tif loaded:\n\t\t\t\t\tfor tck in reversed(tcks):\n\t\t\t\t\t\tif r0 == r1 and tck <= t1:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tif (b0, r0, tck) != (b0, r0, t0) and (\n\t\t\t\t\t\t\tb0,\n\t\t\t\t\t\t\tr0,\n\t\t\t\t\t\t\ttck,\n\t\t\t\t\t\t) in kfl:\n\t\t\t\t\t\t\tyield b0, r0, tck\n\t\t\t\telse:\n\t\t\t\t\tfor tck in reversed(tcks):\n\t\t\t\t\t\tif tck < t0:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tyield b0, r0, tck\n\t\t\tif r0 == r1:\n\t\t\t\tif r0 in kfdb:\n\t\t\t\t\ttcks = sorted(kfdb[r0], reverse=True)\n\t\t\t\t\tif loaded:\n\t\t\t\t\t\tfor tck in tcks:\n\t\t\t\t\t\t\tif (b0, r0, tck) in kfl:\n\t\t\t\t\t\t\t\tyield b0, r0, tck\n\t\t\t\t\telse:\n\t\t\t\t\t\tfor tck in tcks:\n\t\t\t\t\t\t\tyield b0, r0, tck\n\t\t\telse:\n\t\t\t\tfor r_between in range(r0 - 1, r1, -1):  # too much iteration?\n\t\t\t\t\tif r_between in kfdb:\n\t\t\t\t\t\ttcks = sorted(kfdb[r_between], reverse=True)\n\t\t\t\t\t\tif loaded:\n\t\t\t\t\t\t\tfor tck in tcks:\n\t\t\t\t\t\t\t\tif (b0, r_between, tck) in kfl:\n\t\t\t\t\t\t\t\t\tyield b0, r_between, tck\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tfor tck in tcks:\n\t\t\t\t\t\t\t\tyield b0, r_between, tck\n\t\t\tif r1 in kfdb:\n\t\t\t\ttcks = sorted(kfdb[r1], reverse=True)\n\t\t\t\tif loaded:\n\t\t\t\t\tfor tck in tcks:\n\t\t\t\t\t\tif tck <= t1:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tif (b0, r1, tck) in kfl:\n\t\t\t\t\t\t\tyield b0, r1, tck\n\t\t\t\telse:\n\t\t\t\t\tfor tck in tcks:\n\t\t\t\t\t\tif tck <= t1:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tyield b0, r1, tck\n\t\tif b1 in kfd and r1 in kfd[b1]:\n\t\t\tkfdb = kfd[b1]\n\t\t\ttcks = sorted(kfdb[r1], reverse=True)\n\t\t\twhile tcks[-1] > t1:\n\t\t\t\ttcks.pop()\n\t\t\tif not tcks:\n\t\t\t\tif with_fork_points:\n\t\t\t\t\tyield b1, r1, t1\n\t\t\t\treturn\n\t\t\tif loaded:\n\t\t\t\tfor tck in tcks:\n\t\t\t\t\tif (b1, r1, tck) in kfl:\n\t\t\t\t\t\tyield b1, r1, tck\n\t\t\telse:\n\t\t\t\tfor tck in tcks:\n\t\t\t\t\tyield b1, r1, tck\n\t\t\tif with_fork_points and tcks[-1] == t1:\n\t\t\t\treturn\n\t\tif with_fork_points:\n\t\t\tyield b1, r1, t1\n\n\tdef _has_graph(self, graph, branch=None, turn=None, tick=None):\n\t\tif branch is None:\n\t\t\tbranch = self.branch\n\t\tif turn is None:\n\t\t\tturn = self.turn\n\t\tif tick is None:\n\t\t\ttick = self.tick\n\t\ttry:\n\t\t\treturn (\n\t\t\t\tself._graph_cache.retrieve(graph, branch, turn, tick)\n\t\t\t\t!= \"Deleted\"\n\t\t\t)\n\t\texcept KeyError:\n\t\t\treturn False\n\n\tdef _get_kf(\n\t\tself,\n\t\tbranch: Branch,\n\t\tturn: Turn,\n\t\ttick: Tick,\n\t\trulebooks: bool = True,\n\t) -> Keyframe:\n\t\t\"\"\"Get a keyframe that's already in memory\"\"\"\n\t\tassert (branch, turn, tick) in self._keyframes_loaded\n\t\tgraph_val: GraphValKeyframe = {}\n\t\tnodes: GraphNodesKeyframe = {}\n\t\tnode_val: GraphNodeValKeyframe = {}\n\t\tedges: GraphEdgesKeyframe = {}\n\t\tedge_val: GraphEdgeValKeyframe = {}\n\t\tkf: Keyframe = {\n\t\t\t\"graph_val\": graph_val,\n\t\t\t\"nodes\": nodes,\n\t\t\t\"node_val\": node_val,\n\t\t\t\"edges\": edges,\n\t\t\t\"edge_val\": edge_val,\n\t\t}\n\t\tfor k in self._graph_cache.iter_keys(branch, turn, tick):\n\t\t\ttry:\n\t\t\t\tif (\n\t\t\t\t\tself._graph_cache.retrieve(k, branch, turn, tick)\n\t\t\t\t\t== \"Deleted\"\n\t\t\t\t):\n\t\t\t\t\tcontinue\n\t\t\texcept KeyError:\n\t\t\t\tcontinue\n\t\t\ttry:\n\t\t\t\tgraph_val[k] = self._graph_val_cache.get_keyframe(\n\t\t\t\t\tk, branch, turn, tick\n\t\t\t\t)\n\t\t\texcept KeyframeError:\n\t\t\t\tgraph_val[k] = {}\n\t\t\ttry:\n\t\t\t\tgraph_val[k][\"units\"] = (\n\t\t\t\t\tself._unitness_cache.dict_cache.get_keyframe(\n\t\t\t\t\t\tk, branch, turn, tick\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\texcept KeyframeError:\n\t\t\t\tpass\n\t\t\ttry:\n\t\t\t\tnodes[k] = self._nodes_cache.get_keyframe(\n\t\t\t\t\tk, branch, turn, tick\n\t\t\t\t)\n\t\t\texcept KeyframeError:\n\t\t\t\tpass\n\t\t\ttry:\n\t\t\t\tnode_val[k] = self._node_val_cache.get_keyframe(\n\t\t\t\t\tk, branch, turn, tick\n\t\t\t\t)\n\t\t\texcept KeyframeError:\n\t\t\t\tpass\n\t\t\ttry:\n\t\t\t\tedges[k] = self._edges_cache.get_keyframe(\n\t\t\t\t\tk, branch, turn, tick\n\t\t\t\t)\n\t\t\texcept KeyframeError:\n\t\t\t\tpass\n\t\t\ttry:\n\t\t\t\tedge_val[k] = self._edge_val_cache.get_keyframe(\n\t\t\t\t\tk, branch, turn, tick\n\t\t\t\t)\n\t\t\texcept KeyframeError:\n\t\t\t\tpass\n\t\t\ttry:\n\t\t\t\tlocs_kf = self._things_cache.get_keyframe(\n\t\t\t\t\tk, branch, turn, tick\n\t\t\t\t)\n\t\t\texcept KeyframeError:\n\t\t\t\tlocs_kf = {}\n\t\t\t\tfor thing in list(\n\t\t\t\t\tself._things_cache.iter_entities(k, branch, turn, tick)\n\t\t\t\t):\n\t\t\t\t\tlocs_kf[thing] = self._things_cache.retrieve(\n\t\t\t\t\t\tk, thing, branch, turn, tick\n\t\t\t\t\t)\n\t\t\tif k not in node_val:\n\t\t\t\tnode_val[k] = {\n\t\t\t\t\tthing: {\"location\": loc}\n\t\t\t\t\tfor (thing, loc) in locs_kf.items()\n\t\t\t\t}\n\t\t\telse:\n\t\t\t\tfor thing, loc in locs_kf.items():\n\t\t\t\t\tif thing in node_val[k]:\n\t\t\t\t\t\tnode_val[k][thing][\"location\"] = loc\n\t\t\t\t\telse:\n\t\t\t\t\t\tnode_val[k][thing] = {\"location\": loc}\n\n\t\tif rulebooks:\n\t\t\tfor graph, vals in graph_val.items():\n\t\t\t\ttry:\n\t\t\t\t\tvals[\"units\"] = (\n\t\t\t\t\t\tself._unitness_cache.dict_cache.get_keyframe(\n\t\t\t\t\t\t\tgraph, branch, turn, tick\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\texcept KeyError:\n\t\t\t\t\tpass\n\t\t\t\ttry:\n\t\t\t\t\tvals[\"character_rulebook\"] = (\n\t\t\t\t\t\tself._characters_rulebooks_cache.retrieve(\n\t\t\t\t\t\t\tgraph, branch, turn, tick\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\texcept KeyError:\n\t\t\t\t\tpass\n\t\t\t\ttry:\n\t\t\t\t\tvals[\"unit_rulebook\"] = (\n\t\t\t\t\t\tself._units_rulebooks_cache.retrieve(\n\t\t\t\t\t\t\tgraph, branch, turn, tick\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\texcept KeyError:\n\t\t\t\t\tpass\n\t\t\t\ttry:\n\t\t\t\t\tvals[\"character_thing_rulebook\"] = (\n\t\t\t\t\t\tself._characters_things_rulebooks_cache.retrieve(\n\t\t\t\t\t\t\tgraph, branch, turn, tick\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\texcept KeyError:\n\t\t\t\t\tpass\n\t\t\t\ttry:\n\t\t\t\t\tvals[\"character_place_rulebook\"] = (\n\t\t\t\t\t\tself._characters_places_rulebooks_cache.retrieve(\n\t\t\t\t\t\t\tgraph, branch, turn, tick\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\texcept KeyError:\n\t\t\t\t\tpass\n\t\t\t\ttry:\n\t\t\t\t\tvals[\"character_portal_rulebook\"] = (\n\t\t\t\t\t\tself._characters_portals_rulebooks_cache.retrieve(\n\t\t\t\t\t\t\tgraph, branch, turn, tick\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\texcept KeyError:\n\t\t\t\t\tpass\n\t\t\t\tif graph in nodes and nodes[graph]:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tnode_rb_kf = self._nodes_rulebooks_cache.get_keyframe(\n\t\t\t\t\t\t\tgraph, branch, turn, tick\n\t\t\t\t\t\t)\n\t\t\t\t\texcept KeyframeError:\n\t\t\t\t\t\tnode_rb_kf = {}\n\t\t\t\t\tfor node in nodes[graph]:\n\t\t\t\t\t\tnode_val.setdefault(graph, {}).setdefault(node, {})[\n\t\t\t\t\t\t\t\"rulebook\"\n\t\t\t\t\t\t] = node_rb_kf.get(node, (graph, node))\n\t\t\t\tif graph in kf[\"edges\"] and kf[\"edges\"][graph]:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tport_rb_kf = (\n\t\t\t\t\t\t\tself._portals_rulebooks_cache.get_keyframe(\n\t\t\t\t\t\t\t\tgraph, branch, turn, tick\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\texcept KeyframeError:\n\t\t\t\t\t\tport_rb_kf = {}\n\t\t\t\t\tif graph not in edge_val:\n\t\t\t\t\t\tedge_val[graph] = {}\n\t\t\t\t\tkf_graph_edge_val = edge_val[graph]\n\t\t\t\t\tfor orig in edges[graph]:\n\t\t\t\t\t\tif orig not in kf_graph_edge_val:\n\t\t\t\t\t\t\tkf_graph_edge_val[orig] = {}\n\t\t\t\t\t\tkf_graph_orig_edge_val = kf_graph_edge_val[orig]\n\t\t\t\t\t\tif orig not in port_rb_kf:\n\t\t\t\t\t\t\tport_rb_kf[orig] = {}\n\t\t\t\t\t\tport_rb_kf_dests = port_rb_kf[orig]\n\t\t\t\t\t\tfor dest in edges[graph][orig]:\n\t\t\t\t\t\t\tif dest not in kf_graph_orig_edge_val:\n\t\t\t\t\t\t\t\tkf_graph_orig_edge_val[dest] = {}\n\t\t\t\t\t\t\tkf_graph_dest_edge_val = kf_graph_orig_edge_val[\n\t\t\t\t\t\t\t\tdest\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\trulebook = port_rb_kf_dests.get(\n\t\t\t\t\t\t\t\tdest, (graph, orig, dest)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tkf_graph_dest_edge_val[\"rulebook\"] = rulebook\n\t\tkf[\"universal\"] = self._universal_cache.get_keyframe(\n\t\t\tbranch, turn, tick\n\t\t)\n\t\tkf[\"triggers\"] = self._triggers_cache.get_keyframe(branch, turn, tick)\n\t\tkf[\"prereqs\"] = self._prereqs_cache.get_keyframe(branch, turn, tick)\n\t\tkf[\"actions\"] = self._actions_cache.get_keyframe(branch, turn, tick)\n\t\tkf[\"neighborhood\"] = self._neighborhoods_cache.get_keyframe(\n\t\t\tbranch, turn, tick\n\t\t)\n\t\tkf[\"big\"] = self._rule_bigness_cache.get_keyframe(branch, turn, tick)\n\t\tkf[\"rulebook\"] = self._rulebooks_cache.get_keyframe(branch, turn, tick)\n\t\treturn kf\n\n\tdef _load_keyframe_times(self):\n\t\tkeyframes_dict = self._keyframes_dict\n\t\tkeyframes_times = self._keyframes_times\n\t\tq = self.query\n\t\tfor branch, turn, tick in q.keyframes_dump():\n\t\t\tif branch not in keyframes_dict:\n\t\t\t\tkeyframes_dict[branch] = {turn: {tick}}\n\t\t\telse:\n\t\t\t\tkeyframes_dict_branch = keyframes_dict[branch]\n\t\t\t\tif turn not in keyframes_dict_branch:\n\t\t\t\t\tkeyframes_dict_branch[turn] = {tick}\n\t\t\t\telse:\n\t\t\t\t\tkeyframes_dict_branch[turn].add(tick)\n\t\t\tkeyframes_times.add((branch, turn, tick))\n\n\tdef _load_plans(self) -> None:\n\t\tq = self.query\n\n\t\tlast_plan = -1\n\t\tplans = self._plans\n\t\tbranches_plans = self._branches_plans\n\t\tfor plan, branch, turn, tick in q.plans_dump():\n\t\t\tplans[plan] = branch, turn, tick\n\t\t\tbranches_plans[branch].add(plan)\n\t\t\tif plan > last_plan:\n\t\t\t\tlast_plan = plan\n\t\tself._last_plan = last_plan\n\t\tplan_ticks = self._plan_ticks\n\t\ttime_plan = self._time_plan\n\t\tturn_end_plan = self._turn_end_plan\n\t\tfor plan, turn, tick in q.plan_ticks_dump():\n\t\t\tplan_ticks[plan][turn].add(tick)\n\t\t\tbranch = plans[plan][0]\n\t\t\tturn_end_plan[branch, turn] = max(\n\t\t\t\t(turn_end_plan[branch, turn], tick)\n\t\t\t)\n\t\t\ttime_plan[branch, turn, tick] = plan\n\n\tdef _load_rules_handled(self):\n\t\tq = self.query\n\t\tstore_crh = self._character_rules_handled_cache.store\n\t\tfor row in q.character_rules_handled_dump():\n\t\t\tstore_crh(*row, loading=True)\n\t\tstore_arh = self._unit_rules_handled_cache.store\n\t\tfor row in q.unit_rules_handled_dump():\n\t\t\tstore_arh(*row, loading=True)\n\t\tstore_ctrh = self._character_thing_rules_handled_cache.store\n\t\tfor row in q.character_thing_rules_handled_dump():\n\t\t\tstore_ctrh(*row, loading=True)\n\t\tstore_cprh = self._character_place_rules_handled_cache.store\n\t\tfor row in q.character_place_rules_handled_dump():\n\t\t\tstore_cprh(*row, loading=True)\n\t\tstore_cporh = self._character_portal_rules_handled_cache.store\n\t\tfor row in q.character_portal_rules_handled_dump():\n\t\t\tstore_cporh(*row, loading=True)\n\t\tstore_cnrh = self._node_rules_handled_cache.store\n\t\tfor row in q.node_rules_handled_dump():\n\t\t\tstore_cnrh(*row, loading=True)\n\t\tstore_porh = self._portal_rules_handled_cache.store\n\t\tfor row in q.portal_rules_handled_dump():\n\t\t\tstore_porh(*row, loading=True)\n\n\tdef _upd_branch_parentage(self, parent: Branch, child: Branch) -> None:\n\t\tself._childbranch[parent].add(child)\n\t\tself._branch_parents[child].add(parent)\n\t\twhile (parent := self.branch_parent(parent)) is not None:\n\t\t\tself._branch_parents[child].add(parent)\n\n\tdef _alias_kf(\n\t\tself, branch_from: Branch, branch_to: Branch, turn: Turn, tick: Tick\n\t):\n\t\t\"\"\"Copy a keyframe from one branch to another\n\n\t\tThis aliases the data, rather than really copying. Keyframes don't\n\t\tchange, so it should be fine.\n\n\t\tThis does *not* save a new keyframe to disk.\n\n\t\t\"\"\"\n\t\ttry:\n\t\t\tgraph_keyframe = self._graph_cache.get_keyframe(\n\t\t\t\tbranch_from, turn, tick, copy=False\n\t\t\t)\n\t\texcept KeyframeError:\n\t\t\tgraph_keyframe = {}\n\t\t\tfor graph in self._graph_cache.iter_entities(\n\t\t\t\tbranch_from, turn, tick\n\t\t\t):\n\t\t\t\ttry:\n\t\t\t\t\tgraph_keyframe[graph] = self._graph_cache.retrieve(\n\t\t\t\t\t\tgraph, branch_from, turn, tick\n\t\t\t\t\t)\n\t\t\t\texcept KeyError:\n\t\t\t\t\tpass\n\t\tself._graph_cache.set_keyframe(\n\t\t\tbranch_to,\n\t\t\tturn,\n\t\t\ttick,\n\t\t\tgraph_keyframe,\n\t\t)\n\t\tfor cache in (\n\t\t\tself._graph_val_cache,\n\t\t\tself._nodes_cache,\n\t\t\tself._node_val_cache,\n\t\t\tself._edges_cache,\n\t\t\tself._edge_val_cache,\n\t\t\tself._things_cache,\n\t\t\tself._node_contents_cache,\n\t\t):\n\t\t\tcache.alias_keyframe(\n\t\t\t\tbranch_from,\n\t\t\t\tbranch_to,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t\t{},\n\t\t\t)\n\t\tfor cache in (\n\t\t\tself._universal_cache,\n\t\t\tself._triggers_cache,\n\t\t\tself._prereqs_cache,\n\t\t\tself._actions_cache,\n\t\t\tself._rulebooks_cache,\n\t\t\tself._unitness_cache,\n\t\t\tself._unitness_cache.leader_cache,\n\t\t\tself._unitness_cache.dict_cache,\n\t\t\tself._characters_rulebooks_cache,\n\t\t\tself._units_rulebooks_cache,\n\t\t\tself._characters_things_rulebooks_cache,\n\t\t\tself._characters_places_rulebooks_cache,\n\t\t\tself._characters_portals_rulebooks_cache,\n\t\t\tself._nodes_rulebooks_cache,\n\t\t\tself._portals_rulebooks_cache,\n\t\t\tself._neighborhoods_cache,\n\t\t\tself._rule_bigness_cache,\n\t\t):\n\t\t\tcache.alias_keyframe(branch_from, branch_to, turn, tick)\n\t\tself._mark_keyframe_loaded(branch_to, turn, tick)\n\n\tdef _mark_keyframe_loaded(self, branch, turn, tick):\n\t\tself._keyframes_times.add((branch, turn, tick))\n\t\tself._keyframes_loaded.add((branch, turn, tick))\n\t\tif branch in self._keyframes_dict:\n\t\t\tkdb = self._keyframes_dict[branch]\n\t\t\tif turn in kdb:\n\t\t\t\tkdb[turn].add(tick)\n\t\t\telse:\n\t\t\t\tkdb[turn] = {tick}\n\t\telse:\n\t\t\tself._keyframes_dict[branch] = {turn: {tick}}\n\n\t@staticmethod\n\tdef _apply_unit_delta(\n\t\tchar: CharName,\n\t\tchar_unit_kf: dict[CharName, dict[NodeName, bool]],\n\t\tuser_set_kf: dict[CharName, dict[NodeName, frozenset[CharName]]],\n\t\tdelta: dict[CharName, DeltaDict],\n\t) -> None:\n\t\tsinglechar = frozenset([char])\n\t\tfor graf, stuff in delta.items():\n\t\t\tif stuff is ...:\n\t\t\t\tif graf in char_unit_kf:\n\t\t\t\t\tdel char_unit_kf[graf]\n\t\t\t\tif char in user_set_kf:\n\t\t\t\t\tsinglegraf = frozenset([graf])\n\t\t\t\t\tfor garph in user_set_kf[char]:\n\t\t\t\t\t\tuser_set_kf[char][garph] -= singlegraf\n\t\t\telif \"nodes\" in stuff:\n\t\t\t\tfor node, ex in stuff[\"nodes\"].items():\n\t\t\t\t\tif ex:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tif graf in char_unit_kf and node in char_unit_kf[graf]:\n\t\t\t\t\t\tdel char_unit_kf[graf][node]\n\t\t\t\t\t\tif not char_unit_kf[graf]:\n\t\t\t\t\t\t\tdel char_unit_kf[graf]\n\t\t\t\t\tif char in user_set_kf:\n\t\t\t\t\t\tsinglegraf = frozenset([graf])\n\t\t\t\t\t\tfor graaf in user_set_kf[char]:\n\t\t\t\t\t\t\tuser_set_kf[char][graaf] -= singlegraf\n\t\tif char not in delta or \"units\" not in delta[char]:\n\t\t\treturn\n\t\tfor graf, units in delta[char][\"units\"].items():\n\t\t\tfor unit, ex in units.items():\n\t\t\t\tif ex:\n\t\t\t\t\tif graf in char_unit_kf:\n\t\t\t\t\t\tchar_unit_kf[graf][unit] = True\n\t\t\t\t\telse:\n\t\t\t\t\t\tchar_unit_kf[graf] = {unit: True}\n\t\t\t\t\tif graf in user_set_kf:\n\t\t\t\t\t\tif unit in user_set_kf[graf]:\n\t\t\t\t\t\t\tuser_set_kf[graf][unit] |= singlechar\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tuser_set_kf[graf][unit] = singlechar\n\t\t\t\t\telse:\n\t\t\t\t\t\tuser_set_kf[graf] = {unit: singlechar}\n\t\t\t\telse:\n\t\t\t\t\tif graf in char_unit_kf and unit in char_unit_kf[graf]:\n\t\t\t\t\t\tdel char_unit_kf[graf][unit]\n\t\t\t\t\t\tif not char_unit_kf[graf]:\n\t\t\t\t\t\t\tdel char_unit_kf[graf]\n\t\t\t\t\tif graf in user_set_kf:\n\t\t\t\t\t\tif unit in user_set_kf[graf]:\n\t\t\t\t\t\t\tuser_set_kf[graf][unit] -= singlechar\n\t\t\t\t\t\t\tif not user_set_kf[graf][unit]:\n\t\t\t\t\t\t\t\tdel user_set_kf[graf][unit]\n\t\t\t\t\t\t\tif not user_set_kf[graf]:\n\t\t\t\t\t\t\t\tdel user_set_kf[graf]\n\n\t@staticmethod\n\tdef _apply_graph_val_delta(\n\t\tgraph: CharName,\n\t\tgraph_val_keyframe: dict,\n\t\tcharacter_rulebook_keyframe: dict,\n\t\tunit_rulebook_keyframe: dict,\n\t\tcharacter_thing_rulebook_keyframe: dict,\n\t\tcharacter_place_rulebook_keyframe: dict,\n\t\tcharacter_portal_rulebook_keyframe: dict,\n\t\tgraph_val_delta: dict,\n\t):\n\t\tfor key, kf in [\n\t\t\t(\"character_rulebook\", character_rulebook_keyframe),\n\t\t\t(\"unit_rulebook\", unit_rulebook_keyframe),\n\t\t\t(\"character_thing_rulebook\", character_thing_rulebook_keyframe),\n\t\t\t(\"character_place_rulebook\", character_place_rulebook_keyframe),\n\t\t\t(\"character_portal_rulebook\", character_portal_rulebook_keyframe),\n\t\t]:\n\t\t\tif key in graph_val_delta:\n\t\t\t\tkf[graph] = graph_val_delta.pop(key)\n\t\t\telif graph not in kf:\n\t\t\t\tkf[graph] = (key, graph)\n\t\tfor k in graph_val_delta.keys() - {\n\t\t\t\"nodes\",\n\t\t\t\"node_val\",\n\t\t\t\"edges\",\n\t\t\t\"edge_val\",\n\t\t\t\"units\",\n\t\t\t\"character_rulebook\",\n\t\t\t\"unit_rulebook\",\n\t\t\t\"character_thing_rulebook\",\n\t\t\t\"character_place_rulebook\",\n\t\t\t\"character_portal_rulebook\",\n\t\t}:\n\t\t\tv = graph_val_delta[k]\n\t\t\tif v is ...:\n\t\t\t\tif k in graph_val_keyframe:\n\t\t\t\t\tdel graph_val_keyframe[k]\n\t\t\telse:\n\t\t\t\tgraph_val_keyframe[k] = v\n\n\t@staticmethod\n\tdef _apply_node_delta(\n\t\tcharname: CharName,\n\t\tnode_val_keyframe: dict,\n\t\tnodes_keyframe: dict,\n\t\tnode_rulebook_keyframe: dict,\n\t\tthing_location_keyframe: dict,\n\t\tnode_contents_keyframe: dict,\n\t\tnode_val_delta: dict,\n\t\tnodes_delta: dict,\n\t) -> None:\n\t\tfor node, ex in nodes_delta.items():\n\t\t\tif ex:\n\t\t\t\tnodes_keyframe[node] = True\n\t\t\t\tif node not in node_val_keyframe:\n\t\t\t\t\tnode_val_keyframe[node] = {}\n\t\t\t\t\tnode_rulebook_keyframe[node] = (charname, node)\n\t\t\telse:\n\t\t\t\tif node in nodes_keyframe:\n\t\t\t\t\tdel nodes_keyframe[node]\n\t\t\t\tif node in node_val_keyframe:\n\t\t\t\t\tif (\n\t\t\t\t\t\t\"location\" in node_val_keyframe[node]\n\t\t\t\t\t\tand node_val_keyframe[node][\"location\"]\n\t\t\t\t\t\tin node_contents_keyframe\n\t\t\t\t\t):\n\t\t\t\t\t\tnode_contents_keyframe[\n\t\t\t\t\t\t\tnode_val_keyframe[node][\"location\"]\n\t\t\t\t\t\t].remove(node)\n\t\t\t\t\tdel node_val_keyframe[node]\n\t\t\t\tif node in thing_location_keyframe:\n\t\t\t\t\tdel thing_location_keyframe[node]\n\t\t\t\tif node in node_contents_keyframe:\n\t\t\t\t\tfor contained in node_contents_keyframe[node]:\n\t\t\t\t\t\tdel nodes_keyframe[contained]\n\t\t\t\t\tdel node_contents_keyframe[node]\n\t\tfor node, upd in node_val_delta.items():\n\t\t\tif node in nodes_delta and not nodes_delta[node]:\n\t\t\t\tcontinue\n\t\t\tupd = upd.copy()\n\t\t\tif \"location\" in upd:\n\t\t\t\tloc = upd.pop(\"location\")\n\t\t\t\tthing_location_keyframe[node] = loc\n\t\t\t\tif loc in node_contents_keyframe:\n\t\t\t\t\tif loc is ...:\n\t\t\t\t\t\tnode_contents_keyframe[loc].remove(node)\n\t\t\t\t\telse:\n\t\t\t\t\t\tnode_contents_keyframe[loc].add(node)\n\t\t\t\telif loc is not ...:\n\t\t\t\t\tnode_contents_keyframe[loc] = {node}\n\t\t\tif \"rulebook\" in upd:\n\t\t\t\tnode_rulebook_keyframe[node] = upd.pop(\"rulebook\")\n\t\t\telif (\n\t\t\t\tnode in node_val_keyframe\n\t\t\t\tand \"rulebook\" in node_val_keyframe[node]\n\t\t\t):\n\t\t\t\tnode_rulebook_keyframe[node] = node_val_keyframe[node].pop(\n\t\t\t\t\t\"rulebook\"\n\t\t\t\t)\n\t\t\telif node in nodes_keyframe:\n\t\t\t\tassert node in node_rulebook_keyframe, (\n\t\t\t\t\tf\"No rulebook for {node}\"\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\tnode_rulebook_keyframe[node] = (charname, node)\n\t\t\tif upd and node in node_val_keyframe:\n\t\t\t\tkv = node_val_keyframe[node]\n\t\t\t\tfor key, value in upd.items():\n\t\t\t\t\tif value is ...:\n\t\t\t\t\t\tif key in kv:\n\t\t\t\t\t\t\tdel kv[key]\n\t\t\t\t\telse:\n\t\t\t\t\t\tkv[key] = value\n\n\t@staticmethod\n\tdef _apply_edge_delta(\n\t\tcharname: Key,\n\t\tedge_val_keyframe: dict,\n\t\tedges_keyframe: dict,\n\t\tportal_rulebook_keyframe: dict,\n\t\tedge_val_delta: dict,\n\t\tedges_delta: dict,\n\t) -> None:\n\t\tfor orig, dests in edges_delta.items():\n\t\t\tfor dest, ex in dests.items():\n\t\t\t\tif ex:\n\t\t\t\t\tedge_val_keyframe.setdefault(orig, {}).setdefault(dest, {})\n\t\t\t\t\tedges_keyframe.setdefault(orig, {})[dest] = True\n\t\t\t\t\tportal_rulebook_keyframe.setdefault(orig, {})[dest] = (\n\t\t\t\t\t\tcharname,\n\t\t\t\t\t\torig,\n\t\t\t\t\t\tdest,\n\t\t\t\t\t)\n\t\t\t\telif orig in edges_keyframe and dest in edges_keyframe[orig]:\n\t\t\t\t\tdel edges_keyframe[orig][dest]\n\t\t\t\t\tif not edges_keyframe[orig]:\n\t\t\t\t\t\tdel edges_keyframe[orig]\n\t\t\t\t\tif orig in edge_val_keyframe:\n\t\t\t\t\t\tif dest in edge_val_keyframe[orig]:\n\t\t\t\t\t\t\tdel edge_val_keyframe[orig][dest]\n\t\t\t\t\t\tif not edge_val_keyframe[orig]:\n\t\t\t\t\t\t\tdel edge_val_keyframe[orig]\n\t\tfor orig, dests in edge_val_delta.items():\n\t\t\tfor dest, upd in dests.items():\n\t\t\t\tif (\n\t\t\t\t\torig in edges_delta\n\t\t\t\t\tand dest in edges_delta[orig]\n\t\t\t\t\tand not edges_delta[orig][dest]\n\t\t\t\t):\n\t\t\t\t\tcontinue\n\t\t\t\tupd = upd.copy()\n\t\t\t\tif \"rulebook\" in upd:\n\t\t\t\t\tportal_rulebook_keyframe.setdefault(orig, {})[dest] = (\n\t\t\t\t\t\tupd.pop(\"rulebook\")\n\t\t\t\t\t)\n\t\t\t\telif (\n\t\t\t\t\torig in edge_val_keyframe\n\t\t\t\t\tand dest in edge_val_keyframe[orig]\n\t\t\t\t\tand \"rulebook\" in edge_val_keyframe[orig][dest]\n\t\t\t\t):\n\t\t\t\t\tportal_rulebook_keyframe.setdefault(orig, {})[dest] = (\n\t\t\t\t\t\tedge_val_keyframe[orig][dest].pop(\"rulebook\")\n\t\t\t\t\t)\n\t\t\t\telse:\n\t\t\t\t\tassert (\n\t\t\t\t\t\torig in portal_rulebook_keyframe\n\t\t\t\t\t\tand dest in portal_rulebook_keyframe[orig]\n\t\t\t\t\t), f\"No rulebook for {orig}->{dest}\"\n\t\t\t\tif upd:\n\t\t\t\t\tkv = edge_val_keyframe.setdefault(orig, {}).setdefault(\n\t\t\t\t\t\tdest, {}\n\t\t\t\t\t)\n\t\t\t\t\tfor key, value in upd.items():\n\t\t\t\t\t\tif value is ...:\n\t\t\t\t\t\t\tif key in kv:\n\t\t\t\t\t\t\t\tdel kv[key]\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tkv[key] = value\n\t\tfor orig, dests in list(edges_keyframe.items()):\n\t\t\tif not dests:\n\t\t\t\tdel edges_keyframe[orig]\n\t\t\t\tif orig in edge_val_keyframe:\n\t\t\t\t\tdel edge_val_keyframe[orig]\n\n\tdef _snap_keyframe_from_delta(\n\t\tself,\n\t\tthen: Time,\n\t\tnow: Time,\n\t\tdelta: DeltaDict,\n\t) -> None:\n\t\tif then[0] != now[0]:\n\t\t\traise RuntimeError(\n\t\t\t\t\"Tried to snap a keyframe from delta between branches\"\n\t\t\t)\n\t\tif then == now:\n\t\t\tself.debug(\"Redundant keyframe snap at %s, %d, %d\", *now)\n\t\t\treturn\n\t\tif not self._time_is_loaded_between(*then, *now[1:]):\n\t\t\traise RuntimeError(\n\t\t\t\t\"Tried to snap a delta of time not loaded\", *then, *now[1:]\n\t\t\t)\n\t\tself.debug(\n\t\t\t\"Snapping keyframe from delta in branch %s between times \"\n\t\t\t\"%d, %d and %d, %d\",\n\t\t\t*then,\n\t\t\t*now[1:],\n\t\t)\n\t\tkeyframe = self._get_keyframe(*then, rulebooks=False)\n\t\tgraph_val_keyframe: GraphValKeyframe = keyframe[\"graph_val\"]\n\t\tnodes_keyframe: GraphNodesKeyframe = keyframe[\"nodes\"]\n\t\tnode_val_keyframe: GraphNodeValKeyframe = keyframe[\"node_val\"]\n\t\tedges_keyframe: GraphEdgesKeyframe = keyframe[\"edges\"]\n\t\tedge_val_keyframe: GraphEdgeValKeyframe = keyframe[\"edge_val\"]\n\t\tuniversal_keyframe = keyframe[\"universal\"]\n\t\trulebooks_keyframe = keyframe[\"rulebook\"]\n\t\ttriggers_keyframe = keyframe[\"triggers\"]\n\t\tprereqs_keyframe = keyframe[\"prereqs\"]\n\t\tactions_keyframe = keyframe[\"actions\"]\n\t\tneighborhoods_keyframe = keyframe[\"neighborhood\"]\n\t\tbigs = keyframe[\"big\"]\n\t\tcharacters_rulebooks_keyframe = (\n\t\t\tself._characters_rulebooks_cache.get_keyframe(*then)\n\t\t)\n\t\tunits_rulebooks_keyframe = self._units_rulebooks_cache.get_keyframe(\n\t\t\t*then\n\t\t)\n\t\tcharacters_things_rulebooks_keyframe = (\n\t\t\tself._characters_things_rulebooks_cache.get_keyframe(*then)\n\t\t)\n\t\tcharacters_places_rulebooks_keyframe = (\n\t\t\tself._characters_places_rulebooks_cache.get_keyframe(*then)\n\t\t)\n\t\tcharacters_portals_rulebooks_keyframe = (\n\t\t\tself._characters_portals_rulebooks_cache.get_keyframe(*then)\n\t\t)\n\t\tfor k, v in delta.get(\"universal\", {}).items():\n\t\t\tif v is ...:\n\t\t\t\tif k in universal_keyframe:\n\t\t\t\t\tdel universal_keyframe[k]\n\t\t\telse:\n\t\t\t\tuniversal_keyframe[k] = v\n\t\tif \"rulebooks\" in delta:\n\t\t\trulebooks_keyframe.update(delta[\"rulebooks\"])\n\t\tfor rule, funcs in delta.get(\"rules\", {}).items():\n\t\t\ttriggers_keyframe[rule] = funcs.get(\n\t\t\t\t\"triggers\", triggers_keyframe.get(rule, [])\n\t\t\t)\n\t\t\tprereqs_keyframe[rule] = funcs.get(\n\t\t\t\t\"prereqs\", prereqs_keyframe.get(rule, [])\n\t\t\t)\n\t\t\tactions_keyframe[rule] = funcs.get(\n\t\t\t\t\"actions\", actions_keyframe.get(rule, [])\n\t\t\t)\n\t\t\tif \"neighborhood\" in funcs:\n\t\t\t\tneighborhoods_keyframe[rule] = funcs[\"neighborhood\"]\n\t\t\tif \"big\" in funcs:\n\t\t\t\tbigs[rule] = funcs[\"big\"]\n\t\tthings_keyframe = {}\n\t\tnodes_rulebooks_keyframe = {}\n\t\tportals_rulebooks_keyframe = {}\n\t\tunits_keyframe = {}\n\t\tfor k, vs in graph_val_keyframe.items():\n\t\t\tif \"units\" in vs:\n\t\t\t\tunits_keyframe[k] = vs.pop(\"units\")\n\t\tuser_set_keyframe = {}\n\t\tgraphs: set[CharName] = (\n\t\t\tset(self._graph_cache.iter_keys(*then)).union(delta.keys())\n\t\t\t- self.illegal_graph_names\n\t\t)\n\t\tfor graph in graphs:\n\t\t\ttry:\n\t\t\t\tuser_set_keyframe[graph] = (\n\t\t\t\t\tself._unitness_cache.leader_cache.get_keyframe(\n\t\t\t\t\t\tgraph, *then, copy=True\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\texcept KeyframeError:\n\t\t\t\tuser_set_keyframe[graph] = {}\n\t\tfor graph in graphs:\n\t\t\tdelt = delta.get(graph, {})\n\t\t\tif delt is ...:\n\t\t\t\tcontinue\n\t\t\ttry:\n\t\t\t\tnoderbs = nodes_rulebooks_keyframe[graph] = (\n\t\t\t\t\tself._nodes_rulebooks_cache.get_keyframe(graph, *then)\n\t\t\t\t)\n\t\t\texcept KeyframeError:\n\t\t\t\tnoderbs = nodes_rulebooks_keyframe[graph] = {}\n\t\t\ttry:\n\t\t\t\tportrbs = portals_rulebooks_keyframe[graph] = (\n\t\t\t\t\tself._portals_rulebooks_cache.get_keyframe(graph, *then)\n\t\t\t\t)\n\t\t\texcept KeyframeError:\n\t\t\t\tportrbs = portals_rulebooks_keyframe[graph] = {}\n\t\t\ttry:\n\t\t\t\tcharunit = units_keyframe[graph] = (\n\t\t\t\t\tself._unitness_cache.dict_cache.get_keyframe(\n\t\t\t\t\t\tgraph, *then, copy=True\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\texcept KeyframeError:\n\t\t\t\tcharunit = units_keyframe[graph] = {}\n\t\t\ttry:\n\t\t\t\tlocs = things_keyframe[graph] = (\n\t\t\t\t\tself._things_cache.get_keyframe(graph, *then, copy=True)\n\t\t\t\t)\n\t\t\texcept KeyframeError:\n\t\t\t\tlocs = things_keyframe[graph] = {}\n\t\t\ttry:\n\t\t\t\tconts = {\n\t\t\t\t\tkey: set(value)\n\t\t\t\t\tfor (key, value) in self._node_contents_cache.get_keyframe(\n\t\t\t\t\t\tgraph, *then, copy=True\n\t\t\t\t\t).items()\n\t\t\t\t}\n\t\t\texcept KeyframeError:\n\t\t\t\tconts = {}\n\t\t\tif graph not in node_val_keyframe:\n\t\t\t\tnode_val_keyframe[graph] = {}\n\t\t\tif graph not in nodes_keyframe:\n\t\t\t\tnodes_keyframe[graph] = {}\n\t\t\tself._apply_unit_delta(\n\t\t\t\tgraph,\n\t\t\t\tcharunit,\n\t\t\t\tuser_set_keyframe,\n\t\t\t\tdelta,\n\t\t\t)\n\t\t\tself._apply_node_delta(\n\t\t\t\tgraph,\n\t\t\t\tnode_val_keyframe.setdefault(graph, {}),\n\t\t\t\tnodes_keyframe.setdefault(graph, {}),\n\t\t\t\tnoderbs,\n\t\t\t\tlocs,\n\t\t\t\tconts,\n\t\t\t\tdelt.get(\"node_val\", {}),\n\t\t\t\tdelt.get(\"nodes\", {}),\n\t\t\t)\n\t\t\tself._apply_edge_delta(\n\t\t\t\tgraph,\n\t\t\t\tedge_val_keyframe.setdefault(graph, {}),\n\t\t\t\tedges_keyframe.setdefault(graph, {}),\n\t\t\t\tportrbs,\n\t\t\t\tdelt.get(\"edge_val\", {}),\n\t\t\t\tdelt.get(\"edges\", {}),\n\t\t\t)\n\t\t\tself._apply_graph_val_delta(\n\t\t\t\tgraph,\n\t\t\t\tgraph_val_keyframe.setdefault(graph, {}),\n\t\t\t\tcharacters_rulebooks_keyframe,\n\t\t\t\tunits_rulebooks_keyframe,\n\t\t\t\tcharacters_things_rulebooks_keyframe,\n\t\t\t\tcharacters_places_rulebooks_keyframe,\n\t\t\t\tcharacters_portals_rulebooks_keyframe,\n\t\t\t\tdelt,\n\t\t\t)\n\t\t\tif graph not in edge_val_keyframe:\n\t\t\t\tedge_val_keyframe[graph] = {}\n\t\t\tif graph not in edges_keyframe:\n\t\t\t\tedges_keyframe[graph] = {}\n\t\t\tself._unitness_cache.set_keyframe(graph, *now, charunit)\n\t\t\tself._things_cache.set_keyframe(graph, *now, locs)\n\t\t\tself._node_contents_cache.set_keyframe(\n\t\t\t\tgraph,\n\t\t\t\t*now,\n\t\t\t\t{key: frozenset(value) for (key, value) in conts.items()},\n\t\t\t)\n\t\t\tself._nodes_rulebooks_cache.set_keyframe(graph, *now, noderbs)\n\t\t\tself._portals_rulebooks_cache.set_keyframe(graph, *now, portrbs)\n\t\t\tself._nodes_cache.set_keyframe(graph, *now, nodes_keyframe[graph])\n\t\t\tself._node_val_cache.set_keyframe(\n\t\t\t\tgraph, *now, node_val_keyframe[graph]\n\t\t\t)\n\t\t\tself._edges_cache.set_keyframe(graph, *now, edges_keyframe[graph])\n\t\t\tself._edge_val_cache.set_keyframe(\n\t\t\t\tgraph, *now, edge_val_keyframe[graph]\n\t\t\t)\n\t\t\tself._graph_val_cache.set_keyframe(\n\t\t\t\tgraph, *now, graph_val_keyframe[graph]\n\t\t\t)\n\t\tfor char, kf in user_set_keyframe.items():\n\t\t\tself._unitness_cache.leader_cache.set_keyframe(char, *now, kf)\n\t\tself._characters_rulebooks_cache.set_keyframe(\n\t\t\t*now, characters_rulebooks_keyframe\n\t\t)\n\t\tself._units_rulebooks_cache.set_keyframe(\n\t\t\t*now, units_rulebooks_keyframe\n\t\t)\n\t\tself._characters_things_rulebooks_cache.set_keyframe(\n\t\t\t*now, characters_things_rulebooks_keyframe\n\t\t)\n\t\tself._characters_places_rulebooks_cache.set_keyframe(\n\t\t\t*now, characters_places_rulebooks_keyframe\n\t\t)\n\t\tself._characters_portals_rulebooks_cache.set_keyframe(\n\t\t\t*now, characters_portals_rulebooks_keyframe\n\t\t)\n\t\tself._universal_cache.set_keyframe(*now, universal_keyframe)\n\t\tself._triggers_cache.set_keyframe(*now, triggers_keyframe)\n\t\tself._prereqs_cache.set_keyframe(*now, prereqs_keyframe)\n\t\tself._actions_cache.set_keyframe(*now, actions_keyframe)\n\t\tself._neighborhoods_cache.set_keyframe(*now, neighborhoods_keyframe)\n\t\tself._rule_bigness_cache.set_keyframe(*now, bigs)\n\t\tself._rulebooks_cache.set_keyframe(*now, rulebooks_keyframe)\n\t\tself.query.keyframe_extension_insert(\n\t\t\t*now,\n\t\t\tuniversal_keyframe,\n\t\t\t{\n\t\t\t\t\"triggers\": triggers_keyframe,\n\t\t\t\t\"prereqs\": prereqs_keyframe,\n\t\t\t\t\"actions\": actions_keyframe,\n\t\t\t\t\"neighborhood\": neighborhoods_keyframe,\n\t\t\t\t\"big\": bigs,\n\t\t\t},\n\t\t\trulebooks_keyframe,\n\t\t)\n\t\tkfd = self._keyframes_dict\n\t\tkfs = self._keyframes_times\n\t\tkfsl = self._keyframes_loaded\n\t\tkfs.add(now)\n\t\tkfsl.add(now)\n\t\tself.query.keyframe_insert(*now)\n\t\tbranch, turn, tick = now\n\t\tif branch not in kfd:\n\t\t\tkfd[branch] = {\n\t\t\t\tturn: {\n\t\t\t\t\ttick,\n\t\t\t\t}\n\t\t\t}\n\t\telif turn not in kfd[branch]:\n\t\t\tkfd[branch][turn] = {\n\t\t\t\ttick,\n\t\t\t}\n\t\telse:\n\t\t\tkfd[branch][turn].add(tick)\n\t\tinskf = self.query.keyframe_graph_insert\n\t\tgraphs_keyframe = {g: \"DiGraph\" for g in graph_val_keyframe}\n\t\tfor graph in graphs_keyframe.keys() - self.illegal_graph_names:\n\t\t\tdeltg = delta.get(graph, {})\n\t\t\tif deltg is ...:\n\t\t\t\tdel graphs_keyframe[graph]\n\t\t\t\tcontinue\n\t\t\tcombined_node_val_keyframe = {\n\t\t\t\tnode: val.copy()\n\t\t\t\tfor (node, val) in node_val_keyframe.get(graph, {}).items()\n\t\t\t}\n\t\t\tfor node, loc in things_keyframe.get(graph, {}).items():\n\t\t\t\tif loc is ...:\n\t\t\t\t\tcontinue\n\t\t\t\tif node in combined_node_val_keyframe:\n\t\t\t\t\tcombined_node_val_keyframe[node][\"location\"] = loc\n\t\t\t\telse:\n\t\t\t\t\tcombined_node_val_keyframe[node] = {\"location\": loc}\n\t\t\tfor node, rb in nodes_rulebooks_keyframe.get(graph, {}).items():\n\t\t\t\tif node in combined_node_val_keyframe:\n\t\t\t\t\tcombined_node_val_keyframe[node][\"rulebook\"] = rb\n\t\t\t\telif node in nodes_keyframe[graph]:\n\t\t\t\t\tcombined_node_val_keyframe[node] = {\"rulebook\": rb}\n\t\t\tfor node, ex in nodes_keyframe.get(graph, {}).items():\n\t\t\t\tif ex and node not in combined_node_val_keyframe:\n\t\t\t\t\tcombined_node_val_keyframe[node] = {\n\t\t\t\t\t\t\"rulebook\": (graph, node)\n\t\t\t\t\t}\n\t\t\tcombined_edge_val_keyframe = {\n\t\t\t\torig: {dest: val.copy() for (dest, val) in dests.items()}\n\t\t\t\tfor (orig, dests) in edge_val_keyframe.get(graph, {}).items()\n\t\t\t}\n\t\t\tfor orig, dests in portals_rulebooks_keyframe.get(\n\t\t\t\tgraph, {}\n\t\t\t).items():\n\t\t\t\tfor dest, rb in dests.items():\n\t\t\t\t\tif (\n\t\t\t\t\t\torig not in edges_keyframe[graph]\n\t\t\t\t\t\tor dest not in edges_keyframe[graph][orig]\n\t\t\t\t\t):\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tcombined_edge_val_keyframe.setdefault(orig, {}).setdefault(\n\t\t\t\t\t\tdest, {}\n\t\t\t\t\t)[\"rulebook\"] = rb\n\t\t\tfor orig, dests in edges_keyframe.get(graph, {}).items():\n\t\t\t\tfor dest, ex in dests.items():\n\t\t\t\t\tif ex and (\n\t\t\t\t\t\torig not in combined_edge_val_keyframe\n\t\t\t\t\t\tor dest not in combined_edge_val_keyframe[orig]\n\t\t\t\t\t):\n\t\t\t\t\t\tcombined_edge_val_keyframe.setdefault(\n\t\t\t\t\t\t\torig, {}\n\t\t\t\t\t\t).setdefault(dest, {})\n\t\t\tcombined_graph_val_keyframe = graph_val_keyframe.get(\n\t\t\t\tgraph, {}\n\t\t\t).copy()\n\t\t\tcombined_graph_val_keyframe[\"character_rulebook\"] = (\n\t\t\t\tcharacters_rulebooks_keyframe[graph]\n\t\t\t)\n\t\t\tcombined_graph_val_keyframe[\"unit_rulebook\"] = (\n\t\t\t\tunits_rulebooks_keyframe[graph]\n\t\t\t)\n\t\t\tcombined_graph_val_keyframe[\"character_thing_rulebook\"] = (\n\t\t\t\tcharacters_things_rulebooks_keyframe[graph]\n\t\t\t)\n\t\t\tcombined_graph_val_keyframe[\"character_place_rulebook\"] = (\n\t\t\t\tcharacters_places_rulebooks_keyframe[graph]\n\t\t\t)\n\t\t\tcombined_graph_val_keyframe[\"character_portal_rulebook\"] = (\n\t\t\t\tcharacters_portals_rulebooks_keyframe[graph]\n\t\t\t)\n\t\t\tcombined_graph_val_keyframe[\"units\"] = units_keyframe[graph]\n\t\t\tinskf(\n\t\t\t\tgraph,\n\t\t\t\t*now,\n\t\t\t\tcombined_node_val_keyframe,\n\t\t\t\tcombined_edge_val_keyframe,\n\t\t\t\tcombined_graph_val_keyframe,\n\t\t\t)\n\t\tself._graph_cache.set_keyframe(*now, graphs_keyframe)\n\n\tdef _recurse_delta_keyframes(self, branch, turn, tick):\n\t\t\"\"\"Make keyframes until we have one in the current branch\"\"\"\n\t\ttime_from = branch, turn, tick\n\t\tkfd = self._keyframes_dict\n\t\tif time_from[0] in kfd:\n\t\t\t# could probably avoid these sorts by restructuring kfd\n\t\t\tfor turn in sorted(kfd[time_from[0]].keys(), reverse=True):\n\t\t\t\tif turn < time_from[1]:\n\t\t\t\t\treturn time_from[0], turn, max(kfd[time_from[0]][turn])\n\t\t\t\telif turn == time_from[1]:\n\t\t\t\t\tfor tick in sorted(kfd[time_from[0]][turn], reverse=True):\n\t\t\t\t\t\tif time_from[2] <= tick:\n\t\t\t\t\t\t\treturn time_from[0], turn, tick\n\t\tparent, branched_turn_from, branched_tick_from, turn_to, tick_to = (\n\t\t\tself._branches_d[time_from[0]]\n\t\t)\n\t\tif parent is None:\n\t\t\tif (\n\t\t\t\tbranch,\n\t\t\t\tbranched_turn_from,\n\t\t\t\tbranched_tick_from,\n\t\t\t) in self._keyframes_times:\n\t\t\t\tself._get_keyframe(\n\t\t\t\t\tbranch, branched_turn_from, branched_tick_from, silent=True\n\t\t\t\t)\n\t\t\t\treturn branch, branched_turn_from, branched_tick_from\n\t\t\telif branch in self._keyframes_dict:\n\t\t\t\tfor r in sorted(self._keyframes_dict[branch], reverse=True):\n\t\t\t\t\tif r <= turn:\n\t\t\t\t\t\tt = max(self._keyframes_dict[branch][r])\n\t\t\t\t\t\tself._get_keyframe(branch, r, t, silent=True)\n\t\t\t\t\t\treturn branch, r, t\n\t\t\tself._snap_keyframe_de_novo(*time_from)\n\t\t\tself._mark_keyframe_loaded(*time_from)\n\t\t\treturn time_from\n\t\telse:\n\t\t\t(parent, turn_from, tick_from) = self._recurse_delta_keyframes(\n\t\t\t\tparent, branched_turn_from, branched_tick_from\n\t\t\t)\n\t\t\tif (\n\t\t\t\tparent,\n\t\t\t\tbranched_turn_from,\n\t\t\t\tbranched_tick_from,\n\t\t\t) not in self._keyframes_times:\n\t\t\t\tself._get_keyframe(parent, turn_from, tick_from)\n\t\t\t\tself._snap_keyframe_from_delta(\n\t\t\t\t\t(parent, turn_from, tick_from),\n\t\t\t\t\t(parent, branched_turn_from, branched_tick_from),\n\t\t\t\t\tself._get_branch_delta(\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tturn_from,\n\t\t\t\t\t\ttick_from,\n\t\t\t\t\t\tbranched_turn_from,\n\t\t\t\t\t\tbranched_tick_from,\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\tself._mark_keyframe_loaded(\n\t\t\t\t\tparent, branched_turn_from, branched_tick_from\n\t\t\t\t)\n\t\t\tif (\n\t\t\t\ttime_from[0],\n\t\t\t\tbranched_turn_from,\n\t\t\t\tbranched_tick_from,\n\t\t\t) not in self._keyframes_times:\n\t\t\t\tself._get_keyframe(\n\t\t\t\t\tparent, branched_turn_from, branched_tick_from, silent=True\n\t\t\t\t)\n\t\t\t\tassert (\n\t\t\t\t\tparent,\n\t\t\t\t\tbranched_turn_from,\n\t\t\t\t\tbranched_tick_from,\n\t\t\t\t) in self._keyframes_loaded\n\t\t\t\tself._alias_kf(\n\t\t\t\t\tparent,\n\t\t\t\t\ttime_from[0],\n\t\t\t\t\tbranched_turn_from,\n\t\t\t\t\tbranched_tick_from,\n\t\t\t\t)\n\t\treturn time_from[0], branched_turn_from, branched_tick_from\n\n\tdef _node_exists(self, character: CharName, node: NodeName) -> bool:\n\t\tretrieve, btt = self._node_exists_stuff\n\t\targs = (character, node) + btt()\n\t\tretrieved = retrieve(args)\n\t\treturn retrieved and not isinstance(retrieved, Exception)\n\n\t@world_locked\n\tdef _exist_node(\n\t\tself,\n\t\tcharacter: CharName,\n\t\tnode: NodeName,\n\t\texist: bool = True,\n\t\t*,\n\t\tnow: Optional[Time] = None,\n\t) -> None:\n\t\tnbtt, exist_node, store = self._exist_node_stuff\n\t\tif now:\n\t\t\tbranch, turn, tick = now\n\t\telse:\n\t\t\tbranch, turn, tick = nbtt()\n\t\tstore(character, node, branch, turn, tick, exist)\n\t\tif exist:\n\t\t\tself._nodes_rulebooks_cache.store(\n\t\t\t\tcharacter, node, branch, turn, tick, (character, node)\n\t\t\t)\n\t\t\tself.query.set_node_rulebook(\n\t\t\t\tcharacter, node, branch, turn, tick, (character, node)\n\t\t\t)\n\t\texist_node(character, node, branch, turn, tick, exist)\n\n\tdef _edge_exists(\n\t\tself, character: CharName, orig: NodeName, dest: NodeName\n\t) -> bool:\n\t\tretrieve, btt = self._edge_exists_stuff\n\t\targs = (character, orig, dest, *btt())\n\t\tretrieved = retrieve(args)\n\t\treturn retrieved is not None and not isinstance(retrieved, Exception)\n\n\t@world_locked\n\tdef _exist_edge(\n\t\tself,\n\t\tcharacter: Key,\n\t\torig: Key,\n\t\tdest: Key,\n\t\texist: bool = True,\n\t\t*,\n\t\tnow: Optional[Time] = None,\n\t) -> None:\n\t\tnbtt, exist_edge, store = self._exist_edge_stuff\n\t\tif now:\n\t\t\tbranch, turn, tick = now\n\t\telse:\n\t\t\tbranch, turn, tick = nbtt()\n\t\tstore(character, orig, dest, branch, turn, tick, exist)\n\t\tif (character, orig, dest) in self._edge_objs:\n\t\t\tdel self._edge_objs[character, orig, dest]\n\t\tif exist:\n\t\t\tself._portals_rulebooks_cache.store(\n\t\t\t\tcharacter,\n\t\t\t\torig,\n\t\t\t\tdest,\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t\t(character, orig, dest),\n\t\t\t)\n\t\t\tself.query.set_portal_rulebook(\n\t\t\t\tcharacter,\n\t\t\t\torig,\n\t\t\t\tdest,\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t\t(character, orig, dest),\n\t\t\t)\n\t\texist_edge(character, orig, dest, branch, turn, tick, exist or False)\n\n\tdef _call_in_subprocess(\n\t\tself,\n\t\tuid,\n\t\tmethod,\n\t\tfuture: Future,\n\t\t*args,\n\t\tupdate=True,\n\t\t**kwargs,\n\t):\n\t\ti = uid % len(self._worker_inputs)\n\t\tuidbytes = uid.to_bytes(8, \"little\")\n\t\targbytes = zlib.compress(self.pack((method, args, kwargs)))\n\t\twith self._worker_locks[i]:\n\t\t\tif update:\n\t\t\t\tself._update_worker_process_state(i, lock=False)\n\t\t\tself._worker_inputs[i].send_bytes(uidbytes + argbytes)\n\t\t\toutput = self._worker_outputs[i].recv_bytes()\n\t\tgot_uid = int.from_bytes(output[:8], \"little\")\n\t\tresult = self.unpack(zlib.decompress(output[8:]))\n\t\tassert got_uid == uid\n\t\tself._how_many_futs_running -= 1\n\t\tdel self._uid_to_fut[uid]\n\t\tif isinstance(result, Exception):\n\t\t\tfuture.set_exception(result)\n\t\telse:\n\t\t\tfuture.set_result(result)\n\n\tdef _build_loading_windows(\n\t\tself,\n\t\tbranch_from: str,\n\t\tturn_from: int,\n\t\ttick_from: int,\n\t\tbranch_to: str,\n\t\tturn_to: int | None,\n\t\ttick_to: int | None,\n\t) -> list[tuple[str, int, int, int, int]]:\n\t\t\"\"\"Return windows of time I've got to load\n\n\t\tIn order to have a complete timeline between these points.\n\n\t\tReturned windows are in reverse chronological order.\n\n\t\t\"\"\"\n\t\tif branch_from == branch_to:\n\t\t\treturn [(branch_from, turn_from, tick_from, turn_to, tick_to)]\n\t\twindows = []\n\t\tif turn_to is None:\n\t\t\tbranch1 = self.branch_parent(branch_to)\n\t\t\tturn1, tick1 = self._branch_start(branch_to)\n\t\t\twindows.append(\n\t\t\t\t(\n\t\t\t\t\tbranch_to,\n\t\t\t\t\tturn1,\n\t\t\t\t\ttick1,\n\t\t\t\t\tNone,\n\t\t\t\t\tNone,\n\t\t\t\t)\n\t\t\t)\n\t\t\tparentage_iter = self._iter_parent_btt(branch1, turn1, tick1)\n\t\telse:\n\t\t\tparentage_iter = self._iter_parent_btt(branch_to, turn_to, tick_to)\n\t\t\tbranch1, turn1, tick1 = next(parentage_iter)\n\t\tfor branch0, turn0, tick0 in parentage_iter:\n\t\t\twindows.append((branch1, turn0, tick0, turn1, tick1))\n\t\t\t(branch1, turn1, tick1) = (branch0, turn0, tick0)\n\t\t\tif branch0 == branch_from:\n\t\t\t\twindows.append((branch0, turn_from, tick_from, turn0, tick0))\n\t\t\t\tbreak\n\t\telse:\n\t\t\traise HistoricKeyError(\"Couldn't build sensible loading windows\")\n\t\treturn windows\n\n\tdef _keyframe_after(\n\t\tself, branch: Branch, turn: Turn, tick: Tick\n\t) -> Optional[Time]:\n\t\tif branch not in self._keyframes_dict:\n\t\t\treturn None\n\t\tkfdb = self._keyframes_dict[branch]\n\t\tif turn in kfdb:\n\t\t\tticks: set[Tick] = set(filter(partial(lt, tick), kfdb[turn]))\n\t\t\tif ticks:\n\t\t\t\treturn branch, turn, min(ticks)\n\t\tturns: set[Turn] = set(filter(partial(lt, turn), kfdb.keys()))\n\t\tif turns:\n\t\t\tr = min(turns)\n\t\t\treturn branch, r, min(kfdb[r])\n\t\treturn None\n\n\tdef _updload(self, branch, turn, tick):\n\t\tloaded = self._loaded\n\t\tif branch not in loaded:\n\t\t\tlatekf = self._keyframe_after(branch, turn, tick)\n\t\t\tif latekf is None or latekf == (branch, turn, tick):\n\t\t\t\tloaded[branch] = (turn, tick, None, None)\n\t\t\telse:\n\t\t\t\t_, r, t = latekf\n\t\t\t\tloaded[branch] = (turn, tick, r, t)\n\t\t\treturn\n\t\t(early_turn, early_tick, late_turn, late_tick) = loaded[branch]\n\t\tif None in (late_turn, late_tick):\n\t\t\tassert late_turn is late_tick is None\n\t\t\tif (turn, tick) < (early_turn, early_tick):\n\t\t\t\t(early_turn, early_tick) = (turn, tick)\n\t\telse:\n\t\t\tif (turn, tick) < (early_turn, early_tick):\n\t\t\t\t(early_turn, early_tick) = (turn, tick)\n\t\t\tif (late_turn, late_tick) < (turn, tick):\n\t\t\t\t(late_turn, late_tick) = (turn, tick)\n\t\tloaded[branch] = (early_turn, early_tick, late_turn, late_tick)\n\n\t@world_locked\n\tdef load_between(\n\t\tself,\n\t\tbranch: Branch,\n\t\tturn_from: Turn,\n\t\ttick_from: Tick,\n\t\tturn_to: Turn,\n\t\ttick_to: Tick,\n\t):\n\t\tif self._time_is_loaded_between(\n\t\t\tbranch, turn_from, tick_from, turn_to, tick_to\n\t\t):\n\t\t\treturn\n\t\ttry:\n\t\t\tself._get_keyframe(branch, turn_from, tick_from, silent=True)\n\t\texcept KeyframeError:\n\t\t\tself._recurse_delta_keyframes(branch, turn_from, tick_from)\n\t\tnoderows = []\n\t\tnodevalrows = []\n\t\tedgerows = []\n\t\tedgevalrows = []\n\t\tgraphvalrows = []\n\t\tgraphsrows = list(\n\t\t\tself.query.graphs_types(\n\t\t\t\tbranch, turn_from, tick_from, turn_to, tick_to\n\t\t\t)\n\t\t)\n\t\tself._graph_cache.load(graphsrows)\n\t\tloaded_graphs = self.query.load_windows(\n\t\t\t[(branch, turn_from, tick_from, turn_to, tick_to)]\n\t\t)\n\t\tfor graph, loaded in loaded_graphs.items():\n\t\t\tmatch graph:\n\t\t\t\tcase \"universals\":\n\t\t\t\t\tself._universal_cache.load(loaded)\n\t\t\t\tcase \"rulebooks\":\n\t\t\t\t\tself._rulebooks_cache.load(loaded)\n\t\t\t\tcase \"rule_triggers\":\n\t\t\t\t\tself._triggers_cache.load(loaded)\n\t\t\t\tcase \"rule_prereqs\":\n\t\t\t\t\tself._prereqs_cache.load(loaded)\n\t\t\t\tcase \"rule_actions\":\n\t\t\t\t\tself._actions_cache.load(loaded)\n\t\t\t\tcase \"rule_neighborhoods\":\n\t\t\t\t\tself._neighborhoods_cache.load(loaded)\n\t\t\t\tcase \"rule_big\":\n\t\t\t\t\tself._rule_bigness_cache.load(loaded)\n\t\t\t\tcase _:\n\t\t\t\t\tnoderows.extend(loaded[\"nodes\"])\n\t\t\t\t\tedgerows.extend(loaded[\"edges\"])\n\t\t\t\t\tnodevalrows.extend(loaded[\"node_val\"])\n\t\t\t\t\tedgevalrows.extend(loaded[\"edge_val\"])\n\t\t\t\t\tgraphvalrows.extend(loaded[\"graph_val\"])\n\t\t\t\t\tif things := loaded.get(\"things\"):\n\t\t\t\t\t\tself._things_cache.load(things)\n\t\t\t\t\tif crb := loaded.get(\"character_rulebook\"):\n\t\t\t\t\t\tself._characters_rulebooks_cache.load(crb)\n\t\t\t\t\tif urb := loaded.get(\"unit_rulebook\"):\n\t\t\t\t\t\tself._units_rulebooks_cache.load(urb)\n\t\t\t\t\tif cthrb := loaded.get(\"character_thing_rulebook\"):\n\t\t\t\t\t\tself._characters_things_rulebooks_cache.load(cthrb)\n\t\t\t\t\tif cprb := loaded.get(\"character_place_rulebook\"):\n\t\t\t\t\t\tself._characters_places_rulebooks_cache.load(cprb)\n\t\t\t\t\tif cporb := loaded.get(\"character_portal_rulebook\"):\n\t\t\t\t\t\tself._characters_portals_rulebooks_cache.load(cporb)\n\t\t\t\t\tif nrb := loaded.get(\"node_rulebook\"):\n\t\t\t\t\t\tself._nodes_rulebooks_cache.load(nrb)\n\t\t\t\t\tif porb := loaded.get(\"portal_rulebook\"):\n\t\t\t\t\t\tself._portals_rulebooks_cache.load(porb)\n\t\t\t\t\tloaded_graphs[graph] = loaded\n\t\tself._nodes_cache.load(noderows)\n\t\tself._node_val_cache.load(nodevalrows)\n\t\tself._edges_cache.load(edgerows)\n\t\tself._edge_val_cache.load(edgevalrows)\n\t\tself._graph_val_cache.load(graphvalrows)\n\t\tif not self._time_is_loaded_between(\n\t\t\tbranch, turn_from, tick_from, turn_to, tick_to\n\t\t):\n\t\t\tself.warning(\n\t\t\t\t\"Didn't completely fill the time window: %s (%d,%d)→(%d,%d)\",\n\t\t\t\tbranch,\n\t\t\t\tturn_from,\n\t\t\t\ttick_from,\n\t\t\t\tturn_to,\n\t\t\t\ttick_to,\n\t\t\t)\n\t\t\tself._extend_loaded_window(\n\t\t\t\tbranch, turn_from, tick_from, turn_to, tick_to\n\t\t\t)\n\t\treturn loaded_graphs\n\n\tdef _extend_loaded_window(\n\t\tself,\n\t\tbranch: Branch,\n\t\tturn_from: Turn,\n\t\ttick_from: Tick,\n\t\tturn_to: Turn | None,\n\t\ttick_to: Tick | None,\n\t):\n\t\tloaded = self._loaded\n\t\tif branch in loaded:\n\t\t\ta, b, x, y = loaded[branch]\n\t\t\tif None in (x, y) or (x, y) < (turn_to, tick_to):\n\t\t\t\t(x, y) = (turn_to, tick_to)\n\t\t\tif (turn_from, tick_from) < (a, b):\n\t\t\t\t(a, b) = (turn_from, tick_from)\n\t\t\tloaded[branch] = (a, b, x, y)\n\t\telse:\n\t\t\tloaded[branch] = turn_from, tick_from, turn_to, tick_to\n\n\t@world_locked\n\tdef unload(self) -> None:\n\t\t\"\"\"Remove everything from memory that can be removed.\"\"\"\n\t\t# If we're not connected to some database, we can't unload anything\n\t\t# without losing data\n\t\tif isinstance(self.query, NullQueryEngine):\n\t\t\treturn\n\t\t# find the slices of time that need to stay loaded\n\t\tbranch, turn, tick = self._btt()\n\t\titer_parent_btt = self._iter_parent_btt\n\t\tkfd = self._keyframes_dict\n\t\tif not kfd:\n\t\t\treturn\n\t\tloaded = self._loaded\n\t\tto_keep = {}\n\t\t# Find a path to the latest past keyframe we can use. Keep things\n\t\t# loaded from there to here.\n\t\tfor past_branch, past_turn, past_tick in iter_parent_btt(\n\t\t\tbranch, turn, tick\n\t\t):\n\t\t\tif past_branch not in loaded:\n\t\t\t\tcontinue  # nothing happened in this branch i guess\n\t\t\tearly_turn, early_tick, late_turn, late_tick = loaded[past_branch]\n\t\t\tif None in (late_turn, late_tick):\n\t\t\t\tassert late_turn is late_tick is None\n\t\t\t\tlate_turn, late_tick = self._branch_end(past_branch)\n\t\t\tif past_branch in kfd:\n\t\t\t\tfor kfturn, kfticks in kfd[past_branch].items():\n\t\t\t\t\t# this can't possibly perform very well.\n\t\t\t\t\t# Maybe I need another loadedness dict that gives the two\n\t\t\t\t\t# keyframes I am between and gets upkept upon time travel\n\t\t\t\t\tfor kftick in kfticks:\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(early_turn, early_tick)\n\t\t\t\t\t\t\t<= (kfturn, kftick)\n\t\t\t\t\t\t\t<= (late_turn, late_tick)\n\t\t\t\t\t\t):\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tkfturn < turn\n\t\t\t\t\t\t\t\tor (kfturn == turn and kftick < tick)\n\t\t\t\t\t\t\t) and (\n\t\t\t\t\t\t\t\tkfturn > early_turn\n\t\t\t\t\t\t\t\tor (\n\t\t\t\t\t\t\t\t\tkfturn == early_turn\n\t\t\t\t\t\t\t\t\tand kftick > early_tick\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t):\n\t\t\t\t\t\t\t\tearly_turn, early_tick = kfturn, kftick\n\t\t\t\t\t\t\telif (\n\t\t\t\t\t\t\t\tkfturn > turn\n\t\t\t\t\t\t\t\tor (kfturn == turn and kftick >= tick)\n\t\t\t\t\t\t\t) and (\n\t\t\t\t\t\t\t\tkfturn < late_turn\n\t\t\t\t\t\t\t\tor (kfturn == late_turn and kftick < late_tick)\n\t\t\t\t\t\t\t):\n\t\t\t\t\t\t\t\tlate_turn, late_tick = kfturn, kftick\n\t\t\t\tto_keep[past_branch] = (\n\t\t\t\t\tearly_turn,\n\t\t\t\t\tearly_tick,\n\t\t\t\t\t*max(((past_turn, past_tick), (late_turn, late_tick))),\n\t\t\t\t)\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tto_keep[past_branch] = (\n\t\t\t\t\tearly_turn,\n\t\t\t\t\tearly_tick,\n\t\t\t\t\tlate_turn,\n\t\t\t\t\tlate_tick,\n\t\t\t\t)\n\t\tif not to_keep:\n\t\t\t# unloading literally everything would make the game unplayable,\n\t\t\t# so don't\n\t\t\tif hasattr(self, \"warning\"):\n\t\t\t\tself.warning(\"Not unloading, due to lack of keyframes\")\n\t\t\treturn\n\t\tcaches = self._caches\n\t\tkf_to_keep = set()\n\t\ttimes_unloaded = set()\n\t\tfor past_branch, (\n\t\t\tearly_turn,\n\t\t\tearly_tick,\n\t\t\tlate_turn,\n\t\t\tlate_tick,\n\t\t) in to_keep.items():\n\t\t\t# I could optimize this with windowdicts\n\t\t\tif early_turn == late_turn:\n\t\t\t\tif (\n\t\t\t\t\tpast_branch in self._keyframes_dict\n\t\t\t\t\tand early_turn in self._keyframes_dict[past_branch]\n\t\t\t\t):\n\t\t\t\t\tfor tick in self._keyframes_dict[past_branch][early_turn]:\n\t\t\t\t\t\tif early_tick <= tick <= late_tick:\n\t\t\t\t\t\t\tkf_to_keep.add((past_branch, early_turn, tick))\n\t\t\telse:\n\t\t\t\tif past_branch in self._keyframes_dict:\n\t\t\t\t\tfor turn, ticks in self._keyframes_dict[\n\t\t\t\t\t\tpast_branch\n\t\t\t\t\t].items():\n\t\t\t\t\t\tif turn < early_turn or late_turn < turn:\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\telif early_turn == turn:\n\t\t\t\t\t\t\tfor tick in ticks:\n\t\t\t\t\t\t\t\tif early_tick <= tick:\n\t\t\t\t\t\t\t\t\tkf_to_keep.add((past_branch, turn, tick))\n\t\t\t\t\t\telif turn == late_turn:\n\t\t\t\t\t\t\tfor tick in ticks:\n\t\t\t\t\t\t\t\tif tick <= late_tick:\n\t\t\t\t\t\t\t\t\tkf_to_keep.add((past_branch, turn, tick))\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tkf_to_keep.update(\n\t\t\t\t\t\t\t\t(past_branch, turn, tick) for tick in ticks\n\t\t\t\t\t\t\t)\n\t\t\tkf_to_keep &= self._keyframes_loaded\n\t\t\tfor cache in caches:\n\t\t\t\tcache.truncate(past_branch, early_turn, early_tick, \"backward\")\n\t\t\t\tcache.truncate(past_branch, late_turn, late_tick, \"forward\")\n\t\t\t\tif not hasattr(cache, \"keyframe\"):\n\t\t\t\t\tcontinue\n\t\t\t\tfor graph, branches in cache.keyframe.items():\n\t\t\t\t\tturns = branches[past_branch]\n\t\t\t\t\tturns_truncated = turns.truncate(late_turn, \"forward\")\n\t\t\t\t\tif late_turn in turns:\n\t\t\t\t\t\tlate = turns[late_turn]\n\t\t\t\t\t\ttimes_unloaded.update(\n\t\t\t\t\t\t\t(past_branch, late_turn, t)\n\t\t\t\t\t\t\tfor t in late.truncate(late_tick, \"forward\")\n\t\t\t\t\t\t)\n\t\t\t\t\tturns_truncated.update(\n\t\t\t\t\t\tturns.truncate(early_turn, \"backward\")\n\t\t\t\t\t)\n\t\t\t\t\ttimes_unloaded.update(\n\t\t\t\t\t\t(past_branch, turn_deleted, tick_deleted)\n\t\t\t\t\t\tfor turn_deleted in self._keyframes_dict[\n\t\t\t\t\t\t\tpast_branch\n\t\t\t\t\t\t].keys()\n\t\t\t\t\t\t& turns_truncated\n\t\t\t\t\t\tfor tick_deleted in self._keyframes_dict[past_branch][\n\t\t\t\t\t\t\tturn_deleted\n\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t\t\tif early_turn in turns:\n\t\t\t\t\t\tearly = turns[early_turn]\n\t\t\t\t\t\ttimes_unloaded.update(\n\t\t\t\t\t\t\t(past_branch, early_turn, t)\n\t\t\t\t\t\t\tfor t in early.truncate(early_tick, \"backward\")\n\t\t\t\t\t\t)\n\t\t\t\t\tunloaded_wrongly = times_unloaded & kf_to_keep\n\t\t\t\t\tassert not unloaded_wrongly, unloaded_wrongly\n\t\tself._keyframes_loaded.clear()\n\t\tself._keyframes_loaded.update(kf_to_keep)\n\t\tloaded.update(to_keep)\n\t\tfor branch in set(loaded).difference(to_keep):\n\t\t\tfor cache in caches:\n\t\t\t\tcache.remove_branch(branch)\n\t\t\tdel loaded[branch]\n\n\tdef _time_is_loaded(\n\t\tself, branch: Branch, turn: Turn = None, tick: Tick = None\n\t) -> bool:\n\t\tloaded = self._loaded\n\t\tif branch not in loaded:\n\t\t\treturn False\n\t\tif turn is None:\n\t\t\tif tick is not None:\n\t\t\t\traise ValueError(\"Need both or neither of turn and tick\")\n\t\t\treturn True\n\t\tif tick is None:\n\t\t\t(past_turn, _, future_turn, _) = loaded[branch]\n\t\t\tif future_turn is None:\n\t\t\t\treturn past_turn <= turn\n\t\t\treturn past_turn <= turn <= future_turn\n\t\telse:\n\t\t\tearly_turn, early_tick, late_turn, late_tick = loaded[branch]\n\t\t\tif late_turn is None:\n\t\t\t\tassert late_tick is None\n\t\t\t\treturn (early_turn, early_tick) <= (turn, tick)\n\t\t\treturn (\n\t\t\t\t(early_turn, early_tick)\n\t\t\t\t<= (turn, tick)\n\t\t\t\t<= (late_turn, late_tick)\n\t\t\t)\n\n\tdef _time_is_loaded_between(\n\t\tself,\n\t\tbranch: Branch,\n\t\tturn_from: Turn,\n\t\ttick_from: Tick,\n\t\tturn_to: Turn,\n\t\ttick_to: Tick,\n\t) -> bool:\n\t\t\"\"\"Return whether we have all time in this window in memory\"\"\"\n\t\tloaded = self._loaded\n\t\tif branch not in loaded:\n\t\t\treturn False\n\t\tearly_turn, early_tick, late_turn, late_tick = loaded[branch]\n\t\tif (turn_from, tick_from) < (early_turn, early_tick):\n\t\t\treturn False\n\t\tif None in (late_turn, late_tick):\n\t\t\treturn True\n\t\telif (late_turn, late_tick) < (turn_to, tick_to):\n\t\t\treturn False\n\t\treturn True\n\n\tdef _iter_linear_time(self, branch: Branch):\n\t\tfor turn, ticks in reversed(self._keyframes_dict[branch].items()):\n\t\t\tfor tick in sorted(ticks, reverse=True):\n\t\t\t\tyield turn, tick\n\n\tdef _build_keyframe_window(\n\t\tself, branch: Branch, turn: Turn, tick: Tick, loading=False\n\t) -> tuple[Time | None, Time | None]:\n\t\t\"\"\"Return a pair of keyframes that contain the given moment\n\n\t\tThey give the smallest contiguous span of time I can reasonably load.\n\n\t\t\"\"\"\n\t\tbranch_now = branch\n\t\tturn_now = turn\n\t\ttick_now = tick\n\t\tlatest_past_keyframe: Optional[Time] = None\n\t\tearliest_future_keyframe: Optional[Time] = None\n\t\tbranch_parents = self._branch_parents\n\t\tcache = self._keyframes_times if loading else self._keyframes_loaded\n\t\tfor branch, turn, tick in self._iter_keyframes(\n\t\t\tbranch_now, turn_now, tick_now, loaded=not loading\n\t\t):\n\t\t\tif (turn, tick) <= (turn_now, tick_now):\n\t\t\t\tlatest_past_keyframe = branch, turn, tick\n\t\t\t\tbreak\n\t\tfor turn, ticks in (\n\t\t\tself._keyframes_dict[branch_now]\n\t\t\t.future(turn, include_same_rev=True)\n\t\t\t.items()\n\t\t):\n\t\t\tfor tick in sorted(ticks):\n\t\t\t\tif (turn, tick) <= (turn_now, tick_now):\n\t\t\t\t\tcontinue\n\t\t\t\tif (branch_now, turn, tick) in cache:\n\t\t\t\t\tearliest_future_keyframe = (branch_now, turn, tick)\n\t\t\t\t\tbreak\n\t\t\tif earliest_future_keyframe is not None:\n\t\t\t\tbreak\n\t\t(branch, turn, tick) = (branch_now, turn_now, tick_now)\n\t\tif not loading or branch not in self._loaded:\n\t\t\treturn latest_past_keyframe, earliest_future_keyframe\n\t\tif (\n\t\t\tearliest_future_keyframe\n\t\t\tand earliest_future_keyframe[1:] < self._loaded[branch][:2]\n\t\t):\n\t\t\tearliest_future_keyframe = (branch, *self._loaded[branch][:2])\n\t\tif (\n\t\t\tlatest_past_keyframe\n\t\t\tand None not in self._loaded[branch][2:]\n\t\t\tand self._loaded[branch][2:] < latest_past_keyframe[1:]\n\t\t):\n\t\t\tlatest_past_keyframe = (branch, *self._loaded[branch][2:])\n\t\treturn latest_past_keyframe, earliest_future_keyframe\n\n\t@world_locked\n\tdef snap_keyframe(\n\t\tself, silent: bool = False, update_worker_processes: bool = True\n\t) -> Keyframe | None:\n\t\t\"\"\"Make a copy of the complete state of the world.\n\n\t\tYou need to do this occasionally in order to keep time travel\n\t\tperformant.\n\n\t\tThe keyframe will be saved to the database at the next call to\n\t\t``flush``.\n\n\t\tReturn the keyframe by default. With ``silent=True``,\n\t\treturn ``None``. This is a little faster, and uses a little less\n\t\tmemory.\n\n\t\t\"\"\"\n\t\tbranch, turn, tick = self._btt()\n\t\tself.debug(\"Snapping keyframe at %s, %d, %d\", branch, turn, tick)\n\t\tif (branch, turn, tick) in self._keyframes_times:\n\t\t\tif silent:\n\t\t\t\treturn None\n\t\t\treturn self._get_keyframe(branch, turn, tick)\n\t\tif not (self._branch_start() <= (turn, tick) <= self._branch_end()):\n\t\t\traise OutOfTimelineError(\"Don't snap keyframes in plans\")\n\t\tkfd = self._keyframes_dict\n\t\tthe_kf: tuple[str, int, int] = None\n\t\tif branch in kfd:\n\t\t\t# I could probably avoid sorting these by using windowdicts\n\t\t\tfor trn in sorted(kfd[branch].keys(), reverse=True):\n\t\t\t\tif trn < turn:\n\t\t\t\t\tthe_kf = (branch, trn, max(kfd[branch][trn]))\n\t\t\t\t\tbreak\n\t\t\t\telif trn == turn:\n\t\t\t\t\tfor tck in sorted(kfd[branch][trn], reverse=True):\n\t\t\t\t\t\tif tck <= tick:\n\t\t\t\t\t\t\tthe_kf = (branch, trn, tck)\n\t\t\t\t\t\t\tbreak\n\t\t\t\tif the_kf is not None:\n\t\t\t\t\tbreak\n\t\tif the_kf is None:\n\t\t\tparent = self.branch_parent(branch)\n\t\t\tif parent is None:\n\t\t\t\tself.debug(\n\t\t\t\t\t\"Fresh keyframe, snapping de novo at %s, %d, %d\",\n\t\t\t\t\tbranch,\n\t\t\t\t\tturn,\n\t\t\t\t\ttick,\n\t\t\t\t)\n\t\t\t\tself._snap_keyframe_de_novo(branch, turn, tick)\n\t\t\t\tif silent:\n\t\t\t\t\treturn None\n\t\t\t\telse:\n\t\t\t\t\treturn self._get_kf(branch, turn, tick)\n\t\t\tself.debug(\n\t\t\t\t\"Swimming up the timestream from %s, %d, %d\",\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t)\n\t\t\tthe_kf = self._recurse_delta_keyframes(branch, turn, tick)\n\t\tif the_kf not in self._keyframes_loaded:\n\t\t\tself._get_keyframe(*the_kf, silent=True)\n\t\tif the_kf != (branch, turn, tick):\n\t\t\tself.load_between(*the_kf, turn, tick)\n\t\t\tif the_kf[0] != branch:\n\t\t\t\tself.debug(\n\t\t\t\t\t\"Aliasing keyframe from branch %s to %s, %d, %d\",\n\t\t\t\t\tthe_kf[0],\n\t\t\t\t\tbranch,\n\t\t\t\t\tturn,\n\t\t\t\t\ttick,\n\t\t\t\t)\n\t\t\t\tself._alias_kf(the_kf[0], branch, turn, tick)\n\t\t\tself._snap_keyframe_from_delta(\n\t\t\t\tthe_kf,\n\t\t\t\t(branch, turn, tick),\n\t\t\t\tself._get_branch_delta(*the_kf, turn, tick),\n\t\t\t)\n\t\t\tself._mark_keyframe_loaded(branch, turn, tick)\n\t\tif silent:\n\t\t\treturn None\n\t\tret = self._get_kf(branch, turn, tick)\n\t\tif hasattr(self, \"_worker_processes\") and update_worker_processes:\n\t\t\tself._update_all_worker_process_states(clobber=True)\n\t\treturn ret\n\n\t@world_locked\n\tdef _read_at(\n\t\tself, branch: Branch, turn: Turn, tick: Tick\n\t) -> tuple[\n\t\tTime | None,\n\t\tTime | None,\n\t\tlist,\n\t\tdict,\n\t]:\n\t\tlatest_past_keyframe: Time | None\n\t\tearliest_future_keyframe: Time | None\n\t\tbranch_now, turn_now, tick_now = branch, turn, tick\n\t\t(latest_past_keyframe, earliest_future_keyframe) = (\n\t\t\tself._build_keyframe_window(\n\t\t\t\tbranch_now,\n\t\t\t\tturn_now,\n\t\t\t\ttick_now,\n\t\t\t\tloading=True,\n\t\t\t)\n\t\t)\n\t\t# If branch is a descendant of branch_now, don't load the keyframe\n\t\t# there, because then we'd potentially be loading keyframes from any\n\t\t# number of possible futures, and we're trying to be conservative\n\t\t# about what we load. If neither branch is an ancestor of the other,\n\t\t# we can't use the keyframe for this load\n\n\t\tif latest_past_keyframe is None:\n\t\t\tif earliest_future_keyframe is None:\n\t\t\t\treturn (\n\t\t\t\t\tNone,\n\t\t\t\t\tNone,\n\t\t\t\t\tlist(\n\t\t\t\t\t\tself.query.graphs_types(\n\t\t\t\t\t\t\tself.query.globl[\"main_branch\"], 0, 0\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t\tself.query.load_windows(\n\t\t\t\t\t\t[(self.query.globl[\"main_branch\"], 0, 0, None, None)]\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\twindows = self._build_loading_windows(\n\t\t\t\t\tself.query.globl[\"main_branch\"], 0, 0, branch, turn, tick\n\t\t\t\t)\n\t\telse:\n\t\t\tpast_branch, past_turn, past_tick = latest_past_keyframe\n\t\t\tif earliest_future_keyframe is None:\n\t\t\t\t# Load data from the keyframe to now\n\t\t\t\twindows = self._build_loading_windows(\n\t\t\t\t\tpast_branch,\n\t\t\t\t\tpast_turn,\n\t\t\t\t\tpast_tick,\n\t\t\t\t\tbranch,\n\t\t\t\t\tNone,\n\t\t\t\t\tNone,\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\t# Load data between the two keyframes\n\t\t\t\t(future_branch, future_turn, future_tick) = (\n\t\t\t\t\tearliest_future_keyframe\n\t\t\t\t)\n\t\t\t\twindows = self._build_loading_windows(\n\t\t\t\t\tpast_branch,\n\t\t\t\t\tpast_turn,\n\t\t\t\t\tpast_tick,\n\t\t\t\t\tfuture_branch,\n\t\t\t\t\tfuture_turn,\n\t\t\t\t\tfuture_tick,\n\t\t\t\t)\n\t\tgraphs_types = []\n\t\tfor window in windows:\n\t\t\tgraphs_types.extend(self.query.graphs_types(*window))\n\t\treturn (\n\t\t\tlatest_past_keyframe,\n\t\t\tearliest_future_keyframe,\n\t\t\tgraphs_types,\n\t\t\tself.query.load_windows(windows),\n\t\t)\n\n\t@world_locked\n\tdef load_at(\n\t\tself, branch: Branch, turn: Turn, tick: Tick | None = None\n\t) -> None:\n\t\tif tick is None:\n\t\t\ttick = self._turn_end[branch, turn]\n\t\tif self._time_is_loaded(branch, turn, tick):\n\t\t\treturn\n\t\twith garbage():\n\t\t\tself._load(*self._read_at(branch, turn, tick))\n\n\tdef _load(\n\t\tself,\n\t\tlatest_past_keyframe: Time | None,\n\t\tearliest_future_keyframe: tuple[str, int, int] | None,\n\t\tgraphs_rows: list,\n\t\tloaded: dict,\n\t):\n\t\t\"\"\"Load history data at the given time\n\n\t\tWill load the keyframe prior to that time, and all history\n\t\tdata following, up to (but not including) the keyframe thereafter.\n\n\t\t\"\"\"\n\t\tif latest_past_keyframe:\n\t\t\tif hasattr(self, \"_validate_initial_keyframe_load\"):\n\t\t\t\tself._validate_initial_keyframe_load(\n\t\t\t\t\tself._get_keyframe(*latest_past_keyframe)\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\tself._get_keyframe(*latest_past_keyframe, silent=True)\n\n\t\tif universals := loaded.pop(\"universals\", None):\n\t\t\tself._universal_cache.load(universals)\n\t\tif rulebooks := loaded.pop(\"rulebooks\", None):\n\t\t\tself._rulebooks_cache.load(rulebooks)\n\t\tif rule_triggers := loaded.pop(\"rule_triggers\", None):\n\t\t\tself._triggers_cache.load(rule_triggers)\n\t\tif rule_prereqs := loaded.pop(\"rule_prereqs\", None):\n\t\t\tself._prereqs_cache.load(rule_prereqs)\n\t\tif rule_actions := loaded.pop(\"rule_actions\", None):\n\t\t\tself._actions_cache.load(rule_actions)\n\t\tif rule_neighborhoods := loaded.pop(\"rule_neighborhoods\", None):\n\t\t\tself._neighborhoods_cache.load(rule_neighborhoods)\n\t\tif rule_big := loaded.pop(\"rule_big\", None):\n\t\t\tself._rule_bigness_cache.load(rule_big)\n\t\tfor loaded_graph, data in loaded.items():\n\t\t\tassert isinstance(data, dict)\n\t\t\tif data.get(\"things\"):\n\t\t\t\tself._things_cache.load(data[\"things\"])\n\t\t\tif data.get(\"character_rulebook\"):\n\t\t\t\tself._characters_rulebooks_cache.load(\n\t\t\t\t\tdata[\"character_rulebook\"]\n\t\t\t\t)\n\t\t\tif data.get(\"unit_rulebook\"):\n\t\t\t\tself._units_rulebooks_cache.load(data[\"unit_rulebook\"])\n\t\t\tif data.get(\"character_thing_rulebook\"):\n\t\t\t\tself._characters_things_rulebooks_cache.load(\n\t\t\t\t\tdata[\"character_thing_rulebook\"]\n\t\t\t\t)\n\t\t\tif data.get(\"character_place_rulebook\"):\n\t\t\t\tself._characters_places_rulebooks_cache.load(\n\t\t\t\t\tdata[\"character_place_rulebook\"]\n\t\t\t\t)\n\t\t\tif data.get(\"character_portal_rulebook\"):\n\t\t\t\tself._characters_portals_rulebooks_cache.load(\n\t\t\t\t\tdata[\"character_portal_rulebook\"]\n\t\t\t\t)\n\t\t\tif data.get(\"node_rulebook\"):\n\t\t\t\tself._nodes_rulebooks_cache.load(data[\"node_rulebook\"])\n\t\t\tif data.get(\"portal_rulebook\"):\n\t\t\t\tself._portals_rulebooks_cache.load(data[\"portal_rulebook\"])\n\t\t\tif data.get(\"units\"):\n\t\t\t\tself._unitness_cache.load(data[\"units\"])\n\n\t\tself._graph_cache.load(graphs_rows)\n\t\tnoderows = []\n\t\tedgerows = []\n\t\tnodevalrows = []\n\t\tedgevalrows = []\n\t\tgraphvalrows = []\n\t\tfor graph, graph_loaded in loaded.items():\n\t\t\tnoderows.extend(graph_loaded[\"nodes\"])\n\t\t\tedgerows.extend(graph_loaded[\"edges\"])\n\t\t\tnodevalrows.extend(graph_loaded[\"node_val\"])\n\t\t\tedgevalrows.extend(graph_loaded[\"edge_val\"])\n\t\t\tgraphvalrows.extend(graph_loaded[\"graph_val\"])\n\n\t\tself._graph_cache.load(graphs_rows)\n\t\tself._nodes_cache.load(noderows)\n\t\tself._edges_cache.load(edgerows)\n\t\tself._graph_val_cache.load(graphvalrows)\n\t\tself._node_val_cache.load(nodevalrows)\n\t\tself._edge_val_cache.load(edgevalrows)\n\n\tdef turn_end(self, branch: Branch = None, turn: Turn = None) -> Tick:\n\t\tif branch is None:\n\t\t\tbranch = self._obranch\n\t\tif turn is None:\n\t\t\tturn = self._oturn\n\t\treturn self._turn_end[branch, turn]\n\n\tdef turn_end_plan(self, branch: Branch = None, turn: Turn = None) -> Tick:\n\t\tif branch is None:\n\t\t\tbranch = self._obranch\n\t\tif turn is None:\n\t\t\tturn = self._oturn\n\t\treturn self._turn_end_plan[branch, turn]\n\n\tdef submit(\n\t\tself, fn: FunctionType | MethodType, /, *args, **kwargs\n\t) -> Future:\n\t\tif fn.__module__ not in {\n\t\t\t\"function\",\n\t\t\t\"method\",\n\t\t\t\"trigger\",\n\t\t\t\"prereq\",\n\t\t\t\"action\",\n\t\t}:\n\t\t\traise ValueError(\n\t\t\t\t\"Function is not stored in this lisien engine. \"\n\t\t\t\t\"Use, eg., the engine's attribute `function` to store it.\"\n\t\t\t)\n\t\tuid = self._top_uid\n\t\tif hasattr(self, \"_worker_processes\"):\n\t\t\tret = Future()\n\t\t\tret._t = Thread(\n\t\t\t\ttarget=self._call_in_subprocess,\n\t\t\t\targs=(uid, fn, ret, *args),\n\t\t\t\tkwargs=kwargs,\n\t\t\t)\n\t\t\tself._uid_to_fut[uid] = ret\n\t\t\tself._futs_to_start.put(ret)\n\t\telse:\n\t\t\tret = fake_submit(fn, *args, **kwargs)\n\t\tret.uid = uid\n\t\tself._top_uid += 1\n\t\treturn ret\n\n\tdef _manage_futs(self):\n\t\twhile not hasattr(self, \"_closed\"):\n\t\t\twhile self._how_many_futs_running < self._workers:\n\t\t\t\ttry:\n\t\t\t\t\tfut = self._futs_to_start.get()\n\t\t\t\texcept Empty:\n\t\t\t\t\tbreak\n\t\t\t\tif not fut.running() and fut.set_running_or_notify_cancel():\n\t\t\t\t\tfut._t.start()\n\t\t\t\t\tself._how_many_futs_running += 1\n\t\t\tsleep(0.001)\n\n\tdef shutdown(self, wait=True, *, cancel_futures=False) -> None:\n\t\tif not hasattr(self, \"_worker_processes\"):\n\t\t\treturn\n\t\tif cancel_futures:\n\t\t\tfor fut in self._uid_to_fut.values():\n\t\t\t\tfut.cancel()\n\t\tif wait:\n\t\t\tfutwait(self._uid_to_fut.values())\n\t\tself._uid_to_fut = {}\n\n\t\tif hasattr(self, \"_worker_processes\"):\n\t\t\tfor i, (lock, pipein, pipeout, proc) in enumerate(\n\t\t\t\tzip(\n\t\t\t\t\tself._worker_locks,\n\t\t\t\t\tself._worker_inputs,\n\t\t\t\t\tself._worker_outputs,\n\t\t\t\t\tself._worker_processes,\n\t\t\t\t)\n\t\t\t):\n\t\t\t\twith lock:\n\t\t\t\t\tif not proc.is_alive():\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tpipein.send_bytes(b\"shutdown\")\n\t\t\t\t\tproc.join(timeout=SUBPROCESS_TIMEOUT)\n\t\t\t\t\tif proc.exitcode is None:\n\t\t\t\t\t\tif KILL_SUBPROCESS:\n\t\t\t\t\t\t\tos.kill(proc.pid, signal.SIGKILL)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\traise RuntimeError(\"Worker process didn't exit\", i)\n\t\t\t\t\tif not KILL_SUBPROCESS and proc.exitcode != 0:\n\t\t\t\t\t\traise RuntimeError(\n\t\t\t\t\t\t\t\"Worker process didn't exit normally\",\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tproc.exitcode,\n\t\t\t\t\t\t)\n\t\t\t\t\tproc.close()\n\t\t\t\t\tpipein.close()\n\t\t\t\t\tpipeout.close()\n\t\t\tdel self._worker_processes\n\n\tdef _detect_kf_interval_override(self):\n\t\tif self._planning:\n\t\t\treturn True\n\t\tif getattr(self, \"_no_kc\", False):\n\t\t\treturn True\n\n\tdef _reimport_some_functions(self, some):\n\t\tif getattr(self, \"_prefix\", None) is not None:\n\t\t\tself._call_every_subprocess(f\"_reimport_{some}\")\n\t\telse:\n\t\t\tcallables = {}\n\t\t\tfor att in dir(getattr(self, some)):\n\t\t\t\tv = getattr(getattr(self.some), att)\n\t\t\t\tif callable(v):\n\t\t\t\t\tcallables[att] = v\n\t\t\tself._call_every_subprocess(\n\t\t\t\tf\"_replace_{some}_pkl\", pickle.dumps(callables)\n\t\t\t)\n\n\tdef _reimport_trigger_functions(self, *args, attr, **kwargs):\n\t\tif attr is not None:\n\t\t\treturn\n\t\tself._reimport_some_functions(\"triggers\")\n\n\tdef _reimport_worker_functions(self, *args, attr, **kwargs):\n\t\tif attr is not None:\n\t\t\treturn\n\t\tself._reimport_some_functions(\"functions\")\n\n\tdef _reimport_worker_methods(self, *args, attr, **kwargs):\n\t\tif attr is not None:\n\t\t\treturn\n\t\tself._reimport_some_functions(\"methods\")\n\n\tdef _get_worker_kf_payload(self, uid: int = sys.maxsize) -> bytes:\n\t\t# I'm not using the uid at the moment, because this doesn't return anything\n\t\tplainstored = {}\n\t\tpklstored = {}\n\t\tfor name, store in [\n\t\t\t(\"function\", self.function),\n\t\t\t(\"method\", self.method),\n\t\t\t(\"trigger\", self.trigger),\n\t\t\t(\"prereq\", self.prereq),\n\t\t\t(\"action\", self.action),\n\t\t]:\n\t\t\tif hasattr(store, \"iterplain\") and callable(store.iterplain):\n\t\t\t\tplainstored[name] = dict(store.iterplain())\n\t\t\telse:\n\t\t\t\tpklstored[name] = pickle.dumps(store)\n\t\treturn uid.to_bytes(8, \"little\") + zlib.compress(\n\t\t\tself.pack(\n\t\t\t\t(\n\t\t\t\t\t\"_upd_from_game_start\",\n\t\t\t\t\t(\n\t\t\t\t\t\tNone,\n\t\t\t\t\t\t*self._btt(),\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tself.snap_keyframe(update_worker_processes=False),\n\t\t\t\t\t\t\tdict(self.eternal.items()),\n\t\t\t\t\t\t\tplainstored,\n\t\t\t\t\t\t\tpklstored,\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t\t{},\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\tdef _call_any_subprocess(self, method: str | callable, *args, **kwargs):\n\t\tuid = self._top_uid\n\t\tself._top_uid += 1\n\t\treturn self._call_in_subprocess(uid, method, *args, **kwargs)\n\n\t@contextmanager\n\tdef _all_worker_locks_ctx(self):\n\t\tfor lock in self._worker_locks:\n\t\t\tlock.acquire()\n\t\tyield\n\t\tfor lock in self._worker_locks:\n\t\t\tlock.release()\n\n\t@staticmethod\n\tdef _all_worker_locks(fn):\n\t\t@wraps(fn)\n\t\tdef call_with_all_worker_locks(self, *args, **kwargs):\n\t\t\twith self._all_worker_locks_ctx():\n\t\t\t\treturn fn(self, *args, **kwargs)\n\n\t\treturn call_with_all_worker_locks\n\n\t@_all_worker_locks\n\tdef _call_every_subprocess(self, method: str, *args, **kwargs):\n\t\tret = []\n\t\tuids = []\n\t\tfor _ in range(len(self._worker_processes)):\n\t\t\tuids.append(self._top_uid)\n\t\t\tuidbytes = self._top_uid.to_bytes(8, \"little\")\n\t\t\targbytes = zlib.compress(self.pack((method, args, kwargs)))\n\t\t\ti = self._top_uid % len(self._worker_processes)\n\t\t\tself._top_uid += 1\n\t\t\tself._worker_inputs[i].send_bytes(uidbytes + argbytes)\n\t\tfor uid in uids:\n\t\t\ti = uid % len(self._worker_processes)\n\t\t\toutbytes = self._worker_outputs[i].recv_bytes()\n\t\t\tgot_uid = int.from_bytes(outbytes[:8], \"little\")\n\t\t\tassert got_uid == uid\n\t\t\tretval = self.unpack(zlib.decompress(outbytes[8:]))\n\t\t\tif isinstance(retval, Exception):\n\t\t\t\traise retval\n\t\t\tret.append(retval)\n\t\treturn ret\n\n\t@world_locked\n\tdef _init_graph(\n\t\tself,\n\t\tname: CharName,\n\t\ttype_s: str = \"DiGraph\",\n\t\tdata: CharacterFacade | Graph | nx.Graph | dict | KeyframeTuple = None,\n\t) -> None:\n\t\tif name in self.illegal_graph_names:\n\t\t\traise GraphNameError(\"Illegal name\")\n\t\tbranch, turn, tick = self._btt()\n\t\tif (turn, tick) != (0, 0):\n\t\t\tbranch, turn, tick = self._nbtt()\n\t\tfor rbcache, rbname in [\n\t\t\t(self._characters_rulebooks_cache, \"character_rulebook\"),\n\t\t\t(self._units_rulebooks_cache, \"unit_rulebook\"),\n\t\t\t(\n\t\t\t\tself._characters_things_rulebooks_cache,\n\t\t\t\t\"character_thing_rulebook\",\n\t\t\t),\n\t\t\t(\n\t\t\t\tself._characters_places_rulebooks_cache,\n\t\t\t\t\"character_place_rulebook\",\n\t\t\t),\n\t\t\t(\n\t\t\t\tself._characters_portals_rulebooks_cache,\n\t\t\t\t\"character_portal_rulebook\",\n\t\t\t),\n\t\t]:\n\t\t\ttry:\n\t\t\t\tkf = rbcache.get_keyframe(branch, turn, tick)\n\t\t\texcept KeyframeError:\n\t\t\t\tkf = {}\n\t\t\t\tfor ch in self._graph_cache.iter_entities(branch, turn, tick):\n\t\t\t\t\t# may yield this very character\n\t\t\t\t\ttry:\n\t\t\t\t\t\tkf[ch] = rbcache.retrieve(ch, branch, turn, tick)\n\t\t\t\t\texcept KeyError:\n\t\t\t\t\t\tkf[ch] = (rbname, ch)\n\t\t\tkf[name] = (rbname, name)\n\t\t\trbcache.set_keyframe(branch, turn, tick, kf)\n\t\tself._graph_cache.store(name, branch, turn, tick, type_s)\n\t\tself.snap_keyframe(silent=True, update_worker_processes=False)\n\t\tself.query.graphs_insert(name, branch, turn, tick, type_s)\n\t\tself._extend_branch(branch, turn, tick)\n\t\tif isinstance(data, DiGraph):\n\t\t\tnodes = data._nodes_state()\n\t\t\tedges = data._edges_state()\n\t\t\tval = data._val_state()\n\t\t\tself._snap_keyframe_de_novo_graph(\n\t\t\t\tname, branch, turn, tick, nodes, edges, val\n\t\t\t)\n\t\t\tself.query.keyframe_graph_insert(\n\t\t\t\tname, branch, turn, tick, nodes, edges, val\n\t\t\t)\n\t\telif isinstance(data, nx.Graph):\n\t\t\tnodes = {k: v.copy() for (k, v) in data.nodes.items()}\n\t\t\tedges = {}\n\t\t\tfor orig in data.adj:\n\t\t\t\tsuccs = edges[orig] = {}\n\t\t\t\tfor dest, stats in data.adj[orig].items():\n\t\t\t\t\tsuccs[dest] = stats.copy()\n\t\t\tself._snap_keyframe_de_novo_graph(\n\t\t\t\tname,\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t\tnodes,\n\t\t\t\tedges,\n\t\t\t\tdata.graph,\n\t\t\t)\n\t\t\tself.query.keyframe_graph_insert(\n\t\t\t\tname,\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t\tnodes,\n\t\t\t\tedges,\n\t\t\t\tdata.graph,\n\t\t\t)\n\t\telif isinstance(data, dict):\n\t\t\ttry:\n\t\t\t\tdata = nx.from_dict_of_dicts(data)\n\t\t\texcept AttributeError:\n\t\t\t\tdata = nx.from_dict_of_lists(data)\n\t\t\tnodes = {k: v.copy() for (k, v) in data.nodes.items()}\n\t\t\tedges = {}\n\t\t\tfor orig in data.adj:\n\t\t\t\tsuccs = edges[orig] = {}\n\t\t\t\tfor dest, stats in data.adj[orig].items():\n\t\t\t\t\tsuccs[dest] = stats.copy()\n\t\t\tself._snap_keyframe_de_novo_graph(\n\t\t\t\tname, branch, turn, tick, nodes, edges, {}\n\t\t\t)\n\t\t\tself.query.keyframe_graph_insert(\n\t\t\t\tname,\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t\tnodes,\n\t\t\t\tedges,\n\t\t\t\t{},\n\t\t\t)\n\t\telif data is None:\n\t\t\tself._snap_keyframe_de_novo_graph(\n\t\t\t\tname, branch, turn, tick, {}, {}, {}\n\t\t\t)\n\t\t\tself.query.keyframe_graph_insert(\n\t\t\t\tname, branch, turn, tick, {}, {}, {}\n\t\t\t)\n\t\telse:\n\t\t\tif len(data) != 3 or not all(isinstance(d, dict) for d in data):\n\t\t\t\traise TypeError(\"Invalid graph data\")\n\t\t\tself._snap_keyframe_de_novo_graph(name, branch, turn, tick, *data)\n\t\t\tself.query.keyframe_graph_insert(name, branch, turn, tick, *data)\n\t\tif hasattr(self, \"_worker_processes\"):\n\t\t\tself._call_every_subprocess(\"_add_character\", name, data)\n\n\t@world_locked\n\tdef _complete_turn(self, branch: Branch, turn: Turn) -> None:\n\t\tself._extend_branch(branch, turn, self.turn_end_plan(branch, turn))\n\t\tself._turns_completed_d[branch] = turn\n\t\tself.query.complete_turn(\n\t\t\tbranch, turn, discard_rules=not self.keep_rules_journal\n\t\t)\n\n\tdef _get_last_completed_turn(self, branch: Branch) -> Turn | None:\n\t\tif branch not in self._turns_completed_d:\n\t\t\treturn None\n\t\treturn self._turns_completed_d[branch]\n\n\tdef _load_graphs(self) -> None:\n\t\tfor charn, branch, turn, tick, typ in self.query.characters():\n\t\t\tself._graph_cache.store(\n\t\t\t\tcharn,\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t\t(typ if typ != \"Deleted\" else None),\n\t\t\t)\n\t\t\tself._graph_objs[charn] = self.char_cls(\n\t\t\t\tself, charn, init_rulebooks=False\n\t\t\t)\n\n\tdef _make_node(\n\t\tself, graph: Character, node: NodeName\n\t) -> thing_cls | place_cls:\n\t\tif self._is_thing(graph.name, node):\n\t\t\treturn self.thing_cls(graph, node)\n\t\telse:\n\t\t\treturn self.place_cls(graph, node)\n\n\tdef _make_edge(\n\t\tself,\n\t\tgraph: Character,\n\t\torig: NodeName,\n\t\tdest: NodeName,\n\t) -> portal_cls:\n\t\treturn self.portal_cls(graph, orig, dest)\n\n\tdef _is_timespan_too_big(\n\t\tself, branch: Branch, turn_from: Turn, turn_to: Turn\n\t) -> bool:\n\t\t\"\"\"Return whether the changes between these turns are numerous enough that you might as well use the slow delta\n\n\t\tSomewhat imprecise.\n\n\t\t\"\"\"\n\t\tkfint = self.query.keyframe_interval\n\t\tif kfint is None:\n\t\t\treturn False\n\t\tif turn_from == turn_to:\n\t\t\treturn self._turn_end_plan[branch, turn_from] > kfint\n\t\tacc = 0\n\t\tr: Turn\n\t\tfor r in range(\n\t\t\tmin((turn_from, turn_to)),\n\t\t\tmax((turn_from, turn_to)),\n\t\t):\n\t\t\tacc += self._turn_end_plan[branch, r]\n\t\t\tif acc > kfint:\n\t\t\t\treturn True\n\t\treturn False\n\n\tdef get_delta(\n\t\tself,\n\t\ttime_from: Time | tuple[Branch, Turn],\n\t\ttime_to: Time | tuple[Branch, Turn],\n\t\tslow: bool = False,\n\t) -> DeltaDict:\n\t\t\"\"\"Get a dictionary describing changes to the world.\n\n\t\tMost keys will be character names, and their values will be\n\t\tdictionaries of the character's stats' new values, with ``None``\n\t\tfor deleted keys. Characters' dictionaries have special keys\n\t\t'nodes' and 'edges' which contain booleans indicating whether\n\t\tthe node or edge has been created (True) or deleted (False), and 'node_val' and\n\t\t'edge_val' for the stats of those entities. For edges (also\n\t\tcalled portals) these dictionaries are two layers deep, keyed\n\t\tfirst by the origin, then by the destination.\n\n\t\tCharacters also have special keys for the various rulebooks\n\t\tthey have:\n\n\t\t* ``'character_rulebook'``\n\t\t* ``'unit_rulebook'``\n\t\t* ``'character_thing_rulebook'``\n\t\t* ``'character_place_rulebook'``\n\t\t* ``'character_portal_rulebook'``\n\n\t\tAnd each node and edge may have a 'rulebook' stat of its own.\n\t\tIf a node is a thing, it gets a 'location'; when the 'location'\n\t\tis deleted, that means it's back to being a place.\n\n\t\tKeys at the top level that are not character names:\n\n\t\t* ``'rulebooks'``, a dictionary keyed by the name of each changed\n\t\t  rulebook, the value being a list of rule names\n\t\t* ``'rules'``, a dictionary keyed by the name of each changed rule,\n\t\t  containing any of the lists ``'triggers'``, ``'prereqs'``,\n\t\t  and ``'actions'``\n\n\n\t\t:param slow: Whether to compare entire keyframes. Default ``False``,\n\t\t\tbut we may take that approach anyway, if comparing between branches,\n\t\t\tor between times that are far enough apart that a delta assuming\n\t\t\tlinear time would require *more* comparisons than comparing keyframes.\n\n\t\t\"\"\"\n\t\tif len(time_from) < 3 or time_from[2] is None:\n\t\t\ttime_from = (*time_from[:2], self._turn_end_plan[time_from[:2]])\n\t\tif len(time_to) < 3 or time_to[2] is None:\n\t\t\ttime_to = (*time_to[:2], self._turn_end_plan[time_to[:2]])\n\t\tif time_from == time_to:\n\t\t\treturn {}\n\t\tif time_from[0] == time_to[0]:\n\t\t\tif slow or self._is_timespan_too_big(\n\t\t\t\ttime_from[0], time_from[1], time_to[1]\n\t\t\t):\n\t\t\t\treturn self._unpack_slightly_packed_delta(\n\t\t\t\t\tself._get_slow_delta(time_from, time_to)\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\treturn self._get_branch_delta(\n\t\t\t\t\t*time_from, time_to[1], time_to[2]\n\t\t\t\t)\n\t\treturn self._unpack_slightly_packed_delta(\n\t\t\tself._get_slow_delta(time_from, time_to)\n\t\t)\n\n\tdef _unpack_slightly_packed_delta(\n\t\tself, delta: SlightlyPackedDeltaType\n\t) -> DeltaDict:\n\t\tunpack = self.unpack\n\t\tdelta = delta.copy()\n\t\tdelt = {}\n\t\tif UNIVERSAL in delta:\n\t\t\tuniversal = delt[\"universal\"] = {}\n\t\t\tfor k, v in delta.pop(UNIVERSAL).items():\n\t\t\t\tuniversal[unpack(k)] = unpack(v)\n\t\tif RULES in delta:\n\t\t\trules = delt[\"rules\"] = {}\n\t\t\tfor rule_name, funclists in delta.pop(RULES).items():\n\t\t\t\trules[unpack(rule_name)] = {\n\t\t\t\t\t\"triggers\": unpack(funclists[TRIGGERS]),\n\t\t\t\t\t\"prereqs\": unpack(funclists[PREREQS]),\n\t\t\t\t\t\"actions\": unpack(funclists[ACTIONS]),\n\t\t\t\t}\n\t\tif RULEBOOK in delta:\n\t\t\trulebook = delt[\"rulebook\"] = {}\n\t\t\tfor rulebok, rules in delta.pop(RULEBOOK).items():\n\t\t\t\trulebook[unpack(rulebok)] = unpack(rules)\n\t\tfor char, chardeltpacked in delta.items():\n\t\t\tif chardeltpacked == ELLIPSIS:\n\t\t\t\tdelt[unpack(char)] = ...\n\t\t\t\tcontinue\n\t\t\tchardelt = delt[unpack(char)] = {}\n\t\t\tif NODES in chardeltpacked:\n\t\t\t\tchardelt[\"nodes\"] = {\n\t\t\t\t\tunpack(node): extant == TRUE\n\t\t\t\t\tfor (node, extant) in chardeltpacked.pop(NODES).items()\n\t\t\t\t}\n\t\t\tif EDGES in chardeltpacked:\n\t\t\t\tedges = chardelt[\"edges\"] = {}\n\t\t\t\tfor ab, ex in chardeltpacked.pop(EDGES).items():\n\t\t\t\t\ta, b = unpack(ab)\n\t\t\t\t\tif a not in edges:\n\t\t\t\t\t\tedges[a] = {}\n\t\t\t\t\tedges[a][b] = ex == TRUE\n\t\t\tif NODE_VAL in chardeltpacked:\n\t\t\t\tnode_val = chardelt[\"node_val\"] = {}\n\t\t\t\tfor node, stats in chardeltpacked.pop(NODE_VAL).items():\n\t\t\t\t\tnode_val[unpack(node)] = {\n\t\t\t\t\t\tunpack(k): unpack(v) for (k, v) in stats.items()\n\t\t\t\t\t}\n\t\t\tif EDGE_VAL in chardeltpacked:\n\t\t\t\tedge_val = chardelt[\"edge_val\"] = {}\n\t\t\t\tfor a, bs in chardeltpacked.pop(EDGE_VAL).items():\n\t\t\t\t\taA = unpack(a)\n\t\t\t\t\tif aA not in edge_val:\n\t\t\t\t\t\tedge_val[aA] = {}\n\t\t\t\t\tfor b, stats in bs.items():\n\t\t\t\t\t\tedge_val[aA][unpack(b)] = {\n\t\t\t\t\t\t\tunpack(k): unpack(v) for (k, v) in stats.items()\n\t\t\t\t\t\t}\n\t\t\tfor k, v in chardeltpacked.items():\n\t\t\t\tchardelt[unpack(k)] = unpack(v)\n\t\treturn delt\n\n\tdef _get_slow_delta(\n\t\tself, btt_from: Time, btt_to: Time\n\t) -> SlightlyPackedDeltaType:\n\t\tdef newgraph():\n\t\t\treturn {\n\t\t\t\t# null mungers mean KeyError, which is correct\n\t\t\t\tNODES: PickyDefaultDict(\n\t\t\t\t\tbytes, args_munger=None, kwargs_munger=None\n\t\t\t\t),\n\t\t\t\tEDGES: PickyDefaultDict(\n\t\t\t\t\tbytes, args_munger=None, kwargs_munger=None\n\t\t\t\t),\n\t\t\t\tNODE_VAL: StructuredDefaultDict(\n\t\t\t\t\t1, bytes, args_munger=None, kwargs_munger=None\n\t\t\t\t),\n\t\t\t\tEDGE_VAL: StructuredDefaultDict(\n\t\t\t\t\t2, bytes, args_munger=None, kwargs_munger=None\n\t\t\t\t),\n\t\t\t}\n\n\t\tdelta: dict[bytes, Any] = {\n\t\t\tUNIVERSAL: PickyDefaultDict(bytes),\n\t\t\tRULES: StructuredDefaultDict(1, bytes),\n\t\t\tRULEBOOK: PickyDefaultDict(bytes),\n\t\t}\n\t\tpack = self.pack\n\t\tnow = self._btt()\n\t\tself._set_btt(*btt_from)\n\t\tkf_from = self.snap_keyframe()\n\t\tself._set_btt(*btt_to)\n\t\tkf_to = self.snap_keyframe()\n\t\tself._set_btt(*now)\n\t\tkeys = []\n\t\tids_from = []\n\t\tids_to = []\n\t\tvalues_from = []\n\t\tvalues_to = []\n\t\t# Comparing object IDs is guaranteed never to give a false equality,\n\t\t# because of the way keyframes are constructed.\n\t\t# It may give a false inequality.\n\t\tnon_graph_kf_keys = [\n\t\t\t\"universal\",\n\t\t\t\"triggers\",\n\t\t\t\"prereqs\",\n\t\t\t\"actions\",\n\t\t\t\"neighborhood\",\n\t\t\t\"big\",\n\t\t\t\"rulebook\",\n\t\t]\n\t\tfor kfkey in non_graph_kf_keys:\n\t\t\tfor k in (\n\t\t\t\tkf_from.get(kfkey, {}).keys() | kf_to.get(kfkey, {}).keys()\n\t\t\t):\n\t\t\t\tkeys.append((kfkey, k))\n\t\t\t\tva = kf_from[kfkey].get(k, ...)\n\t\t\t\tvb = kf_to[kfkey].get(k, ...)\n\t\t\t\tids_from.append(id(va))\n\t\t\t\tids_to.append(id(vb))\n\t\t\t\tvalues_from.append(va)\n\t\t\t\tvalues_to.append(vb)\n\t\tfor graph in kf_from[\"graph_val\"].keys() | kf_to[\"graph_val\"].keys():\n\t\t\ta = kf_from[\"graph_val\"].get(graph, {})\n\t\t\tb = kf_to[\"graph_val\"].get(graph, {})\n\t\t\tkey_union = a.keys() | b.keys()\n\t\t\tif \"units\" in key_union:\n\t\t\t\tunits_a = a.get(\"units\", {})\n\t\t\t\tunits_b = b.get(\"units\", {})\n\t\t\t\tfor g in units_a.keys() | units_b.keys():\n\t\t\t\t\tkeys.append((\"units\", graph, g))\n\t\t\t\t\tva = frozenset(units_a.get(g, {}).keys())\n\t\t\t\t\tvb = frozenset(units_b.get(g, {}).keys())\n\t\t\t\t\tids_from.append(id(va))\n\t\t\t\t\tids_to.append(id(vb))\n\t\t\t\t\tvalues_from.append(va)\n\t\t\t\t\tvalues_to.append(vb)\n\t\t\tfor k in (a.keys() | b.keys()) - {\"units\"}:\n\t\t\t\tkeys.append((\"graph\", graph, k))\n\t\t\t\tva = a.get(k, ...)\n\t\t\t\tvb = b.get(k, ...)\n\t\t\t\tids_from.append(id(va))\n\t\t\t\tids_to.append(id(vb))\n\t\t\t\tvalues_from.append(va)\n\t\t\t\tvalues_to.append(vb)\n\t\tfor graph in kf_from[\"node_val\"].keys() | kf_to[\"node_val\"].keys():\n\t\t\tnodes = set()\n\t\t\tif graph in kf_from[\"node_val\"]:\n\t\t\t\tnodes.update(kf_from[\"node_val\"][graph].keys())\n\t\t\tif graph in kf_to[\"node_val\"]:\n\t\t\t\tnodes.update(kf_to[\"node_val\"][graph].keys())\n\t\t\tfor node in nodes:\n\t\t\t\ta = kf_from[\"node_val\"].get(graph, {}).get(node, {})\n\t\t\t\tb = kf_to[\"node_val\"].get(graph, {}).get(node, {})\n\t\t\t\tfor k in a.keys() | b.keys():\n\t\t\t\t\tkeys.append((\"node\", graph, node, k))\n\t\t\t\t\tva = a.get(k, ...)\n\t\t\t\t\tvb = b.get(k, ...)\n\t\t\t\t\tids_from.append(id(va))\n\t\t\t\t\tids_to.append(id(vb))\n\t\t\t\t\tvalues_from.append(va)\n\t\t\t\t\tvalues_to.append(vb)\n\t\tfor graph in kf_from[\"edge_val\"].keys() | kf_to[\"edge_val\"].keys():\n\t\t\tedges = set()\n\t\t\tif graph in kf_from[\"edge_val\"]:\n\t\t\t\tfor orig in kf_from[\"edge_val\"][graph]:\n\t\t\t\t\tfor dest in kf_from[\"edge_val\"][graph][orig]:\n\t\t\t\t\t\tedges.add((orig, dest))\n\t\t\tif graph in kf_to[\"edge_val\"]:\n\t\t\t\tfor orig in kf_to[\"edge_val\"][graph]:\n\t\t\t\t\tfor dest in kf_to[\"edge_val\"][graph][orig]:\n\t\t\t\t\t\tedges.add((orig, dest))\n\t\t\tfor orig, dest in edges:\n\t\t\t\ta = (\n\t\t\t\t\tkf_from[\"edge_val\"]\n\t\t\t\t\t.get(graph, {})\n\t\t\t\t\t.get(orig, {})\n\t\t\t\t\t.get(dest, {})\n\t\t\t\t)\n\t\t\t\tb = (\n\t\t\t\t\tkf_to[\"edge_val\"]\n\t\t\t\t\t.get(graph, {})\n\t\t\t\t\t.get(orig, {})\n\t\t\t\t\t.get(dest, {})\n\t\t\t\t)\n\t\t\t\tfor k in a.keys() | b.keys():\n\t\t\t\t\tkeys.append((\"edge\", graph, orig, dest, k))\n\t\t\t\t\tva = a.get(k, ...)\n\t\t\t\t\tvb = b.get(k, ...)\n\t\t\t\t\tids_from.append(id(va))\n\t\t\t\t\tids_to.append(id(vb))\n\t\t\t\t\tvalues_from.append(va)\n\t\t\t\t\tvalues_to.append(vb)\n\n\t\tdef pack_one(k, va, vb, deleted_nodes, deleted_edges):\n\t\t\tif va == vb:\n\t\t\t\treturn\n\t\t\tmatch k:\n\t\t\t\tcase \"universal\", key:\n\t\t\t\t\tkey = pack(key)\n\t\t\t\t\tdelta[UNIVERSAL][key] = pack(vb)\n\t\t\t\tcase \"triggers\", rule:\n\t\t\t\t\tdelta[RULES][pack(rule)][TRIGGERS] = pack(vb)\n\t\t\t\tcase \"prereqs\", rule:\n\t\t\t\t\tdelta[RULES][pack(rule)][PREREQS] = pack(vb)\n\t\t\t\tcase \"actions\", rule:\n\t\t\t\t\tdelta[RULES][pack(rule)][ACTIONS] = pack(vb)\n\t\t\t\tcase \"neighborhood\", rule:\n\t\t\t\t\tdelta[RULES][pack(rule)][NEIGHBORHOOD] = pack(vb)\n\t\t\t\tcase \"big\", rule:\n\t\t\t\t\tdelta[RULES][pack(rule)][BIG] = pack(vb)\n\t\t\t\tcase \"rulebook\", rulebook:\n\t\t\t\t\tdelta[RULEBOOK][pack(rulebook)] = pack(vb)\n\t\t\t\tcase \"units\", char, graph:\n\t\t\t\t\tva: frozenset[NodeName]\n\t\t\t\t\tvb: frozenset[NodeName]\n\t\t\t\t\tcharpacked = pack(char)\n\t\t\t\t\tunit_delta = {}\n\t\t\t\t\tfor k in vb - va:\n\t\t\t\t\t\tunit_delta[k] = True\n\t\t\t\t\tfor k in va - vb:\n\t\t\t\t\t\tunit_delta[k] = False\n\t\t\t\t\tif charpacked in delta:\n\t\t\t\t\t\tif UNITS in delta[charpacked]:\n\t\t\t\t\t\t\tdelta[charpacked][UNITS][graph] = unit_delta\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tdelta[charpacked][UNITS] = {graph: unit_delta}\n\t\t\t\t\telse:\n\t\t\t\t\t\tdelta[charpacked] = {UNITS: {graph: unit_delta}}\n\t\t\t\tcase \"node\", graph, node, key:\n\t\t\t\t\tif graph in deleted_nodes and node in deleted_nodes[graph]:\n\t\t\t\t\t\treturn\n\t\t\t\t\tgraph, node, key = map(pack, (graph, node, key))\n\t\t\t\t\tif graph not in delta:\n\t\t\t\t\t\tdelta[graph] = newgraph()\n\t\t\t\t\tdelta[graph][NODE_VAL][node][key] = pack(vb)\n\t\t\t\tcase \"edge\", graph, orig, dest, key:\n\t\t\t\t\tif (graph, orig, dest) in deleted_edges:\n\t\t\t\t\t\treturn\n\t\t\t\t\tgraph, orig, dest, key = map(\n\t\t\t\t\t\tpack, (graph, orig, dest, key)\n\t\t\t\t\t)\n\t\t\t\t\tif graph not in delta:\n\t\t\t\t\t\tdelta[graph] = newgraph()\n\t\t\t\t\tdelta[graph][EDGE_VAL][orig][dest][key] = pack(vb)\n\t\t\t\tcase \"graph\", graph, key:\n\t\t\t\t\tgraph, key = map(pack, (graph, key))\n\t\t\t\t\tif graph not in delta:\n\t\t\t\t\t\tdelta[graph] = newgraph()\n\t\t\t\t\tdelta[graph][key] = pack(vb)\n\n\t\tdef pack_node(graph, node, existence):\n\t\t\tgrap, node = map(pack, (graph, node))\n\t\t\tif grap not in delta:\n\t\t\t\tdelta[grap] = newgraph()\n\t\t\tdelta[grap][NODES][node] = existence\n\n\t\tdef pack_edge(graph, orig, dest, existence):\n\t\t\tgraph, origdest = map(pack, (graph, (orig, dest)))\n\t\t\tif graph not in delta:\n\t\t\t\tdelta[graph] = newgraph()\n\t\t\tdelta[graph][EDGES][origdest] = existence\n\n\t\tfuts = []\n\t\twith ThreadPoolExecutor() as pool:\n\t\t\tnodes_intersection = (\n\t\t\t\tkf_from[\"nodes\"].keys() & kf_to[\"nodes\"].keys()\n\t\t\t)\n\t\t\tdeleted_nodes = {}\n\t\t\tfor graph in nodes_intersection:\n\t\t\t\tdeleted_nodes_here = deleted_nodes[graph] = (\n\t\t\t\t\tkf_from[\"nodes\"][graph].keys()\n\t\t\t\t\t- kf_to[\"nodes\"][graph].keys()\n\t\t\t\t)\n\t\t\t\tfor node in deleted_nodes_here:\n\t\t\t\t\tfuts.append(pool.submit(pack_node, graph, node, FALSE))\n\t\t\tdeleted_edges = set()\n\t\t\tfor graph in kf_from[\"edges\"]:\n\t\t\t\tfor orig in kf_from[\"edges\"][graph]:\n\t\t\t\t\tfor dest, ex in kf_from[\"edges\"][graph][orig].items():\n\t\t\t\t\t\tdeleted_edges.add((graph, orig, dest))\n\t\t\tfor graph in kf_to[\"edges\"]:\n\t\t\t\tfor orig in kf_to[\"edges\"][graph]:\n\t\t\t\t\tfor dest, ex in kf_to[\"edges\"][graph][orig].items():\n\t\t\t\t\t\tdeleted_edges.discard((graph, orig, dest))\n\t\t\tvalues_changed: np.array = np.array(ids_from) != np.array(ids_to)\n\t\t\tfor k, va, vb, _ in filter(\n\t\t\t\titemgetter(3),\n\t\t\t\tzip(keys, values_from, values_to, values_changed),\n\t\t\t):\n\t\t\t\tfuts.append(\n\t\t\t\t\tpool.submit(\n\t\t\t\t\t\tpack_one, k, va, vb, deleted_nodes, deleted_edges\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\tfor graf in (\n\t\t\t\tkf_from[\"graph_val\"].keys() - kf_to[\"graph_val\"].keys()\n\t\t\t):\n\t\t\t\tdelta[self.pack(graf)] = ELLIPSIS\n\t\t\tfor graph in nodes_intersection:\n\t\t\t\tfor node in (\n\t\t\t\t\tkf_to[\"nodes\"][graph].keys()\n\t\t\t\t\t- kf_from[\"nodes\"][graph].keys()\n\t\t\t\t):\n\t\t\t\t\tfuts.append(pool.submit(pack_node, graph, node, TRUE))\n\t\t\tfor graph, orig, dest in deleted_edges:\n\t\t\t\tfuts.append(pool.submit(pack_edge, graph, orig, dest, FALSE))\n\t\t\tedges_to = {\n\t\t\t\t(graph, orig, dest)\n\t\t\t\tfor graph in kf_to[\"edges\"]\n\t\t\t\tfor orig in kf_to[\"edges\"][graph]\n\t\t\t\tfor dest in kf_to[\"edges\"][graph][orig]\n\t\t\t}\n\t\t\tedges_from = {\n\t\t\t\t(graph, orig, dest)\n\t\t\t\tfor graph in kf_from[\"edges\"]\n\t\t\t\tfor orig in kf_from[\"edges\"][graph]\n\t\t\t\tfor dest in kf_from[\"edges\"][graph][orig]\n\t\t\t}\n\t\t\tfor graph, orig, dest in edges_to - edges_from:\n\t\t\t\tfuts.append(pool.submit(pack_edge, graph, orig, dest, TRUE))\n\t\t\tfor deleted in (\n\t\t\t\tkf_from[\"graph_val\"].keys() - kf_to[\"graph_val\"].keys()\n\t\t\t):\n\t\t\t\tdelta[pack(deleted)] = ELLIPSIS\n\t\t\tfutwait(futs)\n\t\tif not delta[UNIVERSAL]:\n\t\t\tdel delta[UNIVERSAL]\n\t\tif not delta[RULEBOOK]:\n\t\t\tdel delta[RULEBOOK]\n\t\ttodel = []\n\t\tfor rule_name, rule in delta[RULES].items():\n\t\t\tif not rule[TRIGGERS]:\n\t\t\t\tdel rule[TRIGGERS]\n\t\t\tif not rule[PREREQS]:\n\t\t\t\tdel rule[PREREQS]\n\t\t\tif not rule[ACTIONS]:\n\t\t\t\tdel rule[ACTIONS]\n\t\t\tif not rule:\n\t\t\t\ttodel.append(rule_name)\n\t\tfor deleterule in todel:\n\t\t\tdel delta[deleterule]\n\t\tif not delta[RULES]:\n\t\t\tdel delta[RULES]\n\t\tfor key, mapp in delta.items():\n\t\t\tif (\n\t\t\t\tkey in {RULES, RULEBOOKS, ETERNAL, UNIVERSAL}\n\t\t\t\tor mapp == ELLIPSIS\n\t\t\t):\n\t\t\t\tcontinue\n\t\t\ttodel = []\n\t\t\tif UNITS in mapp:\n\t\t\t\tmapp[UNITS] = pack(mapp[UNITS])\n\t\t\tfor keey, mappp in mapp.items():\n\t\t\t\tif not mappp:\n\t\t\t\t\ttodel.append(keey)\n\t\t\tfor todo in todel:\n\t\t\t\tdel mapp[todo]\n\t\tfor added in kf_to[\"graph_val\"].keys() - kf_from[\"graph_val\"].keys():\n\t\t\tgraphn = pack(added)\n\t\t\tif graphn not in delta:\n\t\t\t\tdelta[graphn] = {}\n\t\treturn delta\n\n\tdef _del_rulebook(self, rulebook):\n\t\traise NotImplementedError(\"Can't delete rulebooks yet\")\n\n\t@property\n\tdef stores(self):\n\t\treturn (\n\t\t\tself.action,\n\t\t\tself.prereq,\n\t\t\tself.trigger,\n\t\t\tself.function,\n\t\t\tself.method,\n\t\t\tself.string,\n\t\t)\n\n\tdef close(self) -> None:\n\t\t\"\"\"Commit changes and close the database\n\n\t\tThis will be useless thereafter.\n\n\t\t\"\"\"\n\t\tif hasattr(self, \"_closed\"):\n\t\t\traise RuntimeError(\"Already closed\")\n\t\ttime_was: tuple[Turn, Tick] = (self.turn, self.tick)\n\t\tif time_was > self._branch_end():\n\t\t\t(self.turn, self.tick) = self._branch_end()\n\t\tif (\n\t\t\tself._keyframe_on_close\n\t\t\tand self._btt() not in self._keyframes_times\n\t\t):\n\t\t\tif hasattr(self, \"_validate_final_keyframe\"):\n\t\t\t\tself._validate_final_keyframe(\n\t\t\t\t\tself.snap_keyframe(update_worker_processes=False)\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\tself.snap_keyframe(silent=True, update_worker_processes=False)\n\t\t(self.turn, self.tick) = time_was\n\t\tfor store in self.stores:\n\t\t\tif hasattr(store, \"save\"):\n\t\t\t\tstore.save(reimport=False)\n\t\t\tif not hasattr(store, \"_filename\") or store._filename is None:\n\t\t\t\tcontinue\n\t\t\tpath, filename = os.path.split(store._filename)\n\t\t\tmodname = filename[:-3]\n\t\t\tif modname in sys.modules:\n\t\t\t\tdel sys.modules[modname]\n\t\tself.commit()\n\t\tself.shutdown()\n\t\tself.query.close()\n\t\tfor cache in self._caches:\n\t\t\tif hasattr(cache, \"clear\"):\n\t\t\t\tcache.clear()\n\t\tgc.collect()\n\t\tself._closed = True\n\n\tdef __enter__(self):\n\t\t\"\"\"Return myself. For compatibility with ``with`` semantics.\"\"\"\n\t\treturn self\n\n\tdef __exit__(self, *args):\n\t\t\"\"\"Close on exit.\"\"\"\n\t\tself.close()\n\n\tdef _handled_char(\n\t\tself,\n\t\tcharn: CharName,\n\t\trulebook: RulebookName,\n\t\trulen: RuleName,\n\t\tbranch: Branch,\n\t\tturn: Turn,\n\t\ttick: Tick,\n\t) -> None:\n\t\ttry:\n\t\t\tself._character_rules_handled_cache.store(\n\t\t\t\tcharn, rulebook, rulen, branch, turn, tick\n\t\t\t)\n\t\texcept ValueError:\n\t\t\tassert (\n\t\t\t\trulen\n\t\t\t\tin self._character_rules_handled_cache.handled[\n\t\t\t\t\tcharn, rulebook, branch, turn\n\t\t\t\t]\n\t\t\t)\n\t\t\treturn\n\t\tself.query.handled_character_rule(\n\t\t\tcharn, rulebook, rulen, branch, turn, tick\n\t\t)\n\n\tdef _handled_av(\n\t\tself,\n\t\tcharacter: CharName,\n\t\tgraph: CharName,\n\t\tavatar: NodeName,\n\t\trulebook: RulebookName,\n\t\trule: RuleName,\n\t\tbranch: Branch,\n\t\tturn: Turn,\n\t\ttick: Tick,\n\t) -> None:\n\t\ttry:\n\t\t\tself._unit_rules_handled_cache.store(\n\t\t\t\tcharacter, graph, avatar, rulebook, rule, branch, turn, tick\n\t\t\t)\n\t\texcept ValueError:\n\t\t\tassert (\n\t\t\t\trule\n\t\t\t\tin self._unit_rules_handled_cache.handled[\n\t\t\t\t\tcharacter, graph, avatar, rulebook, branch, turn\n\t\t\t\t]\n\t\t\t)\n\t\t\treturn\n\t\tself.query.handled_unit_rule(\n\t\t\tcharacter, rulebook, rule, graph, avatar, branch, turn, tick\n\t\t)\n\n\tdef _handled_char_thing(\n\t\tself,\n\t\tcharacter: CharName,\n\t\trulebook: RulebookName,\n\t\trule: RuleName,\n\t\tthing: NodeName,\n\t\tbranch: Branch,\n\t\tturn: Turn,\n\t\ttick: Tick,\n\t) -> None:\n\t\ttry:\n\t\t\tself._character_thing_rules_handled_cache.store(\n\t\t\t\tcharacter, thing, rulebook, rule, branch, turn, tick\n\t\t\t)\n\t\texcept ValueError:\n\t\t\tassert (\n\t\t\t\trule\n\t\t\t\tin self._character_thing_rules_handled_cache.handled[\n\t\t\t\t\tcharacter, thing, rulebook, branch, turn\n\t\t\t\t]\n\t\t\t)\n\t\t\treturn\n\t\tself.query.handled_character_thing_rule(\n\t\t\tcharacter, rulebook, rule, thing, branch, turn, tick\n\t\t)\n\n\tdef _handled_char_place(\n\t\tself,\n\t\tcharacter: CharName,\n\t\tplace: NodeName,\n\t\trulebook: RulebookName,\n\t\trule: RuleName,\n\t\tbranch: Branch,\n\t\tturn: Turn,\n\t\ttick: Tick,\n\t) -> None:\n\t\ttry:\n\t\t\tself._character_place_rules_handled_cache.store(\n\t\t\t\tcharacter, place, rulebook, rule, branch, turn, tick\n\t\t\t)\n\t\texcept ValueError:\n\t\t\tassert (\n\t\t\t\trule\n\t\t\t\tin self._character_place_rules_handled_cache.handled[\n\t\t\t\t\tcharacter, place, rulebook, branch, turn\n\t\t\t\t]\n\t\t\t)\n\t\t\treturn\n\t\tself.query.handled_character_place_rule(\n\t\t\tcharacter, rulebook, rule, place, branch, turn, tick\n\t\t)\n\n\tdef _handled_char_port(\n\t\tself,\n\t\tcharacter: CharName,\n\t\torig: NodeName,\n\t\tdest: NodeName,\n\t\trulebook: RulebookName,\n\t\trule: RuleName,\n\t\tbranch: Branch,\n\t\tturn: Turn,\n\t\ttick: Tick,\n\t) -> None:\n\t\ttry:\n\t\t\tself._character_portal_rules_handled_cache.store(\n\t\t\t\tcharacter, orig, dest, rulebook, rule, branch, turn, tick\n\t\t\t)\n\t\texcept ValueError:\n\t\t\tassert (\n\t\t\t\trule\n\t\t\t\tin self._character_portal_rules_handled_cache.handled[\n\t\t\t\t\tcharacter, orig, dest, rulebook, branch, turn\n\t\t\t\t]\n\t\t\t)\n\t\t\treturn\n\t\tself.query.handled_character_portal_rule(\n\t\t\tcharacter, rulebook, rule, orig, dest, branch, turn, tick\n\t\t)\n\n\tdef _handled_node(\n\t\tself,\n\t\tcharacter: CharName,\n\t\tnode: NodeName,\n\t\trulebook: RulebookName,\n\t\trule: RuleName,\n\t\tbranch: Branch,\n\t\tturn: Turn,\n\t\ttick: Tick,\n\t) -> None:\n\t\ttry:\n\t\t\tself._node_rules_handled_cache.store(\n\t\t\t\tcharacter, node, rulebook, rule, branch, turn, tick\n\t\t\t)\n\t\texcept ValueError:\n\t\t\tassert (\n\t\t\t\trule\n\t\t\t\tin self._node_rules_handled_cache.handled[\n\t\t\t\t\tcharacter, node, rulebook, branch, turn\n\t\t\t\t]\n\t\t\t)\n\t\t\treturn\n\t\tself.query.handled_node_rule(\n\t\t\tcharacter, node, rulebook, rule, branch, turn, tick\n\t\t)\n\n\tdef _handled_portal(\n\t\tself,\n\t\tcharacter: CharName,\n\t\torig: NodeName,\n\t\tdest: NodeName,\n\t\trulebook: RulebookName,\n\t\trule: RuleName,\n\t\tbranch: Branch,\n\t\tturn: Turn,\n\t\ttick: Tick,\n\t) -> None:\n\t\ttry:\n\t\t\tself._portal_rules_handled_cache.store(\n\t\t\t\tcharacter, orig, dest, rulebook, rule, branch, turn, tick\n\t\t\t)\n\t\texcept ValueError:\n\t\t\tassert (\n\t\t\t\trule\n\t\t\t\tin self._portal_rules_handled_cache.handled[\n\t\t\t\t\tcharacter, orig, dest, rulebook, branch, turn\n\t\t\t\t]\n\t\t\t)\n\t\t\treturn\n\t\tself.query.handled_portal_rule(\n\t\t\tcharacter, orig, dest, rulebook, rule, branch, turn, tick\n\t\t)\n\n\t@world_locked\n\t@_all_worker_locks\n\tdef _update_all_worker_process_states(self, clobber: bool = False):\n\t\tfor store in self.stores:\n\t\t\tstore.save(reimport=False)\n\t\tkf_payload = None\n\t\tdeltas = {}\n\t\tfor i in range(len(self._worker_processes)):\n\t\t\tbranch_from, turn_from, tick_from = self._worker_updated_btts[i]\n\t\t\tif (branch_from, turn_from, tick_from) == self._btt():\n\t\t\t\tcontinue\n\t\t\tif not clobber and branch_from == self.branch:\n\t\t\t\told_eternal = self._worker_last_eternal\n\t\t\t\tnew_eternal = self._worker_last_eternal = dict(\n\t\t\t\t\tself.eternal.items()\n\t\t\t\t)\n\t\t\t\teternal_delta = {\n\t\t\t\t\tk: new_eternal.get(k, ...)\n\t\t\t\t\tfor k in old_eternal.keys() | new_eternal.keys()\n\t\t\t\t\tif old_eternal.get(k, ...) != new_eternal.get(k, ...)\n\t\t\t\t}\n\t\t\t\tif (branch_from, turn_from, tick_from) in deltas:\n\t\t\t\t\tdelt = deltas[branch_from, turn_from, tick_from]\n\t\t\t\telse:\n\t\t\t\t\tdelt = deltas[branch_from, turn_from, tick_from] = (\n\t\t\t\t\t\tself._get_branch_delta(\n\t\t\t\t\t\t\tbranch_from,\n\t\t\t\t\t\t\tturn_from,\n\t\t\t\t\t\t\ttick_from,\n\t\t\t\t\t\t\tself.turn,\n\t\t\t\t\t\t\tself.tick,\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\tif eternal_delta:\n\t\t\t\t\tdelt[\"eternal\"] = eternal_delta\n\t\t\t\tkwargs = {}\n\t\t\t\tif self._prefix is None:\n\t\t\t\t\tkwargs[\"_replace_funcs_plain\"] = plain = {}\n\t\t\t\t\tkwargs[\"_replace_funcs_pkl\"] = pkl = {}\n\t\t\t\t\tfor name, store in [\n\t\t\t\t\t\t(\"function\", self.function),\n\t\t\t\t\t\t(\"method\", self.method),\n\t\t\t\t\t\t(\"trigger\", self.trigger),\n\t\t\t\t\t\t(\"prereq\", self.prereq),\n\t\t\t\t\t\t(\"action\", self.action),\n\t\t\t\t\t]:\n\t\t\t\t\t\tif hasattr(store, \"iterplain\") and callable(\n\t\t\t\t\t\t\tstore.iterplain\n\t\t\t\t\t\t):\n\t\t\t\t\t\t\tplain[name] = dict(store.iterplain())\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tpkl[name] = pickle.dumps(store)\n\t\t\t\targbytes = sys.maxsize.to_bytes(8, \"little\") + zlib.compress(\n\t\t\t\t\tself.pack(\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\"_upd\",\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tNone,\n\t\t\t\t\t\t\t\tself.branch,\n\t\t\t\t\t\t\t\tself.turn,\n\t\t\t\t\t\t\t\tself.tick,\n\t\t\t\t\t\t\t\t(None, delt),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tkwargs,\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\tself._worker_inputs[i].send_bytes(argbytes)\n\t\t\telse:\n\t\t\t\tif kf_payload is None:\n\t\t\t\t\tkf_payload = self._get_worker_kf_payload()\n\t\t\t\tself._worker_inputs[i].send_bytes(kf_payload)\n\t\t\tself._worker_updated_btts[i] = self._btt()\n\t\t\tself.debug(\n\t\t\t\t\"Updated all worker process states at \"\n\t\t\t\t+ repr(self._worker_updated_btts[i])\n\t\t\t\t+ f\" ({len(deltas)} distinct deltas)\"\n\t\t\t)\n\n\t@world_locked\n\tdef _update_worker_process_state(self, i, lock=True):\n\t\tbranch_from, turn_from, tick_from = self._worker_updated_btts[i]\n\t\tif (branch_from, turn_from, tick_from) == self._btt():\n\t\t\treturn\n\t\told_eternal = self._worker_last_eternal\n\t\tnew_eternal = self._worker_last_eternal = dict(self.eternal.items())\n\t\teternal_delta = {\n\t\t\tk: new_eternal.get(k, ...)\n\t\t\tfor k in old_eternal.keys() | new_eternal.keys()\n\t\t\tif old_eternal.get(k, ...) != new_eternal.get(k, ...)\n\t\t}\n\t\tif branch_from == self.branch:\n\t\t\tdelt = self._get_branch_delta(\n\t\t\t\tbranch_from, turn_from, tick_from, self.turn, self.tick\n\t\t\t)\n\t\t\tdelt[\"eternal\"] = eternal_delta\n\t\t\targbytes = sys.maxsize.to_bytes(8, \"little\") + zlib.compress(\n\t\t\t\tself.pack(\n\t\t\t\t\t(\n\t\t\t\t\t\t\"_upd\",\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tNone,\n\t\t\t\t\t\t\tself.branch,\n\t\t\t\t\t\t\tself.turn,\n\t\t\t\t\t\t\tself.tick,\n\t\t\t\t\t\t\t(None, delt),\n\t\t\t\t\t\t),\n\t\t\t\t\t\t{},\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\telse:\n\t\t\targbytes = self._get_worker_kf_payload()\n\t\tif lock:\n\t\t\twith self._worker_locks[i]:\n\t\t\t\tself._worker_inputs[i].send_bytes(argbytes)\n\t\t\t\tself._worker_updated_btts[i] = self._btt()\n\t\telse:\n\t\t\tself._worker_inputs[i].send_bytes(argbytes)\n\t\t\tself._worker_updated_btts[i] = self._btt()\n\t\tself.debug(f\"Updated worker {i} at {self._worker_updated_btts[i]}\")\n\n\tdef _changed(self, charn: CharName, entity: tuple) -> bool:\n\t\tif len(entity) == 1:\n\t\t\tvbranches = self._node_val_cache.settings\n\t\t\tentikey = (charn, entity[0])\n\t\telif len(entity) != 2:\n\t\t\traise TypeError(\"Unknown entity type\")\n\t\telse:\n\t\t\tvbranches = self._edge_val_cache.settings\n\t\t\tentikey = (\n\t\t\t\tcharn,\n\t\t\t\t*entity,\n\t\t\t\t0,\n\t\t\t)\n\t\tbranch, turn, _ = self._btt()\n\t\tturn -= 1\n\t\tif turn <= self.branch_start_turn():\n\t\t\tbranch = self.branch_parent(branch)\n\t\t\tassert branch is not None\n\t\tif branch not in vbranches:\n\t\t\treturn False\n\t\tvbranchesb = vbranches[branch]\n\t\tif turn not in vbranchesb:\n\t\t\treturn False\n\t\treturn entikey in vbranchesb[turn].entikeys\n\n\tdef _iter_submit_triggers(\n\t\tself,\n\t\tprio: float,\n\t\trulebook: RulebookName,\n\t\trule: Rule,\n\t\thandled_fun: callable,\n\t\tentity,\n\t\tneighbors: Iterable = None,\n\t):\n\t\tchanged = self._changed\n\t\tcharn = entity.character.name\n\t\tif neighbors is not None and not (\n\t\t\tany(changed(charn, neighbor) for neighbor in neighbors)\n\t\t):\n\t\t\treturn\n\t\tif self.trigger.truth in rule.triggers:\n\t\t\tfut = fake_submit(self.trigger.truth)\n\t\t\tfut.rule = rule\n\t\t\tfut.prio = prio\n\t\t\tfut.entity = entity\n\t\t\tfut.rulebook = rulebook\n\t\t\tfut.handled = handled_fun\n\t\t\tyield fut\n\t\t\treturn\n\t\tfor trigger in rule.triggers:\n\t\t\tfut = self.submit(trigger, entity)\n\t\t\tfut.rule = rule\n\t\t\tfut.prio = prio\n\t\t\tfut.entity = entity\n\t\t\tfut.rulebook = rulebook\n\t\t\tfut.handled = handled_fun\n\t\t\tyield fut\n\n\tdef _check_prereqs(self, rule: Rule, handled_fun: callable, entity):\n\t\tif not entity:\n\t\t\treturn False\n\t\tfor prereq in rule.prereqs:\n\t\t\tres = prereq(entity)\n\t\t\tif not res:\n\t\t\t\thandled_fun(self.tick)\n\t\t\t\treturn False\n\t\treturn True\n\n\tdef _do_actions(self, rule: Rule, handled_fun: callable, entity):\n\t\tif rule.big:\n\t\t\tentity = entity.facade()\n\t\tactres = []\n\t\tfor action in rule.actions:\n\t\t\tres = action(entity)\n\t\t\tif res:\n\t\t\t\tactres.append(res)\n\t\t\tif not entity:\n\t\t\t\tbreak\n\t\tif rule.big:\n\t\t\twith self.batch():\n\t\t\t\tentity.engine.apply()\n\t\thandled_fun(self.tick)\n\t\treturn actres\n\n\tdef _get_place_neighbors(\n\t\tself, charn: CharName, name: NodeName\n\t) -> set[Key]:\n\t\tseen: set[Key] = set()\n\t\tfor succ in self._edges_cache.iter_successors(\n\t\t\tcharn, name, *self._btt()\n\t\t):\n\t\t\tseen.add(succ)\n\t\tfor pred in self._edges_cache.iter_predecessors(\n\t\t\tcharn, name, *self._btt()\n\t\t):\n\t\t\tseen.add(pred)\n\t\treturn seen\n\n\tdef _get_place_contents(self, charn: CharName, name: NodeName) -> set[Key]:\n\t\ttry:\n\t\t\treturn self._node_contents_cache.retrieve(\n\t\t\t\tcharn, name, *self._btt()\n\t\t\t)\n\t\texcept KeyError:\n\t\t\treturn set()\n\n\tdef _iter_place_portals(\n\t\tself, charn: CharName, name: NodeName\n\t) -> Iterator[tuple[Key, Key]]:\n\t\tnow = self._btt()\n\t\tfor dest in self._edges_cache.iter_successors(charn, name, *now):\n\t\t\tyield (name, dest)\n\t\tfor orig in self._edges_cache.iter_predecessors(charn, name, *now):\n\t\t\tyield (orig, name)\n\n\tdef _get_thing_location_tup(\n\t\tself, charn: CharName, name: NodeName\n\t) -> tuple[Key, Key] | ():\n\t\ttry:\n\t\t\treturn (self._things_cache.retrieve(charn, name, *self._btt()),)\n\t\texcept KeyError:\n\t\t\treturn ()\n\n\tdef _get_neighbors(\n\t\tself,\n\t\tentity: place_cls | thing_cls | portal_cls,\n\t\tneighborhood: int | None,\n\t) -> list[tuple[NodeName] | tuple[NodeName, NodeName]] | None:\n\t\t\"\"\"Get a list of neighbors within the neighborhood\n\n\t\tNeighbors are given by a tuple containing only their name,\n\t\tif they are Places or Things, or their origin's and destination's\n\t\tnames, if they are Portals.\n\n\t\t\"\"\"\n\t\tcharn = entity.character.name\n\t\tbtt = self._btt()\n\n\t\tif neighborhood is None:\n\t\t\treturn None\n\t\tif hasattr(entity, \"name\"):\n\t\t\tcache_key = (charn, entity.name, *btt)\n\t\telse:\n\t\t\tcache_key = (\n\t\t\t\tcharn,\n\t\t\t\tentity.origin.name,\n\t\t\t\tentity.destination.name,\n\t\t\t\t*btt,\n\t\t\t)\n\t\tif cache_key in self._neighbors_cache:\n\t\t\treturn self._neighbors_cache[cache_key]\n\t\tif hasattr(entity, \"name\"):\n\t\t\tneighbors = [(entity.name,)]\n\t\t\twhile hasattr(entity, \"location\"):\n\t\t\t\tentity = entity.location\n\t\t\t\tneighbors.append((entity.name,))\n\t\telse:\n\t\t\tneighbors = [(entity.origin.name, entity.destination.name)]\n\t\tseen = set(neighbors)\n\t\ti = 0\n\t\tfor _ in range(neighborhood):\n\t\t\tj = len(neighbors)\n\t\t\tfor neighbor in neighbors[i:]:\n\t\t\t\tif len(neighbor) == 2:\n\t\t\t\t\torign, destn = neighbor\n\t\t\t\t\tfor placen in (orign, destn):\n\t\t\t\t\t\tfor neighbor_place in chain(\n\t\t\t\t\t\t\tself._get_place_neighbors(charn, placen),\n\t\t\t\t\t\t\tself._get_place_contents(charn, placen),\n\t\t\t\t\t\t\tself._get_thing_location_tup(charn, placen),\n\t\t\t\t\t\t):\n\t\t\t\t\t\t\tif neighbor_place not in seen:\n\t\t\t\t\t\t\t\tneighbors.append((neighbor_place,))\n\t\t\t\t\t\t\t\tseen.add(neighbor_place)\n\t\t\t\t\t\t\tfor neighbor_thing in self._get_place_contents(\n\t\t\t\t\t\t\t\tcharn, neighbor_place\n\t\t\t\t\t\t\t):\n\t\t\t\t\t\t\t\tif neighbor_thing not in seen:\n\t\t\t\t\t\t\t\t\tneighbors.append((neighbor_thing,))\n\t\t\t\t\t\t\t\t\tseen.add(neighbor_thing)\n\t\t\t\t\t\tfor neighbor_portal in self._iter_place_portals(\n\t\t\t\t\t\t\tcharn, placen\n\t\t\t\t\t\t):\n\t\t\t\t\t\t\tif neighbor_portal not in seen:\n\t\t\t\t\t\t\t\tneighbors.append(neighbor_portal)\n\t\t\t\t\t\t\t\tseen.add(neighbor_portal)\n\t\t\t\telse:\n\t\t\t\t\t(neighbor,) = neighbor\n\t\t\t\t\tfor neighbor_place in chain(\n\t\t\t\t\t\tself._get_place_neighbors(charn, neighbor),\n\t\t\t\t\t\tself._get_place_contents(charn, neighbor),\n\t\t\t\t\t\tself._get_thing_location_tup(charn, neighbor),\n\t\t\t\t\t):\n\t\t\t\t\t\tif neighbor_place not in seen:\n\t\t\t\t\t\t\tneighbors.append((neighbor_place,))\n\t\t\t\t\t\t\tseen.add(neighbor_place)\n\t\t\t\t\t\tfor neighbor_thing in self._get_place_contents(\n\t\t\t\t\t\t\tcharn, neighbor_place\n\t\t\t\t\t\t):\n\t\t\t\t\t\t\tif neighbor_thing not in seen:\n\t\t\t\t\t\t\t\tneighbors.append((neighbor_thing,))\n\t\t\t\t\t\t\t\tseen.add(neighbor_thing)\n\t\t\t\t\tfor neighbor_portal in self._iter_place_portals(\n\t\t\t\t\t\tcharn, neighbor\n\t\t\t\t\t):\n\t\t\t\t\t\tif neighbor_portal not in seen:\n\t\t\t\t\t\t\tneighbors.append(neighbor_portal)\n\t\t\t\t\t\t\tseen.add(neighbor_portal)\n\t\t\ti = j\n\t\tself._neighbors_cache[cache_key] = neighbors\n\t\treturn neighbors\n\n\tdef _get_effective_neighbors(\n\t\tself,\n\t\tentity: place_cls | thing_cls | portal_cls,\n\t\tneighborhood: Optional[int],\n\t) -> list[tuple[NodeName] | tuple[NodeName, NodeName]] | None:\n\t\t\"\"\"Get neighbors unless that's a different set of entities since last turn\n\n\t\tIn which case return None\n\n\t\t\"\"\"\n\t\tif neighborhood is None:\n\t\t\treturn None\n\n\t\tbranch_now, turn_now, tick_now = self._btt()\n\t\tif turn_now <= 1:\n\t\t\t# everything's \"created\" at the start of the game,\n\t\t\t# and therefore, there's been a \"change\" to the neighborhood\n\t\t\treturn None\n\t\twith self.world_lock:\n\t\t\tself.load_at(branch_now, Turn(turn_now - 1), 0)\n\t\t\tself._oturn -= 1\n\t\t\tself._otick = 0\n\t\t\tlast_turn_neighbors = self._get_neighbors(entity, neighborhood)\n\t\t\tself._set_btt(branch_now, turn_now, tick_now)\n\t\t\tthis_turn_neighbors = self._get_neighbors(entity, neighborhood)\n\t\tif set(last_turn_neighbors) != set(this_turn_neighbors):\n\t\t\treturn None\n\t\treturn this_turn_neighbors\n\n\tdef _get_thing(self, graphn: CharName, thingn: NodeName):\n\t\tnode_objs = self._node_objs\n\t\tkey = (graphn, thingn)\n\t\tif key not in node_objs:\n\t\t\tnode_objs[key] = self.thing_cls(self.character[graphn], thingn)\n\t\treturn node_objs[key]\n\n\tdef _get_place(self, graphn: CharName, placen: NodeName):\n\t\tnode_objs = self._node_objs\n\t\tkey = (graphn, placen)\n\t\tif key not in node_objs:\n\t\t\tnode_objs[key] = self.place_cls(self.character[graphn], placen)\n\t\treturn node_objs[key]\n\n\tdef _eval_triggers(self):\n\t\tbranch, turn, tick = self._btt()\n\t\tcharmap = self.character\n\t\trulemap = self.rule\n\t\ttodo = defaultdict(list)\n\t\ttrig_futs = []\n\n\t\tfor (\n\t\t\tprio,\n\t\t\tcharactername,\n\t\t\trulebook,\n\t\t\trulename,\n\t\t) in self._character_rules_handled_cache.iter_unhandled_rules(\n\t\t\tbranch, turn, tick\n\t\t):\n\t\t\tif charactername not in charmap:\n\t\t\t\tcontinue\n\t\t\trule = rulemap[rulename]\n\t\t\thandled = partial(\n\t\t\t\tself._handled_char,\n\t\t\t\tcharactername,\n\t\t\t\trulebook,\n\t\t\t\trulename,\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t)\n\t\t\tentity = charmap[charactername]\n\t\t\ttrig_futs.extend(\n\t\t\t\tself._iter_submit_triggers(\n\t\t\t\t\tprio,\n\t\t\t\t\trulebook,\n\t\t\t\t\trule,\n\t\t\t\t\thandled,\n\t\t\t\t\tentity,\n\t\t\t\t\tNone,\n\t\t\t\t)\n\t\t\t)\n\n\t\tavcache_retr = self._unitness_cache._base_retrieve\n\t\tnode_exists = self._node_exists\n\t\tget_node = self._get_node\n\t\tget_thing = self._get_thing\n\t\tget_place = self._get_place\n\n\t\tfor (\n\t\t\tprio,\n\t\t\tcharn,\n\t\t\tgraphn,\n\t\t\tavn,\n\t\t\trulebook,\n\t\t\trulen,\n\t\t) in self._unit_rules_handled_cache.iter_unhandled_rules(\n\t\t\tbranch, turn, tick\n\t\t):\n\t\t\tif not node_exists(graphn, avn) or avcache_retr(\n\t\t\t\t(charn, graphn, avn, branch, turn, tick)\n\t\t\t) in (KeyError, None):\n\t\t\t\tcontinue\n\t\t\trule = rulemap[rulen]\n\t\t\thandled = partial(\n\t\t\t\tself._handled_av,\n\t\t\t\tcharn,\n\t\t\t\tgraphn,\n\t\t\t\tavn,\n\t\t\t\trulebook,\n\t\t\t\trulen,\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t)\n\t\t\tentity = get_node(graphn, avn)\n\t\t\ttrig_futs.extend(\n\t\t\t\tself._iter_submit_triggers(\n\t\t\t\t\tprio,\n\t\t\t\t\trulebook,\n\t\t\t\t\trule,\n\t\t\t\t\thandled,\n\t\t\t\t\tentity,\n\t\t\t\t\tself._get_effective_neighbors(entity, rule.neighborhood),\n\t\t\t\t)\n\t\t\t)\n\t\tis_thing = self._is_thing\n\t\thandled_char_thing = self._handled_char_thing\n\t\tfor (\n\t\t\tprio,\n\t\t\tcharn,\n\t\t\tthingn,\n\t\t\trulebook,\n\t\t\trulen,\n\t\t) in self._character_thing_rules_handled_cache.iter_unhandled_rules(\n\t\t\tbranch, turn, tick\n\t\t):\n\t\t\tif not node_exists(charn, thingn) or not is_thing(charn, thingn):\n\t\t\t\tcontinue\n\t\t\trule = rulemap[rulen]\n\t\t\thandled = partial(\n\t\t\t\thandled_char_thing,\n\t\t\t\tcharn,\n\t\t\t\trulebook,\n\t\t\t\trulen,\n\t\t\t\tthingn,\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t)\n\t\t\tentity = get_thing(charn, thingn)\n\t\t\ttrig_futs.extend(\n\t\t\t\tself._iter_submit_triggers(\n\t\t\t\t\tprio,\n\t\t\t\t\trulebook,\n\t\t\t\t\trule,\n\t\t\t\t\thandled,\n\t\t\t\t\tentity,\n\t\t\t\t\tself._get_effective_neighbors(entity, rule.neighborhood),\n\t\t\t\t)\n\t\t\t)\n\t\thandled_char_place = self._handled_char_place\n\t\tfor (\n\t\t\tprio,\n\t\t\tcharn,\n\t\t\tplacen,\n\t\t\trulebook,\n\t\t\trulen,\n\t\t) in self._character_place_rules_handled_cache.iter_unhandled_rules(\n\t\t\tbranch, turn, tick\n\t\t):\n\t\t\tif not node_exists(charn, placen) or is_thing(charn, placen):\n\t\t\t\tcontinue\n\t\t\trule = rulemap[rulen]\n\t\t\thandled = partial(\n\t\t\t\thandled_char_place,\n\t\t\t\tcharn,\n\t\t\t\tplacen,\n\t\t\t\trulebook,\n\t\t\t\trulen,\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t)\n\t\t\tentity = get_place(charn, placen)\n\t\t\ttrig_futs.extend(\n\t\t\t\tself._iter_submit_triggers(\n\t\t\t\t\tprio,\n\t\t\t\t\trulebook,\n\t\t\t\t\trule,\n\t\t\t\t\thandled,\n\t\t\t\t\tentity,\n\t\t\t\t\tself._get_effective_neighbors(entity, rule.neighborhood),\n\t\t\t\t)\n\t\t\t)\n\t\tedge_exists = self._edge_exists\n\t\tget_edge = self._get_edge\n\t\thandled_char_port = self._handled_char_port\n\t\tfor (\n\t\t\tprio,\n\t\t\tcharn,\n\t\t\torign,\n\t\t\tdestn,\n\t\t\trulebook,\n\t\t\trulen,\n\t\t) in self._character_portal_rules_handled_cache.iter_unhandled_rules(\n\t\t\tbranch, turn, tick\n\t\t):\n\t\t\tif not edge_exists(charn, orign, destn):\n\t\t\t\tcontinue\n\t\t\trule = rulemap[rulen]\n\t\t\thandled = partial(\n\t\t\t\thandled_char_port,\n\t\t\t\tcharn,\n\t\t\t\torign,\n\t\t\t\tdestn,\n\t\t\t\trulebook,\n\t\t\t\trulen,\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t)\n\t\t\tentity = get_edge(charn, orign, destn)\n\t\t\ttrig_futs.extend(\n\t\t\t\tself._iter_submit_triggers(\n\t\t\t\t\tprio,\n\t\t\t\t\trulebook,\n\t\t\t\t\trule,\n\t\t\t\t\thandled,\n\t\t\t\t\tentity,\n\t\t\t\t\tself._get_effective_neighbors(entity, rule.neighborhood),\n\t\t\t\t)\n\t\t\t)\n\t\thandled_node = self._handled_node\n\t\tfor (\n\t\t\tprio,\n\t\t\tcharn,\n\t\t\tnoden,\n\t\t\trulebook,\n\t\t\trulen,\n\t\t) in self._node_rules_handled_cache.iter_unhandled_rules(\n\t\t\tbranch, turn, tick\n\t\t):\n\t\t\tif not node_exists(charn, noden):\n\t\t\t\tcontinue\n\t\t\trule = rulemap[rulen]\n\t\t\thandled = partial(\n\t\t\t\thandled_node, charn, noden, rulebook, rulen, branch, turn\n\t\t\t)\n\t\t\tentity = get_node(charn, noden)\n\t\t\ttrig_futs.extend(\n\t\t\t\tself._iter_submit_triggers(\n\t\t\t\t\tprio,\n\t\t\t\t\trulebook,\n\t\t\t\t\trule,\n\t\t\t\t\thandled,\n\t\t\t\t\tentity,\n\t\t\t\t\tself._get_effective_neighbors(entity, rule.neighborhood),\n\t\t\t\t)\n\t\t\t)\n\t\thandled_portal = self._handled_portal\n\t\tfor (\n\t\t\tprio,\n\t\t\tcharn,\n\t\t\torign,\n\t\t\tdestn,\n\t\t\trulebook,\n\t\t\trulen,\n\t\t) in self._portal_rules_handled_cache.iter_unhandled_rules(\n\t\t\tbranch, turn, tick\n\t\t):\n\t\t\tif not edge_exists(charn, orign, destn):\n\t\t\t\tcontinue\n\t\t\trule = rulemap[rulen]\n\t\t\thandled = partial(\n\t\t\t\thandled_portal,\n\t\t\t\tcharn,\n\t\t\t\torign,\n\t\t\t\tdestn,\n\t\t\t\trulebook,\n\t\t\t\trulen,\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t)\n\t\t\tentity = get_edge(charn, orign, destn)\n\t\t\ttrig_futs.extend(\n\t\t\t\tself._iter_submit_triggers(\n\t\t\t\t\tprio,\n\t\t\t\t\trulebook,\n\t\t\t\t\trule,\n\t\t\t\t\thandled,\n\t\t\t\t\tentity,\n\t\t\t\t\tself._get_effective_neighbors(entity, rule.neighborhood),\n\t\t\t\t)\n\t\t\t)\n\n\t\tfor fut in trig_futs:\n\t\t\tif fut.result():\n\t\t\t\ttodo[fut.prio, fut.rulebook].append(\n\t\t\t\t\t(\n\t\t\t\t\t\tfut.rule,\n\t\t\t\t\t\tfut.handled,\n\t\t\t\t\t\tfut.entity,\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\tfut.handled(self.tick)\n\n\t\treturn todo\n\n\tdef _fmtent(self, entity):\n\t\tif isinstance(entity, self.char_cls):\n\t\t\treturn entity.name\n\t\telif hasattr(entity, \"name\"):\n\t\t\treturn f\"{entity.character.name}.node[{entity.name}]\"\n\t\telse:\n\t\t\treturn (\n\t\t\t\tf\"{entity.character.name}.portal\"\n\t\t\t\tf\"[{entity.origin.name}][{entity.destination.name}]\"\n\t\t\t)\n\n\tdef _follow_one_rule(\n\t\tself,\n\t\trule: Rule,\n\t\thandled: callable,\n\t\tentity: char_cls | thing_cls | place_cls | portal_cls,\n\t):\n\t\tcheck_prereqs = self._check_prereqs\n\t\tdo_actions = self._do_actions\n\n\t\tif not entity:\n\t\t\tself.debug(\n\t\t\t\tf\"not checking prereqs for rule {rule.name} \"\n\t\t\t\tf\"on nonexistent entity {self._fmtent(entity)}\"\n\t\t\t)\n\t\t\treturn\n\t\tself.debug(\n\t\t\tf\"checking prereqs for rule {rule.name} on entity {self._fmtent(entity)}\"\n\t\t)\n\t\tif check_prereqs(rule, handled, entity):\n\t\t\tself.debug(\n\t\t\t\tf\"prereqs for rule {rule.name} on entity \"\n\t\t\t\tf\"{self._fmtent(entity)} satisfied, will run actions\"\n\t\t\t)\n\t\t\ttry:\n\t\t\t\tret = do_actions(rule, handled, entity)\n\t\t\t\tself.debug(\n\t\t\t\t\tf\"actions for rule {rule.name} on entity \"\n\t\t\t\t\tf\"{self._fmtent(entity)} have run without incident\"\n\t\t\t\t)\n\t\t\t\treturn ret\n\t\t\texcept StopIteration as ex:\n\t\t\t\traise InnerStopIteration from ex\n\n\tdef _follow_rules(\n\t\tself,\n\t\ttodo: dict[\n\t\t\tfloat,\n\t\t\tlist[\n\t\t\t\ttuple[\n\t\t\t\t\tRuleName,\n\t\t\t\t\tcallable,\n\t\t\t\t\tchar_cls | place_cls | thing_cls | portal_cls,\n\t\t\t\t]\n\t\t\t],\n\t\t],\n\t):\n\t\t# TODO: roll back changes done by rules that raise an exception\n\t\t# TODO: if there's a paradox while following some rule,\n\t\t#  start a new branch, copying handled rules\n\t\tfor prio_rulebook in sort_set(todo.keys()):\n\t\t\tfor rule, handled, entity in todo[prio_rulebook]:\n\t\t\t\tyield self._follow_one_rule(rule, handled, entity)\n\n\tdef new_character(\n\t\tself,\n\t\tname: Key | str | int | float | tuple[Key, ...] | frozenset[Key],\n\t\tdata: Optional[Graph] = None,\n\t\tlayout: bool = False,\n\t\tnode: Optional[NodeValDict] = None,\n\t\tedge: Optional[EdgeValDict] = None,\n\t\t**kwargs,\n\t) -> Character:\n\t\t\"\"\"Create and return a new :class:`Character`.\n\n\t\tSee :meth:`add_character` for details.\n\n\t\t\"\"\"\n\t\tself.add_character(name, data, layout, node=node, edge=edge, **kwargs)\n\t\treturn self.character[CharName(name)]\n\n\tdef add_character(\n\t\tself,\n\t\tname: Key | str | int | float | tuple[Key, ...] | frozenset[Key],\n\t\tdata: Optional[Graph | DiGraph] = None,\n\t\tlayout: bool = False,\n\t\tnode: Optional[NodeValDict] = None,\n\t\tedge: Optional[EdgeValDict] = None,\n\t\t**kwargs,\n\t) -> None:\n\t\t\"\"\"Create a new character.\n\n\t\tYou'll be able to access it as a :class:`Character` object by\n\t\tlooking up ``name`` in my ``character`` property.\n\n\t\t``data``, if provided, should be a :class:`networkx.Graph`\n\t\tor :class:`networkx.DiGraph` object. The character will be\n\t\ta copy of it.\n\n\t\t``node`` may be a dictionary of dictionaries representing either\n\t\t``Thing`` objects, if they have a ``\"location\"`` key, or else\n\t\t``Place`` objects.\n\n\t\t``edge`` may be a 3-layer dictionary representing ``Portal`` objects,\n\t\tconnecting mainly ``Place`` objects together.\n\n\t\tWith ``layout=True``, compute a layout to make the\n\t\tgraph show up nicely in elide.\n\n\t\tAny keyword arguments will be set as stats of the new character.\n\n\t\t\"\"\"\n\t\tif name in self.character:\n\t\t\traise KeyError(\"Already have that character\", name)\n\t\tif layout and (data or node or edge):\n\t\t\tif data is None:\n\t\t\t\tdata = nx.DiGraph()\n\t\t\tif node:\n\t\t\t\tfor name, nvs in node.items():\n\t\t\t\t\tdata.add_node(name, **nvs)\n\t\t\tif edge:\n\t\t\t\tfor orig, dests in edge.items():\n\t\t\t\t\tfor dest, evs in dests.items():\n\t\t\t\t\t\tdata.add_edge(orig, dest, **evs)\n\t\t\tnodes = data.nodes\n\t\t\ttry:\n\t\t\t\tlayout = normalize_layout(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: name\n\t\t\t\t\t\tfor name, node in nodes.items()\n\t\t\t\t\t\tif \"location\" not in node\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\texcept (TypeError, ValueError):\n\t\t\t\tlayout = normalize_layout(\n\t\t\t\t\tspring_layout(\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tfor name, node in nodes.items()\n\t\t\t\t\t\t\tif \"location\" not in node\n\t\t\t\t\t\t]\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\tfor k, (x, y) in layout.items():\n\t\t\t\tnodes[k][\"_x\"] = x\n\t\t\t\tnodes[k][\"_y\"] = y\n\t\tif kwargs:\n\t\t\tif not data:\n\t\t\t\tdata = nx.DiGraph()\n\t\t\tif not isinstance(data, Graph):\n\t\t\t\ttry:\n\t\t\t\t\tdata = from_dict_of_lists(data)\n\t\t\t\texcept NetworkXError:\n\t\t\t\t\tdata = from_dict_of_dicts(data)\n\t\t\tif node:\n\t\t\t\tfor k, v in node.items():\n\t\t\t\t\tdata.add_node(k, **v)\n\t\t\tif edge:\n\t\t\t\tfor orig, dests in edge.items():\n\t\t\t\t\tfor dest, v in dests.items():\n\t\t\t\t\t\tdata.add_edge(orig, dest, **v)\n\t\t\tdata.graph.update(kwargs)\n\t\t# When initializing the world state, we don't have to worry about deltas;\n\t\t# it's OK to make multiple characters at ('trunk', 0, 0).\n\t\t# At any time past the start, we have to advance the tick.\n\t\tif self.branch != self.main_branch or self.turn != 0 or self.tick != 0:\n\t\t\tself._nbtt()\n\t\tself._init_graph(name, \"DiGraph\", data)\n\t\tif self._btt() not in self._keyframes_times:\n\t\t\tself.snap_keyframe(silent=True, update_worker_processes=False)\n\t\tif hasattr(self, \"_worker_processes\"):\n\t\t\tself._update_all_worker_process_states(clobber=True)\n\t\tself._graph_objs[name] = self.char_cls(self, name)\n\n\t@world_locked\n\tdef del_character(self, name: CharName) -> None:\n\t\t\"\"\"Mark a graph as deleted\n\n\t\t:arg name: name of an existing graph\n\n\t\t\"\"\"\n\t\t# make sure the graph exists before deleting\n\t\tgraph = self.character[name]\n\t\twith self.batch(), self._graph_val_cache.overwriting():\n\t\t\tnow = self._nbtt()\n\t\t\tfor orig in list(graph.adj):\n\t\t\t\tfor dest in list(graph.adj[orig]):\n\t\t\t\t\tnow = graph.adj[orig][dest]._delete(now=now)\n\t\t\tfor node in list(graph.node):\n\t\t\t\tif node in graph.node:\n\t\t\t\t\tnow = graph.node[node]._delete(now=now)\n\t\t\tfor stat in set(graph.graph) - {\"name\", \"units\"}:\n\t\t\t\tself._graph_val_cache.store(name, stat, *now, None)\n\t\t\t\tself.query.graph_val_set(name, stat, *now, None)\n\t\t\tself._graph_cache.store(name, *now, ...)\n\t\t\tself.query.graphs_insert(name, *now, \"Deleted\")\n\t\t\tself._graph_cache.keycache.clear()\n\t\tif hasattr(self, \"_worker_processes\"):\n\t\t\tself._call_every_subprocess(\"_del_character\", name)\n\n\tdef _is_thing(self, character: CharName, node: NodeName) -> bool:\n\t\treturn self._things_cache.contains_entity(\n\t\t\tcharacter, node, *self._btt()\n\t\t)\n\n\t@world_locked\n\tdef _set_thing_loc(\n\t\tself, character: CharName, node: NodeName, loc: NodeName\n\t) -> None:\n\t\tif loc is not None:\n\t\t\t# make sure the location really exists now\n\t\t\tself._nodes_cache.retrieve(character, loc, *self.time)\n\t\tbranch, turn, tick = self._nbtt()\n\t\tself._things_cache.store(character, node, branch, turn, tick, loc)\n\t\tself.query.set_thing_loc(character, node, branch, turn, tick, loc)\n\n\tdef _snap_keyframe_de_novo(\n\t\tself, branch: Branch, turn: Turn, tick: Tick\n\t) -> None:\n\t\tuniversal = dict(self.universal.items())\n\t\tself._universal_cache.set_keyframe(branch, turn, tick, universal)\n\t\tall_graphs = {\n\t\t\tgraph: self._graph_cache.retrieve(graph, branch, turn, tick)\n\t\t\tfor graph in self._graph_cache.iter_keys(branch, turn, tick)\n\t\t}\n\t\tself._graph_cache.set_keyframe(branch, turn, tick, all_graphs)\n\t\tuser_kf = {}\n\t\tfor char in all_graphs:\n\t\t\tchar_kf = {}\n\t\t\tfor graph in self._unitness_cache.iter_char_graphs(\n\t\t\t\tchar, branch, turn, tick\n\t\t\t):\n\t\t\t\tfor unit in self._unitness_cache.iter_entities(\n\t\t\t\t\tchar, graph, branch, turn, tick\n\t\t\t\t):\n\t\t\t\t\tchar_kf[graph] = {\n\t\t\t\t\t\tunit: self._unitness_cache.retrieve(\n\t\t\t\t\t\t\tchar, graph, unit, branch, turn, tick\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tif graph in user_kf:\n\t\t\t\t\t\tif unit in user_kf[graph]:\n\t\t\t\t\t\t\tuser_kf[graph][unit] |= frozenset([char])\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tuser_kf[graph][unit] = frozenset([char])\n\t\t\t\t\telse:\n\t\t\t\t\t\tuser_kf[graph] = {unit: frozenset([char])}\n\n\t\t\tself._unitness_cache.set_keyframe(\n\t\t\t\tchar, branch, turn, tick, char_kf\n\t\t\t)\n\t\tfor char, kf in user_kf.items():\n\t\t\tself._unitness_cache.leader_cache.set_keyframe(\n\t\t\t\tchar, branch, turn, tick, user_kf\n\t\t\t)\n\t\trbnames = list(self._rulebooks_cache.iter_keys(branch, turn, tick))\n\t\trbs = {}\n\t\tfor rbname in rbnames:\n\t\t\ttry:\n\t\t\t\trbs[rbname] = self._rulebooks_cache.retrieve(\n\t\t\t\t\trbname, branch, turn, tick\n\t\t\t\t)\n\t\t\texcept KeyError:\n\t\t\t\trbs[rbname] = (tuple(), 0.0)\n\t\tself._rulebooks_cache.set_keyframe(branch, turn, tick, rbs)\n\t\trulenames = list(self._rules_cache)\n\t\ttrigs = {}\n\t\tpreqs = {}\n\t\tacts = {}\n\t\tnbrs = {}\n\t\tbigs = {}\n\t\tfor rule in rulenames:\n\t\t\ttry:\n\t\t\t\ttrigs[rule] = self._triggers_cache.retrieve(\n\t\t\t\t\trule, branch, turn, tick\n\t\t\t\t)\n\t\t\texcept KeyError:\n\t\t\t\ttrigs[rule] = tuple()\n\t\t\ttry:\n\t\t\t\tpreqs[rule] = self._prereqs_cache.retrieve(\n\t\t\t\t\trule, branch, turn, tick\n\t\t\t\t)\n\t\t\texcept KeyError:\n\t\t\t\tpreqs[rule] = tuple()\n\t\t\ttry:\n\t\t\t\tacts[rule] = self._actions_cache.retrieve(\n\t\t\t\t\trule, branch, turn, tick\n\t\t\t\t)\n\t\t\texcept KeyError:\n\t\t\t\tacts[rule] = tuple()\n\t\t\ttry:\n\t\t\t\tnbrs[rule] = self._neighborhoods_cache.retrieve(\n\t\t\t\t\trule, branch, turn, tick\n\t\t\t\t)\n\t\t\texcept KeyError:\n\t\t\t\tnbrs[rule] = None\n\t\t\ttry:\n\t\t\t\tbigs[rule] = self._rule_bigness_cache.retrieve(\n\t\t\t\t\trule, branch, turn, tick\n\t\t\t\t)\n\t\t\texcept KeyError:\n\t\t\t\tbigs[rule] = False\n\t\tself._triggers_cache.set_keyframe(branch, turn, tick, trigs)\n\t\tself._prereqs_cache.set_keyframe(branch, turn, tick, preqs)\n\t\tself._actions_cache.set_keyframe(branch, turn, tick, acts)\n\t\tself._neighborhoods_cache.set_keyframe(branch, turn, tick, nbrs)\n\t\tself._rule_bigness_cache.set_keyframe(branch, turn, tick, bigs)\n\t\tfor charname in all_graphs:\n\t\t\tlocs = {}\n\t\t\tconts_mut = {}\n\t\t\tfor thingname in self._things_cache.iter_things(\n\t\t\t\tcharname, branch, turn, tick\n\t\t\t):\n\t\t\t\ttry:\n\t\t\t\t\tlocname = self._things_cache.retrieve(\n\t\t\t\t\t\tcharname, thingname, branch, turn, tick\n\t\t\t\t\t)\n\t\t\t\texcept KeyError:\n\t\t\t\t\tlocname = None\n\t\t\t\tlocs[thingname] = locname\n\t\t\t\tif locname in conts_mut:\n\t\t\t\t\tconts_mut[locname].add(thingname)\n\t\t\t\telse:\n\t\t\t\t\tconts_mut[locname] = {thingname}\n\t\t\ttry:\n\t\t\t\tunits = self._graph_val_cache.retrieve(\n\t\t\t\t\tcharname, \"units\", branch, turn, tick\n\t\t\t\t)\n\t\t\texcept KeyError:\n\t\t\t\tunits = {}\n\t\t\tconts = {k: frozenset(v) for (k, v) in conts_mut.items()}\n\t\t\tself._things_cache.set_keyframe(charname, branch, turn, tick, locs)\n\t\t\tself._node_contents_cache.set_keyframe(\n\t\t\t\tcharname, branch, turn, tick, conts\n\t\t\t)\n\t\t\tself._unitness_cache.set_keyframe(\n\t\t\t\tcharname, branch, turn, tick, units\n\t\t\t)\n\t\tfor rbcache in (\n\t\t\tself._characters_rulebooks_cache,\n\t\t\tself._units_rulebooks_cache,\n\t\t\tself._characters_things_rulebooks_cache,\n\t\t\tself._characters_places_rulebooks_cache,\n\t\t\tself._characters_portals_rulebooks_cache,\n\t\t):\n\t\t\tkf = {\n\t\t\t}\n\t\t\tfor ch in all_graphs:\n\t\t\t\ttry:\n\t\t\t\t\tkf[ch] = rbcache.retrieve(ch, branch, turn, tick)\n\t\t\t\texcept KeyError:\n\t\t\t\t\tkf[ch] = (rbcache.name, ch)\n\t\t\trbcache.set_keyframe(branch, turn, tick, kf)\n\t\tself.query.keyframe_extension_insert(\n\t\t\tbranch,\n\t\t\tturn,\n\t\t\ttick,\n\t\t\tuniversal,\n\t\t\t{\n\t\t\t\t\"triggers\": trigs,\n\t\t\t\t\"prereqs\": preqs,\n\t\t\t\t\"actions\": acts,\n\t\t\t\t\"neighborhood\": nbrs,\n\t\t\t\t\"big\": bigs,\n\t\t\t},\n\t\t\trbs,\n\t\t)\n\t\tkfd = self._keyframes_dict\n\t\tself._keyframes_times.add((branch, turn, tick))\n\t\tself._keyframes_loaded.add((branch, turn, tick))\n\t\tinskf = self.query.keyframe_graph_insert\n\t\tself.query.keyframe_insert(branch, turn, tick)\n\t\tnrbcache = self._nodes_rulebooks_cache\n\t\tporbcache = self._portals_rulebooks_cache\n\t\tfor graphn in all_graphs:\n\t\t\tgraph = self.character[graphn]\n\t\t\tnodes = graph._nodes_state()\n\t\t\tedges = graph._edges_state()\n\t\t\tval = graph._val_state()\n\t\t\tnrbkf = {\n\t\t\t\tnode: nrbcache.retrieve(graphn, node, branch, turn, tick)\n\t\t\t\tfor node in nodes\n\t\t\t}\n\t\t\tfor node, rb in nrbkf.items():\n\t\t\t\tnodes[node][\"rulebook\"] = rb\n\t\t\tnrbcache.set_keyframe(\n\t\t\t\t(graphn,),\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t\tnrbkf,\n\t\t\t)\n\t\t\tporbkf = {\n\t\t\t\torig: {\n\t\t\t\t\tdest: porbcache.retrieve(\n\t\t\t\t\t\tgraphn, orig, dest, branch, turn, tick\n\t\t\t\t\t)\n\t\t\t\t\tfor dest in edges[orig]\n\t\t\t\t}\n\t\t\t\tfor orig in edges\n\t\t\t}\n\t\t\tfor orig, dests in porbkf.items():\n\t\t\t\tfor dest, rb in dests.items():\n\t\t\t\t\tedges[orig][dest][\"rulebook\"] = rb\n\t\t\tporbcache.set_keyframe(\n\t\t\t\tgraphn,\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t\ttick,\n\t\t\t\tporbkf,\n\t\t\t)\n\t\t\tinskf(graphn, branch, turn, tick, nodes, edges, val)\n\t\tif branch not in kfd:\n\t\t\tkfd[branch] = {\n\t\t\t\tturn: {\n\t\t\t\t\ttick,\n\t\t\t\t}\n\t\t\t}\n\t\telif turn not in kfd[branch]:\n\t\t\tkfd[branch][turn] = {\n\t\t\t\ttick,\n\t\t\t}\n\t\telse:\n\t\t\tkfd[branch][turn].add(tick)\n\n\tdef _snap_keyframe_de_novo_graph(\n\t\tself,\n\t\tgraph: CharName,\n\t\tbranch: Branch,\n\t\tturn: Turn,\n\t\ttick: Tick,\n\t\tnodes: NodeValDict,\n\t\tedges: EdgeValDict,\n\t\tgraph_val: StatDict,\n\t) -> None:\n\t\tfor rb_kf_type, rb_kf_cache in [\n\t\t\t(\"character_rulebook\", self._characters_rulebooks_cache),\n\t\t\t(\"unit_rulebook\", self._units_rulebooks_cache),\n\t\t\t(\n\t\t\t\t\"character_thing_rulebook\",\n\t\t\t\tself._characters_things_rulebooks_cache,\n\t\t\t),\n\t\t\t(\n\t\t\t\t\"character_place_rulebook\",\n\t\t\t\tself._characters_places_rulebooks_cache,\n\t\t\t),\n\t\t\t(\n\t\t\t\t\"character_portal_rulebook\",\n\t\t\t\tself._characters_portals_rulebooks_cache,\n\t\t\t),\n\t\t]:\n\t\t\ttry:\n\t\t\t\tkf = rb_kf_cache.get_keyframe(branch, turn, tick)\n\t\t\texcept KeyError:\n\t\t\t\tkf = {}\n\t\t\tkf[graph] = graph_val.pop(rb_kf_type, (rb_kf_type, graph))\n\t\t\trb_kf_cache.set_keyframe(branch, turn, tick, kf)\n\t\tunits_kf = graph_val.pop(\"units\", {})\n\t\tself._unitness_cache.set_keyframe(graph, branch, turn, tick, units_kf)\n\t\tfor char, units in units_kf.items():\n\t\t\ttry:\n\t\t\t\tuser_kf = self._unitness_cache.leader_cache.get_keyframe(\n\t\t\t\t\tchar, branch, turn, tick, copy=True\n\t\t\t\t)\n\t\t\texcept KeyframeError:\n\t\t\t\tuser_kf = {}\n\t\t\tfor unit in units:\n\t\t\t\tif unit in user_kf:\n\t\t\t\t\tuser_kf[unit] |= frozenset([graph])\n\t\t\t\telse:\n\t\t\t\t\tuser_kf[unit] = frozenset([graph])\n\t\t\tself._unitness_cache.leader_cache.set_keyframe(\n\t\t\t\tchar, branch, turn, tick, user_kf\n\t\t\t)\n\t\tnode_rb_kf = {}\n\t\tlocs_kf = {}\n\t\tconts_kf = {}\n\t\tfor unit, val in nodes.items():\n\t\t\tnode_rb_kf[unit] = val.pop(\"rulebook\", (graph, unit))\n\t\t\tif \"location\" not in val:\n\t\t\t\tcontinue\n\t\t\tlocs_kf[unit] = location = val[\"location\"]\n\t\t\tif location in conts_kf:\n\t\t\t\tconts_kf[location].add(unit)\n\t\t\telse:\n\t\t\t\tconts_kf[location] = {unit}\n\t\tself._nodes_rulebooks_cache.set_keyframe(\n\t\t\tgraph, branch, turn, tick, node_rb_kf\n\t\t)\n\t\tself._things_cache.set_keyframe(graph, branch, turn, tick, locs_kf)\n\t\tself._node_contents_cache.set_keyframe(\n\t\t\tgraph,\n\t\t\tbranch,\n\t\t\tturn,\n\t\t\ttick,\n\t\t\t{n: frozenset(conts) for (n, conts) in conts_kf.items()},\n\t\t)\n\t\tport_rb_kf = {}\n\t\tfor orig, dests in edges.items():\n\t\t\tif not dests:\n\t\t\t\tcontinue\n\t\t\tport_rb_kf[orig] = rbs = {}\n\t\t\tfor dest, port in dests.items():\n\t\t\t\trbs[dest] = port.pop(\"rulebook\", (graph, orig, dest))\n\t\tself._portals_rulebooks_cache.set_keyframe(\n\t\t\tgraph,\n\t\t\tbranch,\n\t\t\tturn,\n\t\t\ttick,\n\t\t\tport_rb_kf,\n\t\t)\n\t\ttry:\n\t\t\tgraphs_keyframe = self._graph_cache.get_keyframe(\n\t\t\t\tbranch, turn, tick\n\t\t\t)\n\t\texcept KeyframeError:\n\t\t\tgraphs_keyframe = {\n\t\t\t\tg: \"DiGraph\"\n\t\t\t\tfor g in self._graph_cache.iter_keys(branch, turn, tick)\n\t\t\t}\n\t\tgraphs_keyframe[graph] = \"DiGraph\"\n\t\tself._graph_cache.set_keyframe(branch, turn, tick, graphs_keyframe)\n\t\tself._graph_cache.keycache.clear()\n\t\tself._nodes_cache.set_keyframe(\n\t\t\tgraph, branch, turn, tick, {node: True for node in nodes}\n\t\t)\n\t\tself._node_val_cache.set_keyframe(graph, branch, turn, tick, nodes)\n\t\tself._edges_cache.set_keyframe(\n\t\t\tgraph,\n\t\t\tbranch,\n\t\t\tturn,\n\t\t\ttick,\n\t\t\t{\n\t\t\t\torig: {dest: True for dest in edges[orig]}\n\t\t\t\tfor orig in edges\n\t\t\t\tif edges[orig]\n\t\t\t},\n\t\t)\n\t\tself._edge_val_cache.set_keyframe(graph, branch, turn, tick, edges)\n\t\tself._graph_val_cache.set_keyframe(\n\t\t\tgraph, branch, turn, tick, graph_val\n\t\t)\n\t\tif (branch, turn, tick) not in self._keyframes_times:\n\t\t\tself._keyframes_times.add((branch, turn, tick))\n\t\t\tself._keyframes_loaded.add((branch, turn, tick))\n\t\t\tif branch in self._keyframes_dict:\n\t\t\t\tturns = self._keyframes_dict[branch]\n\t\t\t\tif turn in turns:\n\t\t\t\t\tturns[turn].add(tick)\n\t\t\t\telse:\n\t\t\t\t\tturns[turn] = {tick}\n\t\t\telse:\n\t\t\t\tself._keyframes_dict[branch] = {turn: {tick}}\n\t\tassert (\n\t\t\t(graph,) in self._things_cache.keyframe\n\t\t\tand branch in self._things_cache.keyframe[graph,]\n\t\t\tand turn in self._things_cache.keyframe[graph,][branch]\n\t\t\tand tick in self._things_cache.keyframe[graph,][branch][turn]\n\t\t)\n\n\tdef flush(self) -> None:\n\t\t\"\"\"Write pending changes to disk.\n\n\t\tYou can set a ``flush_interval`` when you instantiate ``Engine``\n\t\tto call this every so many turns. However, this may cause your game to\n\t\thitch up sometimes, so it's better to call ``flush`` when you know the\n\t\tplayer won't be running the simulation for a while.\n\n\t\t\"\"\"\n\t\tturn_end = self._turn_end\n\t\tset_turn = self.query.set_turn\n\t\tif self._turn_end_plan.changed:\n\t\t\tfor (\n\t\t\t\tbranch,\n\t\t\t\tturn,\n\t\t\t), plan_end_tick in self._turn_end_plan.changed.items():\n\t\t\t\tset_turn(branch, turn, turn_end[branch, turn], plan_end_tick)\n\t\t\tself._turn_end_plan.apply_changes()\n\t\tset_branch = self.query.set_branch\n\t\tif self._branches_d.changed:\n\t\t\tfor branch, (\n\t\t\t\tparent,\n\t\t\t\tturn_start,\n\t\t\t\ttick_start,\n\t\t\t\tturn_end,\n\t\t\t\ttick_end,\n\t\t\t) in self._branches_d.changed.items():\n\t\t\t\tset_branch(\n\t\t\t\t\tbranch, parent, turn_start, tick_start, turn_end, tick_end\n\t\t\t\t)\n\t\t\tself._branches_d.apply_changes()\n\t\tself.query.flush()\n\n\t@world_locked\n\tdef commit(self, unload: bool = True) -> None:\n\t\t\"\"\"Write the state of all graphs and commit the transaction.\n\n\t\tAlso saves the current branch, turn, and tick.\n\n\t\tCall with ``unload=False`` if you want to keep the written state in memory.\n\n\t\t\"\"\"\n\t\tself.query.globl[\"branch\"] = self._obranch\n\t\tself.query.globl[\"turn\"] = self._oturn\n\t\tself.query.globl[\"tick\"] = self._otick\n\t\tself.flush()\n\t\tself.query.commit()\n\t\tif unload:\n\t\t\tself.unload()\n\n\tdef turns_when(\n\t\tself, qry: Query, mid_turn: bool = False\n\t) -> QueryResult | set:\n\t\t\"\"\"Return the turns when the query held true\n\n\t\tOnly the state of the world at the end of the turn is considered.\n\t\tTo include turns where the query held true at some tick, but\n\t\tbecame false, set ``mid_turn=True``\n\n\t\t:arg qry: a Query, likely constructed by comparing the result\n\t\t\t\t  of a call to an entity's ``historical`` method with\n\t\t\t\t  the output of ``self.alias(..)`` or another\n\t\t\t\t  ``historical(..)``\n\n\t\t\"\"\"\n\t\tunpack = self.unpack\n\t\tend = self._branch_end()[0] + 1\n\n\t\tdef unpack_data_mid(data):\n\t\t\treturn [\n\t\t\t\t((turn_from, tick_from), (turn_to, tick_to), unpack(v))\n\t\t\t\tfor (turn_from, tick_from, turn_to, tick_to, v) in data\n\t\t\t]\n\n\t\tdef unpack_data_end(data):\n\t\t\treturn [\n\t\t\t\t(turn_from, turn_to, unpack(v))\n\t\t\t\tfor (turn_from, _, turn_to, _, v) in data\n\t\t\t]\n\n\t\tif not isinstance(qry, ComparisonQuery):\n\t\t\tif not isinstance(qry, CompoundQuery):\n\t\t\t\traise TypeError(\"Unsupported query type: \" + repr(type(qry)))\n\t\t\treturn CombinedQueryResult(\n\t\t\t\tself.turns_when(qry.leftside, mid_turn),\n\t\t\t\tself.turns_when(qry.rightside, mid_turn),\n\t\t\t\tqry.oper,\n\t\t\t)\n\t\tself.flush()\n\t\tbranches = list({branch for branch, _, _ in self._iter_parent_btt()})\n\t\tleft = qry.leftside\n\t\tright = qry.rightside\n\t\tif isinstance(\n\t\t\tleft, (EntityStatAccessor, CharacterStatAccessor)\n\t\t) and isinstance(right, (EntityStatAccessor, CharacterStatAccessor)):\n\t\t\tleft_sel = _make_side_sel(\n\t\t\t\tleft.entity, left.stat, branches, self.pack, mid_turn\n\t\t\t)\n\t\t\tright_sel = _make_side_sel(\n\t\t\t\tright.entity, right.stat, branches, self.pack, mid_turn\n\t\t\t)\n\t\t\tleft_data = self.query.execute(left_sel)\n\t\t\tright_data = self.query.execute(right_sel)\n\t\t\tif mid_turn:\n\t\t\t\treturn QueryResultMidTurn(\n\t\t\t\t\tunpack_data_mid(left_data),\n\t\t\t\t\tunpack_data_mid(right_data),\n\t\t\t\t\tqry.oper,\n\t\t\t\t\tend,\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\treturn QueryResultEndTurn(\n\t\t\t\t\tunpack_data_end(left_data),\n\t\t\t\t\tunpack_data_end(right_data),\n\t\t\t\t\tqry.oper,\n\t\t\t\t\tend,\n\t\t\t\t)\n\t\telif isinstance(left, (EntityStatAccessor, CharacterStatAccessor)):\n\t\t\tleft_sel = _make_side_sel(\n\t\t\t\tleft.entity, left.stat, branches, self.pack, mid_turn\n\t\t\t)\n\t\t\tleft_data = self.query.execute(left_sel)\n\t\t\tif mid_turn:\n\t\t\t\treturn QueryResultMidTurn(\n\t\t\t\t\tunpack_data_mid(left_data),\n\t\t\t\t\t[(0, 0, None, None, right)],\n\t\t\t\t\tqry.oper,\n\t\t\t\t\tend,\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\treturn QueryResultEndTurn(\n\t\t\t\t\tunpack_data_end(left_data),\n\t\t\t\t\t[(0, None, right)],\n\t\t\t\t\tqry.oper,\n\t\t\t\t\tend,\n\t\t\t\t)\n\t\telif isinstance(right, (EntityStatAccessor, CharacterStatAccessor)):\n\t\t\tright_sel = _make_side_sel(\n\t\t\t\tright.entity, right.stat, branches, self.pack, mid_turn\n\t\t\t)\n\t\t\tright_data = self.query.execute(right_sel)\n\t\t\tif mid_turn:\n\t\t\t\treturn QueryResultMidTurn(\n\t\t\t\t\t[(0, 0, None, None, left)],\n\t\t\t\t\tunpack_data_mid(right_data),\n\t\t\t\t\tqry.oper,\n\t\t\t\t\tend,\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\treturn QueryResultEndTurn(\n\t\t\t\t\t[(0, None, left)],\n\t\t\t\t\tunpack_data_end(right_data),\n\t\t\t\t\tqry.oper,\n\t\t\t\t\tend,\n\t\t\t\t)\n\t\telse:\n\t\t\tif qry.oper(left, right):\n\t\t\t\treturn set(range(0, self.turn))\n\t\t\telse:\n\t\t\t\treturn set()\n\n\tdef _node_contents(self, character: CharName, node: NodeName) -> set:\n\t\treturn self._node_contents_cache.retrieve(\n\t\t\tcharacter, node, *self._btt()\n\t\t)\n\n\tdef apply_choices(\n\t\tself,\n\t\tchoices: list[dict],\n\t\tdry_run: bool = False,\n\t\tperfectionist: bool = False,\n\t) -> tuple[list[tuple[Any, Any]], list[tuple[Any, Any]]]:\n\t\t\"\"\"Validate changes a player wants to make, and apply if acceptable.\n\n\t\tArgument ``choices`` is a list of dictionaries, of which each must\n\t\thave values for ``\"entity\"`` (a lisien entity) and ``\"changes\"``\n\t\t-- the later being a list of lists of pairs. Each change list\n\t\tis applied on a successive turn, and each pair ``(key, value)``\n\t\tsets a key on the entity to a value on that turn.\n\n\t\tReturns a pair of lists containing acceptance and rejection messages,\n\t\twhich the UI may present as it sees fit. They are always in a pair\n\t\twith the change request as the zeroth item. The message may be None\n\t\tor a string.\n\n\t\tValidator functions may return only a boolean indicating acceptance.\n\t\tIf they instead return a pair, the initial boolean indicates\n\t\tacceptance and the following item is the message.\n\n\t\tThis function will not actually result in any simulation happening.\n\t\tIt creates a plan. See my ``plan`` context manager for the precise\n\t\tmeaning of this.\n\n\t\tWith ``dry_run=True`` just return the acceptances and rejections\n\t\twithout really planning anything. With ``perfectionist=True`` apply\n\t\tchanges if and only if all of them are accepted.\n\n\t\t\"\"\"\n\t\tschema = self.schema\n\t\ttodo = defaultdict(list)\n\t\tacceptances = []\n\t\trejections = []\n\t\tfor track in choices:\n\t\t\tentity = track[\"entity\"]\n\t\t\tpermissible = schema.entity_permitted(entity)\n\t\t\tif isinstance(permissible, tuple):\n\t\t\t\tpermissible, msg = permissible\n\t\t\telse:\n\t\t\t\tmsg = \"\"\n\t\t\tif not permissible:\n\t\t\t\tfor turn, changes in enumerate(\n\t\t\t\t\ttrack[\"changes\"], start=self.turn + 1\n\t\t\t\t):\n\t\t\t\t\trejections.extend(\n\t\t\t\t\t\t((turn, entity, k, v), msg) for (k, v) in changes\n\t\t\t\t\t)\n\t\t\t\tcontinue\n\t\t\tfor turn, changes in enumerate(\n\t\t\t\ttrack[\"changes\"], start=self.turn + 1\n\t\t\t):\n\t\t\t\tfor k, v in changes:\n\t\t\t\t\tekv = (entity, k, v)\n\t\t\t\t\tparcel = (turn, entity, k, v)\n\t\t\t\t\tval = schema.stat_permitted(*parcel)\n\t\t\t\t\tif type(val) is tuple:\n\t\t\t\t\t\taccept, message = val\n\t\t\t\t\t\tif accept:\n\t\t\t\t\t\t\ttodo[turn].append(ekv)\n\t\t\t\t\t\t\tl = acceptances\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tl = rejections\n\t\t\t\t\t\tl.append((parcel, message))\n\t\t\t\t\telif val:\n\t\t\t\t\t\ttodo[turn].append(ekv)\n\t\t\t\t\t\tacceptances.append((parcel, None))\n\t\t\t\t\telse:\n\t\t\t\t\t\trejections.append((parcel, None))\n\t\tif dry_run or (perfectionist and rejections):\n\t\t\treturn acceptances, rejections\n\t\tnow = self.turn\n\t\twith self.plan():\n\t\t\tfor turn in sorted(todo):\n\t\t\t\tself.turn = turn\n\t\t\t\tfor entity, key, value in todo[turn]:\n\t\t\t\t\tif isinstance(entity, self.char_cls):\n\t\t\t\t\t\tentity.stat[key] = value\n\t\t\t\t\telse:\n\t\t\t\t\t\tentity[key] = value\n\t\tself.turn = now\n\t\treturn acceptances, rejections\n\n\tdef game_start(self) -> None:\n\t\timport importlib.machinery\n\t\timport importlib.util\n\n\t\tloader = importlib.machinery.SourceFileLoader(\n\t\t\t\"game_start\", os.path.join(self._prefix, \"game_start.py\")\n\t\t)\n\t\tspec = importlib.util.spec_from_loader(\"game_start\", loader)\n\t\tgame_start = importlib.util.module_from_spec(spec)\n\t\tloader.exec_module(game_start)\n\t\tgame_start.game_start(self)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lisien/lisien/engine.py b/lisien/lisien/engine.py
--- a/lisien/lisien/engine.py	(revision 88a2449a682cf4ee82f65c7754adf3cbed014cf5)
+++ b/lisien/lisien/engine.py	(date 1756323386150)
@@ -933,9 +933,7 @@
 
 	@cached_property
 	def _characters_rulebooks_cache(self) -> CharactersRulebooksCache:
-		return CharactersRulebooksCache(
-			self, name="character_rulebook"
-		)
+		return CharactersRulebooksCache(self, name="character_rulebook")
 
 	@cached_property
 	def _units_rulebooks_cache(self) -> CharactersRulebooksCache:
@@ -943,15 +941,11 @@
 
 	@cached_property
 	def _characters_things_rulebooks_cache(self) -> CharactersRulebooksCache:
-		return CharactersRulebooksCache(
-			self, name="character_thing_rulebook"
-		)
+		return CharactersRulebooksCache(self, name="character_thing_rulebook")
 
 	@cached_property
 	def _characters_places_rulebooks_cache(self) -> CharactersRulebooksCache:
-		return CharactersRulebooksCache(
-			self, name="character_place_rulebook"
-		)
+		return CharactersRulebooksCache(self, name="character_place_rulebook")
 
 	@cached_property
 	def _characters_portals_rulebooks_cache(self) -> CharactersRulebooksCache:
@@ -6669,8 +6663,7 @@
 			self._characters_places_rulebooks_cache,
 			self._characters_portals_rulebooks_cache,
 		):
-			kf = {
-			}
+			kf = {}
 			for ch in all_graphs:
 				try:
 					kf[ch] = rbcache.retrieve(ch, branch, turn, tick)
Index: lisien/pyproject.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[build-system]\nrequires = [\"setuptools>=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools]\ninclude-package-data=true\npackages = [\"lisien\", \"lisien.examples\", \"lisien.proxy\", \"lisien.server\", \"lisien.tests\"]\n\n\n[project]\nname = \"lisien\"\nversion = \"0.21.4\"\nauthors = [\n\t{ name=\"Zachary Spector\", email=\"public@zacharyspector.com\" },\n]\ndescription = \"Life Simulator Engine\"\nreadme = \"README.md\"\nlicense = { file = \"LICENSE\" }\nrequires-python = \"~=3.10\"\nclassifiers = [\n\t\"Programming Language :: Python :: 3\",\n\t\"License :: OSI Approved :: GNU Affero General Public License v3\",\n\t\"Operating System :: OS Independent\",\n\t\"Topic :: Software Development :: Libraries\",\n\t\"Development Status :: 2 - Pre-Alpha\"\n]\ndependencies = [\n\t\"astunparse~=1.6.3\",\n\t\"blinker~=1.4\",\n\t\"msgpack~=1.0.0\",\n\t\"networkx~=2.4\",\n\t\"sqlalchemy~=2.0\",\n\t\"numpy~=1.26.4\",\n\t\"tblib~=1.7.0\",\n\t\"parquetdb~=1.0.1\",\n\t\"annotated-types~=0.7.0\"\n]\n\n[project.urls]\n\"Homepage\" = \"https://codeberg.org/clayote/lisien\"\n\"Bug Tracker\" = \"https://codeberg.org/clayote/lisien/issues\"\n\n[tool.pytest.ini_options]\nmarkers = [\n    \"slow: marks tests as slow (deselect with '-m \\\"not slow\\\"')\",\n\t\"big: marks tests as too big to diagnose specific bugs with\",\n\t\"sqlite: marks tests that exercise the SQLite database backend\",\n\t\"parquetdb: marks tests that exercise the ParquetDB database backend\",\n\t\"parallel: marks tests that use the process pool\"\n]\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lisien/pyproject.toml b/lisien/pyproject.toml
--- a/lisien/pyproject.toml	(revision 88a2449a682cf4ee82f65c7754adf3cbed014cf5)
+++ b/lisien/pyproject.toml	(date 1756277794094)
@@ -9,7 +9,7 @@
 
 [project]
 name = "lisien"
-version = "0.21.4"
+version = "0.21.5"
 authors = [
 	{ name="Zachary Spector", email="public@zacharyspector.com" },
 ]
Index: elide/pyproject.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[build-system]\nrequires = [\"setuptools>=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools]\ninclude-package-data=true\npackages = [\"elide\", \"elide.graph\", \"elide.grid\", \"elide.kivygarden.texturestack\", \"elide.tests\"]\n\n[project]\nname = \"elide\"\nversion = \"0.21.4\"\nauthors = [\n\t{ name=\"Zachary Spector\", email=\"public@zacharyspector.com\" },\n]\ndescription = \"Extensible Life Simulator Engine Development Environment\"\nreadme = \"README.md\"\nlicense = { file = \"LICENSE\" }\nrequires-python = \">=3.10,<3.14\"\nclassifiers = [\n\t\"Programming Language :: Python :: 3\",\n\t\"License :: OSI Approved :: GNU Affero General Public License v3\",\n\t\"Operating System :: OS Independent\",\n\t\"Development Status :: 2 - Pre-Alpha\"\n]\ndependencies = [\n\t\"lisien==0.21.4\",\n\t\"kivy>=2.0.0,<3\",\n\t\"kivy_garden.collider\",\n\t\"kivy-deps.glew ; sys_platform == 'win32'\",\n\t\"kivy-deps.sdl2 ; sys_platform == 'win32'\",\n\t\"pygments>=2.7.4\"\n]\n\n[project.urls]\n\"Homepage\" = \"https://codeberg.org/clayote/LiSE\"\n\"Bug Tracker\" = \"https://codeberg.org/clayote/LiSE/issues\"\n\n[tool.pytest.ini_options]\nmarkers = [\n    \"slow: marks tests as slow (deselect with '-m \\\"not slow\\\"')\",\n\t\"big: marks tests as too big to diagnose specific bugs with\"\n]\nasyncio_default_fixture_loop_scope = \"function\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/elide/pyproject.toml b/elide/pyproject.toml
--- a/elide/pyproject.toml	(revision 88a2449a682cf4ee82f65c7754adf3cbed014cf5)
+++ b/elide/pyproject.toml	(date 1756277794104)
@@ -8,7 +8,7 @@
 
 [project]
 name = "elide"
-version = "0.21.4"
+version = "0.21.5"
 authors = [
 	{ name="Zachary Spector", email="public@zacharyspector.com" },
 ]
@@ -23,7 +23,7 @@
 	"Development Status :: 2 - Pre-Alpha"
 ]
 dependencies = [
-	"lisien==0.21.4",
+	"lisien==0.21.5",
 	"kivy>=2.0.0,<3",
 	"kivy_garden.collider",
 	"kivy-deps.glew ; sys_platform == 'win32'",
